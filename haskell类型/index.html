<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="QiET7ttAHFoc3bMl0cmzBIzJBawh36AmKvy_PU89Nz4">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"nebulyu.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12,"onmobile":false},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":null,"post_block":null,"post_header":null,"post_body":null,"coll_header":null,"sidebar":"fadeInDown"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":3,"unescape":false,"preload":false,"trigger":"auto","swiftype_key":null}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Haskell 类型数据类型定义基础数据类型1data Bool &#x3D; False | True 在 Haskell 中，data 用于定义新的数据类型。等号前面的部分是类型名 Bool，等号后面的部分是值构造器。这里 False 和 True 是两个值构造器，分别表示布尔类型的可能值。| 可以理解为“或”。 注意： 类型名和值构造器都需要以大写字母开头。 自定义数据类型示例1data Shape">
<meta property="og:type" content="article">
<meta property="og:title" content="haskell类型">
<meta property="og:url" content="https://nebulyu.github.io/haskell%E7%B1%BB%E5%9E%8B/index.html">
<meta property="og:site_name" content="Nebulyu&#39;s Blog">
<meta property="og:description" content="Haskell 类型数据类型定义基础数据类型1data Bool &#x3D; False | True 在 Haskell 中，data 用于定义新的数据类型。等号前面的部分是类型名 Bool，等号后面的部分是值构造器。这里 False 和 True 是两个值构造器，分别表示布尔类型的可能值。| 可以理解为“或”。 注意： 类型名和值构造器都需要以大写字母开头。 自定义数据类型示例1data Shape">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-12-04T00:00:00.000Z">
<meta property="article:modified_time" content="2024-12-05T00:12:12.078Z">
<meta property="article:author" content="nebulyu">
<meta property="article:tag" content="haskell">
<meta property="article:tag" content="语法">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://nebulyu.github.io/haskell%E7%B1%BB%E5%9E%8B/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://nebulyu.github.io/haskell%E7%B1%BB%E5%9E%8B/","path":"haskell类型/","title":"haskell类型"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>haskell类型 | Nebulyu's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Nebulyu's Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">归档站</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-categories"><a href="/categories/" rel="section">Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section">Archives</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section">links</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger">Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="Searching..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Haskell-%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">Haskell 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="nav-number">1.1.</span> <span class="nav-text">数据类型定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.1.</span> <span class="nav-text">基础数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.1.2.</span> <span class="nav-text">自定义数据类型示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.3.</span> <span class="nav-text">自动派生类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.4.</span> <span class="nav-text">嵌套数据类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="nav-number">1.2.</span> <span class="nav-text">类型参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.2.1.</span> <span class="nav-text">基础示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E7%B1%BB"><span class="nav-number">1.3.</span> <span class="nav-text">类型类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%9E%8B%E7%B1%BB%EF%BC%9F"><span class="nav-number">1.3.1.</span> <span class="nav-text">什么是类型类？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.3.2.</span> <span class="nav-text">创建实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B%E7%B1%BB"><span class="nav-number">1.3.3.</span> <span class="nav-text">常见类型类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.3.4.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Functor"><span class="nav-number">1.4.</span> <span class="nav-text">Functor</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">1.4.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">1.4.2.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.</span> <span class="nav-text">递归数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%97%E8%A1%A8"><span class="nav-number">1.5.1.</span> <span class="nav-text">列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">1.5.2.</span> <span class="nav-text">树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Haskell-%E7%B1%BB%E5%9E%8B-1"><span class="nav-number">2.</span> <span class="nav-text">Haskell 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#data"><span class="nav-number">2.1.</span> <span class="nav-text">data</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#type-para"><span class="nav-number">2.2.</span> <span class="nav-text">type para</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Typeclass"><span class="nav-number">2.3.</span> <span class="nav-text">Typeclass</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Synonyms"><span class="nav-number">2.4.</span> <span class="nav-text">Synonyms</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#recursive"><span class="nav-number">2.5.</span> <span class="nav-text">recursive</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Create-Typeclass"><span class="nav-number">2.6.</span> <span class="nav-text">Create Typeclass</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#example"><span class="nav-number">2.7.</span> <span class="nav-text">example</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#functor"><span class="nav-number">2.8.</span> <span class="nav-text">functor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kinds"><span class="nav-number">2.9.</span> <span class="nav-text">kinds</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">nebulyu</p>
  <div class="site-description" itemprop="description">施工中(*>.<*)</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://nebulyu.github.io/haskell%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nebulyu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nebulyu's Blog">
      <meta itemprop="description" content="施工中(*>.<*)">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="haskell类型 | Nebulyu's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          haskell类型
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-12-04 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-04T00:00:00+00:00">2024-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-12-05 00:12:12" itemprop="dateModified" datetime="2024-12-05T00:12:12+00:00">2024-12-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/haskell/" itemprop="url" rel="index"><span itemprop="name">haskell</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="Haskell-类型"><a href="#Haskell-类型" class="headerlink" title="Haskell 类型"></a>Haskell 类型</h1><h2 id="数据类型定义"><a href="#数据类型定义" class="headerlink" title="数据类型定义"></a>数据类型定义</h2><h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Bool</span> = <span class="type">False</span> | <span class="type">True</span></span></span><br></pre></td></tr></table></figure>
<p>在 Haskell 中，<code>data</code> 用于定义新的数据类型。等号前面的部分是类型名 <code>Bool</code>，等号后面的部分是值构造器。这里 <code>False</code> 和 <code>True</code> 是两个值构造器，分别表示布尔类型的可能值。<code>|</code> 可以理解为“或”。</p>
<p><strong>注意：</strong> 类型名和值构造器都需要以大写字母开头。</p>
<h3 id="自定义数据类型示例"><a href="#自定义数据类型示例" class="headerlink" title="自定义数据类型示例"></a>自定义数据类型示例</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> | <span class="type">Rectangle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>Circle</code> 和 <code>Rectangle</code> 是值构造器，实际上是函数。它们分别接受类型为 <code>Float</code> 的参数。</li>
<li><code>Shape</code> 是类型名，用于表示几何形状。</li>
</ul>
<p>我们可以基于 <code>Shape</code> 类型定义函数，例如：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">surface</span> :: <span class="type">Shape</span> -&gt; <span class="type">Float</span></span><br><span class="line"><span class="title">surface</span> (<span class="type">Circle</span> _ _ r) = pi * r ^ <span class="number">2</span></span><br><span class="line"><span class="title">surface</span> (<span class="type">Rectangle</span> x1 y1 x2 y2) = (abs $ x2 - x1) * (abs $ y2 - y1)</span><br></pre></td></tr></table></figure>
<p>上述 <code>surface</code> 函数用于计算 <code>Shape</code> 的表面积。</p>
<h3 id="自动派生类型"><a href="#自动派生类型" class="headerlink" title="自动派生类型"></a>自动派生类型</h3><p>使用 <code>deriving</code> 关键字可以为数据类型自动生成某些类型类的实例，例如：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure>
<p>这样，<code>Shape</code> 类型的值可以直接打印。</p>
<h3 id="嵌套数据类型"><a href="#嵌套数据类型" class="headerlink" title="嵌套数据类型"></a>嵌套数据类型</h3><p>我们可以通过组合数据类型来定义更复杂的结构：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Point</span> = <span class="type">Point</span> <span class="type">Float</span> <span class="type">Float</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Point</span> <span class="type">Float</span> | <span class="type">Rectangle</span> <span class="type">Point</span> <span class="type">Point</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure>
<p>这里 <code>Point</code> 类型用于表示二维空间中的点，而 <code>Shape</code> 类型通过组合 <code>Point</code> 定义了更加具体的几何形状。</p>
<h2 id="类型参数"><a href="#类型参数" class="headerlink" title="类型参数"></a>类型参数</h2><h3 id="基础示例"><a href="#基础示例" class="headerlink" title="基础示例"></a>基础示例</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Maybe</span> a = <span class="type">Nothing</span> | <span class="type">Just</span> a</span></span><br></pre></td></tr></table></figure>
<p><code>Maybe</code> 是一个带有类型参数 <code>a</code> 的数据类型。根据 <code>a</code> 的不同，<code>Maybe</code> 可以表示不同的类型。例如：</p>
<ul>
<li><code>Maybe Int</code> 表示可能包含整数的值。</li>
<li><code>Maybe String</code> 表示可能包含字符串的值。</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Vector</span> a = <span class="type">Vector</span> a a a <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure>
<p>上例中，<code>Vector</code> 是一个类型构造器，<code>a</code> 是类型参数。它可以用于定义三维向量。</p>
<h2 id="类型类"><a href="#类型类" class="headerlink" title="类型类"></a>类型类</h2><h3 id="什么是类型类？"><a href="#什么是类型类？" class="headerlink" title="什么是类型类？"></a>什么是类型类？</h3><p>类型类类似于接口，用于定义一组行为。我们可以为自定义数据类型实现这些行为。例如：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Eq</span> a <span class="keyword">where</span></span></span><br><span class="line">    (==) :: a -&gt; a -&gt; <span class="type">Bool</span></span><br><span class="line">    (/=) :: a -&gt; a -&gt; <span class="type">Bool</span></span><br><span class="line">    x /= y = not (x == y)</span><br><span class="line">    x == y = not (x /= y)</span><br></pre></td></tr></table></figure>
<h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><p>以交通信号灯为例：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">TrafficLight</span> = <span class="type">Red</span> | <span class="type">Yellow</span> | <span class="type">Green</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Eq</span> <span class="type">TrafficLight</span> <span class="keyword">where</span></span></span><br><span class="line">    <span class="type">Red</span> == <span class="type">Red</span> = <span class="type">True</span></span><br><span class="line">    <span class="type">Yellow</span> == <span class="type">Yellow</span> = <span class="type">True</span></span><br><span class="line">    <span class="type">Green</span> == <span class="type">Green</span> = <span class="type">True</span></span><br><span class="line">    _ == _ = <span class="type">False</span></span><br></pre></td></tr></table></figure>
<p>这里我们为 <code>TrafficLight</code> 类型实现了 <code>Eq</code> 类型类。</p>
<h3 id="常见类型类"><a href="#常见类型类" class="headerlink" title="常见类型类"></a>常见类型类</h3><ul>
<li><code>Eq</code>：支持相等性判断。</li>
<li><code>Ord</code>：支持排序。</li>
<li><code>Show</code>：支持打印。</li>
<li><code>Read</code>：支持从字符串解析值。</li>
<li><code>Enum</code>：支持枚举。</li>
<li><code>Bounded</code>：支持定义上下界。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Day</span> = <span class="type">Monday</span> | <span class="type">Tuesday</span> | <span class="type">Wednesday</span> | <span class="type">Thursday</span> | <span class="type">Friday</span> | <span class="type">Saturday</span> | <span class="type">Sunday</span> </span></span><br><span class="line">           <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>, <span class="type">Show</span>, <span class="type">Read</span>, <span class="type">Bounded</span>, <span class="type">Enum</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="type">Thursday</span> .. <span class="type">Sunday</span>]</span><br><span class="line">[<span class="type">Thursday</span>,<span class="type">Friday</span>,<span class="type">Saturday</span>,<span class="type">Sunday</span>]</span><br></pre></td></tr></table></figure>
<h2 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><code>Functor</code> 是一个常见的类型类，定义如下：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line">    fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></table></figure>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">    fmap f (<span class="type">Just</span> x) = <span class="type">Just</span> (f x)</span><br><span class="line">    fmap f <span class="type">Nothing</span> = <span class="type">Nothing</span></span><br></pre></td></tr></table></figure>
<p><code>fmap</code> 是 <code>Functor</code> 的核心函数，用于将函数应用到容器内的值。</p>
<h2 id="递归数据结构"><a href="#递归数据结构" class="headerlink" title="递归数据结构"></a>递归数据结构</h2><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">List</span> a = <span class="type">Empty</span> | <span class="type">Cons</span> a (<span class="type">List</span> <span class="title">a</span>) <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Read</span>, <span class="type">Eq</span>, <span class="type">Ord</span>)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>Empty</code> 表示空列表。</li>
<li><code>Cons</code> 是构造器，用于将元素添加到列表。</li>
</ul>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tree</span> a = <span class="type">EmptyTree</span> | <span class="type">Node</span> a (<span class="type">Tree</span> <span class="title">a</span>) (<span class="type">Tree</span> <span class="title">a</span>) <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Read</span>, <span class="type">Eq</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="title">singleton</span> :: a -&gt; <span class="type">Tree</span> a</span><br><span class="line"><span class="title">singleton</span> x = <span class="type">Node</span> x <span class="type">EmptyTree</span> <span class="type">EmptyTree</span></span><br></pre></td></tr></table></figure>
<p>通过递归的方式，我们可以非常优雅地操作树结构。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Haskell 提供了强大的类型系统和类型类机制，使得代码更加安全和灵活。熟练使用这些特性可以帮助我们构建更复杂的应用。</p>
<h1 id="Haskell-类型-1"><a href="#Haskell-类型-1" class="headerlink" title="Haskell 类型"></a>Haskell 类型</h1><h2 id="data"><a href="#data" class="headerlink" title="data"></a>data</h2><p>data Bool = False | True<br>data means that we’re defining a new data type. The part before the = denotes the type, which is Bool. The parts after the = are value constructors. They specify the different values that this type can have. The | is read as or. So we can read this as: the Bool type can have a value of True or False. Both the type name and the value constructors have to be capital cased.</p>
<p>data Shape = Circle Float Float Float | Rectangle Float Float Float Float,:<br>Circle Rectange 均为value constructor, 本质函数, 后面的类型是传入值</p>
<p>surface :: Shape -&gt; Float<br>surface (Circle _ _ r) = pi <em> r ^ 2<br>surface (Rectangle x1 y1 x2 y2) = (abs $ x2 - x1) </em> (abs $ y2 - y1)</p>
<p>deriving type<br>data Shape = Circle Float Float Float deriving (Show)</p>
<p>composition<br>data Point = Point Float Float deriving (Show)<br>data Shape = Circle Point Float | Rectangle Point Point deriving (Show)</p>
<p>Notice that when defining a point, we used the same name for the data type and the value constructor. This has no special meaning, although it’s common to use the same name as the type if there’s only one value constructor. </p>
<p>nudge :: Shape -&gt; Float -&gt; Float -&gt; Shape<br>nudge (Circle (Point x y) r) a b = Circle (Point (x+a) (y+b)) r</p>
<p>export<br>module Shapes<br>( Point(..)<br>, Shape(..)<br>, surface<br>, nudge<br>, baseCircle<br>, baseRect<br>) where</p>
<p>data Person = Person String String Int Float String String deriving (Show)</p>
<p>data Person = Person { firstName :: String<br>                     , lastName :: String<br>                     , age :: Int<br>                     , height :: Float<br>                     , phoneNumber :: String<br>                     , flavor :: String<br>                     } deriving (Show)<br>we don’t have to necessarily put the fields in the proper order, as long as we list all of them. But if we don’t use record syntax, we have to specify them in order.</p>
<h2 id="type-para"><a href="#type-para" class="headerlink" title="type para"></a>type para</h2><p>data Maybe a = Nothing | Just a</p>
<p>The a here is the type parameter. And because there’s a type parameter involved, we call Maybe a type constructor.</p>
<p>If some function requires a Maybe Int as a parameter, we can give it a Nothing, because a Nothing doesn’t contain a value anyway and so it doesn’t matter.</p>
<p>Nothing与[]相似,可以和任何[Int],[char]搭配<br>Maybe represents an option of either having nothing or having one of something. It doesn’t matter what the type of that something is.<br>只管有没有,不管是什么</p>
<p>it’s a very strong convention in Haskell to never add typeclass constraints in data declarations</p>
<p>if we don’t put the constraint in the data declaration, we don’t have to put (Ord k) =&gt; in the type declarations of functions that don’t care whether the keys can be ordered or not.</p>
<p>data Vector a = Vector a a a deriving (Show)<br><!-- 三个a类型同 --><br>vplus :: (Num t) =&gt; Vector t -&gt; Vector t -&gt; Vector t<br>(Vector i j k) <code>vplus</code> (Vector l m n) = Vector (i+l) (j+m) (k+n)</p>
<p>vectMult :: (Num t) =&gt; Vector t -&gt; t -&gt; Vector t<br>(Vector i j k) <code>vectMult</code> m = Vector (i<em>m) (j</em>m) (k*m)</p>
<p>scalarMult :: (Num t) =&gt; Vector t -&gt; Vector t -&gt; t<br>(Vector i j k) <code>scalarMult</code> (Vector l m n) = i<em>l + j</em>m + k*n</p>
<p>When declaring a data type, the part before the = is the type constructor and the constructors after it are value constructors</p>
<h2 id="Typeclass"><a href="#Typeclass" class="headerlink" title="Typeclass"></a>Typeclass</h2><p>Typeclasses are more like interfaces. We don’t make data from typeclasses. Instead, we first make our data type and then we think about what it can act like. If it can act like something that can be equated, we make it an instance of the Eq typeclass. If it can act like something that can be ordered, we make it an instance of the Ord typeclass.</p>
<p>first make type, then consider which typeclass it can be</p>
<p>Eq, Ord, Enum, Bounded, Show, Read. Haskell can derive the behavior of our types in these contexts if we use the deriving keyword when making our data type.</p>
<p>data Person = Person { firstName :: String<br>                     , lastName :: String<br>                     , age :: Int<br>                     }</p>
<p>data Person = Person { firstName :: String<br>                     , lastName :: String<br>                     , age :: Int<br>                     } deriving (Eq)</p>
<p>ghci&gt; let mikeD = Person {firstName = “Michael”, lastName = “Diamond”, age = 43}<br>ghci&gt; mikeD == mikeD<br>True<br>ghci&gt; let beastieBoys = [mca, adRock, mikeD]<br>ghci&gt; mikeD <code>elem</code> beastieBoys<br>True</p>
<p>data Person = Person { firstName :: String<br>                     , lastName :: String<br>                     , age :: Int<br>                     } deriving (Eq, Show, Read)</p>
<p>ghci&gt; let mikeD = Person {firstName = “Michael”, lastName = “Diamond”, age = 43}<br>ghci&gt; mikeD<br>Person {firstName = “Michael”, lastName = “Diamond”, age = 43}<br>ghci&gt; read “Person {firstName =\”Michael\”, lastName =\”Diamond\”, age = 43}” :: Person<br>Person {firstName = “Michael”, lastName = “Diamond”, age = 43}</p>
<p>data Bool = False | True deriving (Ord)<br>Because the False value constructor is specified first and the True value constructor is specified after it, we can consider True as greater than False.</p>
<p>Ord根据构造顺序赋偏序</p>
<p>Because all the value constructors are nullary (take no parameters, i.e. fields), we can make it part of the Enum typeclass. The Enum typeclass is for things that have predecessors and successors. We can also make it part of the Bounded typeclass, which is for things that have a lowest possible value and highest possible value. And while we’re at it, let’s also make it an instance of all the other derivable typeclasses and see what we can do with it.</p>
<p>data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday<br>           deriving (Eq, Ord, Show, Read, Bounded, Enum)</p>
<p>ghci&gt; minBound :: Day<br>Monday<br>ghci&gt; maxBound :: Day<br>Sunday<br>ghci&gt; pred Saturday<br>Friday<br>ghci&gt; [Thursday .. Sunday]<br>[Thursday,Friday,Saturday,Sunday]<br>ghci&gt; [minBound .. maxBound] :: [Day]<br>[Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday]</p>
<h2 id="Synonyms"><a href="#Synonyms" class="headerlink" title="Synonyms"></a>Synonyms</h2><p>type String = [Char]</p>
<p>we’re not actually making anything new (we did that with the data keyword), but we’re just making a synonym for an already existing type.</p>
<p>type PhoneNumber = String<br>type Name = String<br>type PhoneBook = [(Name,PhoneNumber)]</p>
<p>with parameter:</p>
<p>type AssocList k v = [(k,v)]<br>Now, a function that gets the value by a key in an association list can have a type of (Eq k) =&gt; k -&gt; AssocList k v -&gt; Maybe v. AssocList is a type constructor that takes two types and produces a concrete type, like AssocList Int String, for instance.</p>
<p>data Either a b = Left a | Right b deriving (Eq, Ord, Read, Show)</p>
<p>ghci&gt; :t Right “aaa”<br>Right “aaa” :: Either a String<br>ghci&gt; :t Left “aaa”<br>Left “aaa” :: Either String b</p>
<p>It has two value constructors. If the Left is used, then its contents are of type a and if Right is used, then its contents are of type b</p>
<p>However, when we’re interested in how some function failed or why, we usually use the result type of Either a b, where a is some sort of type that can tell us something about the possible failure and b is the type of a successful computation.</p>
<p>Hence, errors use the Left value constructor while results use Right.</p>
<p>lockerLookup :: Int -&gt; LockerMap -&gt; Either String Code<br>lockerLookup lockerNumber map =<br>    case Map.lookup lockerNumber map of<br>        Nothing -&gt; Left $ “Locker number “ ++ show lockerNumber ++ “ doesn’t exist!”<br>        Just (state, code) -&gt; if state /= Taken<br>                                then Right code<br>                                else Left $ “Locker “ ++ show lockerNumber ++ “ is already taken!”</p>
<p>用于不同类型返回值</p>
<h2 id="recursive"><a href="#recursive" class="headerlink" title="recursive"></a>recursive</h2><p>data List a = Empty | Cons a (List a) deriving (Show, Read, Eq, Ord)</p>
<p>cons is another word for :. You see, in lists, : is actually a constructor that takes a value and another list and returns a list</p>
<p>priority:</p>
<p>infixr 5 :-:<br>data List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord)</p>
<p>When we define functions as operators, we can use that to give them a fixity (but we don’t have to). A fixity states how tightly the operator binds and whether it’s left-associative or right-associative. For instance, <em>‘s fixity is infixl 7 </em> and +’s fixity is infixl 6. That means that they’re both left-associative (4 <em> 3 </em> 2 is (4 <em> 3) </em> 2) but <em> binds tighter than +, because it has a greater fixity, so 5 </em> 4 + 3 is (5 * 4) + 3.<br>eg:<br>infixr 5  ++<br>(++) :: [a] -&gt; [a] -&gt; [a]<br>[]     ++ ys = ys<br>(x:xs) ++ ys = x : (xs ++ ys)</p>
<p>data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)<br>In Haskell, we can’t really modify our tree, so we have to make a new sub-tree each time we decide to go left or right and in the end the insertion function returns a completely new tree, because Haskell doesn’t really have a concept of pointer, just values.<br>the type for our insertion function is going to be something like a -&gt; Tree a - &gt; Tree a</p>
<p>singleton :: a -&gt; Tree a<br>singleton x = Node x EmptyTree EmptyTree</p>
<p>treeInsert :: (Ord a) =&gt; a -&gt; Tree a -&gt; Tree a<br>treeInsert x EmptyTree = singleton x<br>treeInsert x (Node a left right)<br>    | x == a = Node x left right<br>    | x &lt; a  = Node a (treeInsert x left) right<br>    | x &gt; a  = Node a left (treeInsert x right)</p>
<p>treeElem :: (Ord a) =&gt; a -&gt; Tree a -&gt; Bool<br>treeElem x EmptyTree = False<br>treeElem x (Node a left right)<br>    | x == a = True<br>    | x &lt; a  = treeElem x left<br>    | x &gt; a  = treeElem x right</p>
<p>非常优雅的建树方式<br>ghci&gt; let nums = [8,6,4,1,7,3,5]<br>ghci&gt; let numsTree = foldr treeInsert EmptyTree nums<br>ghci&gt; numsTree<br>Node 5 (Node 3 (Node 1 EmptyTree EmptyTree) (Node 4 EmptyTree EmptyTree)) (Node 7 (Node 6 EmptyTree EmptyTree) (Node 8 EmptyTree EmptyTree))</p>
<h2 id="Create-Typeclass"><a href="#Create-Typeclass" class="headerlink" title="Create Typeclass"></a>Create Typeclass</h2><p>class Eq a where<br>    (==) :: a -&gt; a -&gt; Bool<br>    (/=) :: a -&gt; a -&gt; Bool<br>    x == y = not (x /= y)<br>    x /= y = not (x == y)</p>
<p>The a is the type variable and it means that a will play the role of the type that we will soon be making an instance of Eq.<br>It doesn’t have to be called a, it doesn’t even have to be one letter, it just has to be a lowercase word.</p>
<p>data TrafficLight = Red | Yellow | Green</p>
<p>Notice how we didn’t derive any class instances for it. That’s because we’re going to write up some instances by hand, even though we could derive them for types like Eq and Show. Here’s how we make it an instance of Eq.</p>
<p>instance Eq TrafficLight where<br>    Red == Red = True<br>    Green == Green = True<br>    Yellow == Yellow = True<br>    _ == _ = False</p>
<p>So class is for defining new typeclasses and instance is for making our types instances of typeclasses.</p>
<p>Because == was defined in terms of /= and vice versa in the class declaration, we only had to overwrite one of them in the instance declaration.</p>
<p>That’s called the minimal complete definition for the typeclass — the minimum of functions that we have to implement so that our type can behave like the class advertises.</p>
<p>If Eq was defined simply like this:</p>
<p>class Eq a where<br>    (==) :: a -&gt; a -&gt; Bool<br>    (/=) :: a -&gt; a -&gt; Bool<br>we’d have to implement both of these functions when making a type an instance of it, because Haskell wouldn’t know how these two functions are related.</p>
<p>we implemented == simply by doing pattern matching</p>
<p>class (Eq a) =&gt; Num a where</p>
<p>对于含参data<br>类型类可以有约束,意味着一个类型类可以作为另一个类型类的子类(例如,Num是Eq的子类),因此任何作为Num的类型也必须实现Eq.</p>
<p>在Haskell中,定义一个Num的子类并不要求您必须将所有类似Eq、Ord的行为全部重新定义.只需在定义子类时添加对父类的约束即可,这样就继承了父类的所有行为,无需手动重复定义.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Num</span> <span class="title">a</span>) =&gt; <span class="type">AdvancedNum</span> a <span class="keyword">where</span></span></span><br><span class="line">    <span class="comment">-- 在Num的基础上添加新的函数</span></span><br><span class="line">    square :: a -&gt; a</span><br><span class="line">    cube :: a -&gt; a</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在Haskell中,定义一个Num的子类并不要求您必须将所有类似Eq、Ord的行为全部重新定义.只需在定义子类时添加对父类的约束即可,这样就继承了父类的所有行为,无需手动重复定义.</p>
<p>具体来说,当您定义一个Num的子类时,Haskell允许您在子类声明中引入必要的类型类约束.例如,假设我们要定义一个新的类型类AdvancedNum,它是Num的子类,并增加了一些额外的功能.可以这样实现:</p>
<p>haskell<br>Copy code<br>class (Num a) =&gt; AdvancedNum a where<br>    — 在Num的基础上添加新的函数<br>    square :: a -&gt; a<br>    cube :: a -&gt; a<br>在这个定义中,(Num a) =&gt; AdvancedNum a表示AdvancedNum是Num的一个子类.为了成为AdvancedNum的实例,一个类型a必须首先是Num的实例.这里并不要求您重新实现Num或其父类(例如Eq和Ord)的所有功能,而是可以直接继承它们</p>
<p>instance Eq Maybe where</p>
<p>instance Eq (Maybe m) where<br>    Just x == Just y = x == y<br>    Nothing == Nothing = True<br>    _ == _ = False<br>整个type constructor一起声明<br>即concrete type</p>
<p>We use == on the contents of the Maybe but we have no assurance that what the Maybe contains can be used with Eq</p>
<p>instance (Eq m) =&gt; Eq (Maybe m) where<br>    Just x == Just y = x == y<br>    Nothing == Nothing = True<br>    _ == _ = False</p>
<p>do :info YourTypeClass in GHCI</p>
<h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">YesNo</span> a <span class="keyword">where</span></span></span><br><span class="line">    yesno :: a -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">YesNo</span> <span class="type">Int</span> <span class="keyword">where</span></span></span><br><span class="line">    yesno <span class="number">0</span> = <span class="type">False</span></span><br><span class="line">    yesno _ = <span class="type">True</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">YesNo</span> [a] <span class="keyword">where</span></span></span><br><span class="line">    yesno [] = <span class="type">False</span></span><br><span class="line">    yesno _ = <span class="type">True</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">YesNo</span> <span class="type">Bool</span> <span class="keyword">where</span></span></span><br><span class="line">    yesno = id  </span><br></pre></td></tr></table></figure>
<p>What’s id? It’s just a standard library function that takes a parameter and returns the same thing, which is what we would be writing here anyway.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">YesNo</span> (<span class="type">Maybe</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    yesno (<span class="type">Just</span> _) = <span class="type">True</span></span><br><span class="line">    yesno <span class="type">Nothing</span> = <span class="type">False</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">YesNo</span> (<span class="type">Tree</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    yesno <span class="type">EmptyTree</span> = <span class="type">False</span></span><br><span class="line">    yesno _ = <span class="type">True</span></span><br><span class="line"><span class="title">yesnoIf</span> :: (<span class="type">YesNo</span> y) =&gt; y -&gt; a -&gt; a -&gt; a</span><br><span class="line"><span class="title">yesnoIf</span> yesnoVal yesResult noResult = <span class="keyword">if</span> yesno yesnoVal <span class="keyword">then</span> yesResult <span class="keyword">else</span> noResult</span><br></pre></td></tr></table></figure>
<h2 id="functor"><a href="#functor" class="headerlink" title="functor"></a>functor</h2><p>class Functor f where<br>    fmap :: (a -&gt; b) -&gt; f a -&gt; f b</p>
<p>the f is not a concrete type (a type that a value can hold, like Int, Bool or Maybe String), but a type constructor that takes one type parameter</p>
<p>ghci&gt; :info map<br>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</p>
<p>instance Functor Maybe where<br>    fmap f (Just x) = Just (f x)<br>    fmap f Nothing = Nothing</p>
<p>fmap f共同作函数</p>
<p>ghci&gt; fmap (++ “ HEY GUYS IM INSIDE THE JUST”) (Just “Something serious.”)<br>Just “Something serious. HEY GUYS IM INSIDE THE JUST”<br>ghci&gt; fmap (++ “ HEY GUYS IM INSIDE THE JUST”) Nothing<br>Nothing<br>ghci&gt; fmap (<em>2) (Just 200)<br>Just 400<br>ghci&gt; fmap (</em>2) Nothing<br>Nothing</p>
<p>instance Functor Tree where<br>    fmap f EmptyTree = EmptyTree<br>    fmap f (Node x leftsub rightsub) = Node (f x) (fmap f leftsub) (fmap f rightsub)</p>
<p>非常优美的树递归</p>
<p>ghci&gt; fmap (*4) (foldr treeInsert EmptyTree [5,7,3,2,1,7])<br>Node 28 (Node 4 EmptyTree (Node 8 EmptyTree (Node 12 EmptyTree (Node 20 EmptyTree EmptyTree)))) EmptyTree</p>
<p>instance Functor (Either a) where<br>    fmap f (Right x) = Right (f x)<br>    fmap f (Left x) = Left x</p>
<p>functor针对最后一个类型同态映射,对于Either会取前一个参数<br>即<br>(b -&gt; c) -&gt; Either a b -&gt; Either a c<br>because that’s the same as<br>(b -&gt; c) -&gt; (Either a) b -&gt; (Either a) c</p>
<h2 id="kinds"><a href="#kinds" class="headerlink" title="kinds"></a>kinds</h2><p>types have their own little labels, called kinds<br>ghci&gt; :k Int<br>Int :: *</p>
<p>* means that the type is a concrete type. A concrete type is a type that doesn’t take any type parameters and values can only have types that are concrete types<br>called as star or type</p>
<p>ghci&gt; :k Maybe<br>Maybe :: <em> -&gt; </em><br>ghci&gt; :k Maybe Int<br>Maybe Int :: *</p>
<p>* -&gt; * means that the type constructor takes one concrete type and returns a concrete type</p>
<p>ghci&gt; :k Either<br>Either :: <em> -&gt; </em> -&gt; *</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/haskell/" rel="tag"># haskell</a>
              <a href="/tags/%E8%AF%AD%E6%B3%95/" rel="tag"># 语法</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/haskell%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/" rel="prev" title="haskell函数进阶">
                  <i class="fa fa-angle-left"></i> haskell函数进阶
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">nebulyu's</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>



  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","per_page":true,"mhchem":true,"js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML"}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
