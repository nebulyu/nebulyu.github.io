<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="QiET7ttAHFoc3bMl0cmzBIzJBawh36AmKvy_PU89Nz4">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"nebulyu.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12,"onmobile":false},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":null,"post_block":null,"post_header":null,"post_body":null,"coll_header":null,"sidebar":"fadeInDown"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":3,"unescape":false,"preload":false,"trigger":"auto","swiftype_key":null}}</script><script src="/js/config.js"></script>

    <meta name="description" content="施工中(*&gt;.">
<meta property="og:type" content="website">
<meta property="og:title" content="Nebulyu&#39;s Blog">
<meta property="og:url" content="https://nebulyu.github.io/home/index.html">
<meta property="og:site_name" content="Nebulyu&#39;s Blog">
<meta property="og:description" content="施工中(*&gt;.">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="nebulyu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://nebulyu.github.io/home/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"home/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Nebulyu's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Nebulyu's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">归档站</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-categories"><a href="/categories/" rel="section">Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section">Archives</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section">links</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger">Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="Searching..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">nebulyu</p>
  <div class="site-description" itemprop="description">施工中(*>.<*)</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://nebulyu.github.io/haskell%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nebulyu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nebulyu's Blog">
      <meta itemprop="description" content="施工中(*>.<*)">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Nebulyu's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/haskell%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">haskell类型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-12-04 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-04T00:00:00+00:00">2024-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-12-05 00:12:12" itemprop="dateModified" datetime="2024-12-05T00:12:12+00:00">2024-12-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/haskell/" itemprop="url" rel="index"><span itemprop="name">haskell</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Haskell-类型"><a href="#Haskell-类型" class="headerlink" title="Haskell 类型"></a>Haskell 类型</h1><h2 id="数据类型定义"><a href="#数据类型定义" class="headerlink" title="数据类型定义"></a>数据类型定义</h2><h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Bool</span> = <span class="type">False</span> | <span class="type">True</span></span></span><br></pre></td></tr></table></figure>
<p>在 Haskell 中，<code>data</code> 用于定义新的数据类型。等号前面的部分是类型名 <code>Bool</code>，等号后面的部分是值构造器。这里 <code>False</code> 和 <code>True</code> 是两个值构造器，分别表示布尔类型的可能值。<code>|</code> 可以理解为“或”。</p>
<p><strong>注意：</strong> 类型名和值构造器都需要以大写字母开头。</p>
<h3 id="自定义数据类型示例"><a href="#自定义数据类型示例" class="headerlink" title="自定义数据类型示例"></a>自定义数据类型示例</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> | <span class="type">Rectangle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>Circle</code> 和 <code>Rectangle</code> 是值构造器，实际上是函数。它们分别接受类型为 <code>Float</code> 的参数。</li>
<li><code>Shape</code> 是类型名，用于表示几何形状。</li>
</ul>
<p>我们可以基于 <code>Shape</code> 类型定义函数，例如：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">surface</span> :: <span class="type">Shape</span> -&gt; <span class="type">Float</span></span><br><span class="line"><span class="title">surface</span> (<span class="type">Circle</span> _ _ r) = pi * r ^ <span class="number">2</span></span><br><span class="line"><span class="title">surface</span> (<span class="type">Rectangle</span> x1 y1 x2 y2) = (abs $ x2 - x1) * (abs $ y2 - y1)</span><br></pre></td></tr></table></figure>
<p>上述 <code>surface</code> 函数用于计算 <code>Shape</code> 的表面积。</p>
<h3 id="自动派生类型"><a href="#自动派生类型" class="headerlink" title="自动派生类型"></a>自动派生类型</h3><p>使用 <code>deriving</code> 关键字可以为数据类型自动生成某些类型类的实例，例如：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure>
<p>这样，<code>Shape</code> 类型的值可以直接打印。</p>
<h3 id="嵌套数据类型"><a href="#嵌套数据类型" class="headerlink" title="嵌套数据类型"></a>嵌套数据类型</h3><p>我们可以通过组合数据类型来定义更复杂的结构：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Point</span> = <span class="type">Point</span> <span class="type">Float</span> <span class="type">Float</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Point</span> <span class="type">Float</span> | <span class="type">Rectangle</span> <span class="type">Point</span> <span class="type">Point</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure>
<p>这里 <code>Point</code> 类型用于表示二维空间中的点，而 <code>Shape</code> 类型通过组合 <code>Point</code> 定义了更加具体的几何形状。</p>
<h2 id="类型参数"><a href="#类型参数" class="headerlink" title="类型参数"></a>类型参数</h2><h3 id="基础示例"><a href="#基础示例" class="headerlink" title="基础示例"></a>基础示例</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Maybe</span> a = <span class="type">Nothing</span> | <span class="type">Just</span> a</span></span><br></pre></td></tr></table></figure>
<p><code>Maybe</code> 是一个带有类型参数 <code>a</code> 的数据类型。根据 <code>a</code> 的不同，<code>Maybe</code> 可以表示不同的类型。例如：</p>
<ul>
<li><code>Maybe Int</code> 表示可能包含整数的值。</li>
<li><code>Maybe String</code> 表示可能包含字符串的值。</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Vector</span> a = <span class="type">Vector</span> a a a <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure>
<p>上例中，<code>Vector</code> 是一个类型构造器，<code>a</code> 是类型参数。它可以用于定义三维向量。</p>
<h2 id="类型类"><a href="#类型类" class="headerlink" title="类型类"></a>类型类</h2><h3 id="什么是类型类？"><a href="#什么是类型类？" class="headerlink" title="什么是类型类？"></a>什么是类型类？</h3><p>类型类类似于接口，用于定义一组行为。我们可以为自定义数据类型实现这些行为。例如：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Eq</span> a <span class="keyword">where</span></span></span><br><span class="line">    (==) :: a -&gt; a -&gt; <span class="type">Bool</span></span><br><span class="line">    (/=) :: a -&gt; a -&gt; <span class="type">Bool</span></span><br><span class="line">    x /= y = not (x == y)</span><br><span class="line">    x == y = not (x /= y)</span><br></pre></td></tr></table></figure>
<h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><p>以交通信号灯为例：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">TrafficLight</span> = <span class="type">Red</span> | <span class="type">Yellow</span> | <span class="type">Green</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Eq</span> <span class="type">TrafficLight</span> <span class="keyword">where</span></span></span><br><span class="line">    <span class="type">Red</span> == <span class="type">Red</span> = <span class="type">True</span></span><br><span class="line">    <span class="type">Yellow</span> == <span class="type">Yellow</span> = <span class="type">True</span></span><br><span class="line">    <span class="type">Green</span> == <span class="type">Green</span> = <span class="type">True</span></span><br><span class="line">    _ == _ = <span class="type">False</span></span><br></pre></td></tr></table></figure>
<p>这里我们为 <code>TrafficLight</code> 类型实现了 <code>Eq</code> 类型类。</p>
<h3 id="常见类型类"><a href="#常见类型类" class="headerlink" title="常见类型类"></a>常见类型类</h3><ul>
<li><code>Eq</code>：支持相等性判断。</li>
<li><code>Ord</code>：支持排序。</li>
<li><code>Show</code>：支持打印。</li>
<li><code>Read</code>：支持从字符串解析值。</li>
<li><code>Enum</code>：支持枚举。</li>
<li><code>Bounded</code>：支持定义上下界。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Day</span> = <span class="type">Monday</span> | <span class="type">Tuesday</span> | <span class="type">Wednesday</span> | <span class="type">Thursday</span> | <span class="type">Friday</span> | <span class="type">Saturday</span> | <span class="type">Sunday</span> </span></span><br><span class="line">           <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>, <span class="type">Show</span>, <span class="type">Read</span>, <span class="type">Bounded</span>, <span class="type">Enum</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="type">Thursday</span> .. <span class="type">Sunday</span>]</span><br><span class="line">[<span class="type">Thursday</span>,<span class="type">Friday</span>,<span class="type">Saturday</span>,<span class="type">Sunday</span>]</span><br></pre></td></tr></table></figure>
<h2 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><code>Functor</code> 是一个常见的类型类，定义如下：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line">    fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></table></figure>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">    fmap f (<span class="type">Just</span> x) = <span class="type">Just</span> (f x)</span><br><span class="line">    fmap f <span class="type">Nothing</span> = <span class="type">Nothing</span></span><br></pre></td></tr></table></figure>
<p><code>fmap</code> 是 <code>Functor</code> 的核心函数，用于将函数应用到容器内的值。</p>
<h2 id="递归数据结构"><a href="#递归数据结构" class="headerlink" title="递归数据结构"></a>递归数据结构</h2><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">List</span> a = <span class="type">Empty</span> | <span class="type">Cons</span> a (<span class="type">List</span> <span class="title">a</span>) <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Read</span>, <span class="type">Eq</span>, <span class="type">Ord</span>)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>Empty</code> 表示空列表。</li>
<li><code>Cons</code> 是构造器，用于将元素添加到列表。</li>
</ul>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tree</span> a = <span class="type">EmptyTree</span> | <span class="type">Node</span> a (<span class="type">Tree</span> <span class="title">a</span>) (<span class="type">Tree</span> <span class="title">a</span>) <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Read</span>, <span class="type">Eq</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="title">singleton</span> :: a -&gt; <span class="type">Tree</span> a</span><br><span class="line"><span class="title">singleton</span> x = <span class="type">Node</span> x <span class="type">EmptyTree</span> <span class="type">EmptyTree</span></span><br></pre></td></tr></table></figure>
<p>通过递归的方式，我们可以非常优雅地操作树结构。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Haskell 提供了强大的类型系统和类型类机制，使得代码更加安全和灵活。熟练使用这些特性可以帮助我们构建更复杂的应用。</p>
<h1 id="Haskell-类型-1"><a href="#Haskell-类型-1" class="headerlink" title="Haskell 类型"></a>Haskell 类型</h1><h2 id="data"><a href="#data" class="headerlink" title="data"></a>data</h2><p>data Bool = False | True<br>data means that we’re defining a new data type. The part before the = denotes the type, which is Bool. The parts after the = are value constructors. They specify the different values that this type can have. The | is read as or. So we can read this as: the Bool type can have a value of True or False. Both the type name and the value constructors have to be capital cased.</p>
<p>data Shape = Circle Float Float Float | Rectangle Float Float Float Float,:<br>Circle Rectange 均为value constructor, 本质函数, 后面的类型是传入值</p>
<p>surface :: Shape -&gt; Float<br>surface (Circle _ _ r) = pi <em> r ^ 2<br>surface (Rectangle x1 y1 x2 y2) = (abs $ x2 - x1) </em> (abs $ y2 - y1)</p>
<p>deriving type<br>data Shape = Circle Float Float Float deriving (Show)</p>
<p>composition<br>data Point = Point Float Float deriving (Show)<br>data Shape = Circle Point Float | Rectangle Point Point deriving (Show)</p>
<p>Notice that when defining a point, we used the same name for the data type and the value constructor. This has no special meaning, although it’s common to use the same name as the type if there’s only one value constructor. </p>
<p>nudge :: Shape -&gt; Float -&gt; Float -&gt; Shape<br>nudge (Circle (Point x y) r) a b = Circle (Point (x+a) (y+b)) r</p>
<p>export<br>module Shapes<br>( Point(..)<br>, Shape(..)<br>, surface<br>, nudge<br>, baseCircle<br>, baseRect<br>) where</p>
<p>data Person = Person String String Int Float String String deriving (Show)</p>
<p>data Person = Person { firstName :: String<br>                     , lastName :: String<br>                     , age :: Int<br>                     , height :: Float<br>                     , phoneNumber :: String<br>                     , flavor :: String<br>                     } deriving (Show)<br>we don’t have to necessarily put the fields in the proper order, as long as we list all of them. But if we don’t use record syntax, we have to specify them in order.</p>
<h2 id="type-para"><a href="#type-para" class="headerlink" title="type para"></a>type para</h2><p>data Maybe a = Nothing | Just a</p>
<p>The a here is the type parameter. And because there’s a type parameter involved, we call Maybe a type constructor.</p>
<p>If some function requires a Maybe Int as a parameter, we can give it a Nothing, because a Nothing doesn’t contain a value anyway and so it doesn’t matter.</p>
<p>Nothing与[]相似,可以和任何[Int],[char]搭配<br>Maybe represents an option of either having nothing or having one of something. It doesn’t matter what the type of that something is.<br>只管有没有,不管是什么</p>
<p>it’s a very strong convention in Haskell to never add typeclass constraints in data declarations</p>
<p>if we don’t put the constraint in the data declaration, we don’t have to put (Ord k) =&gt; in the type declarations of functions that don’t care whether the keys can be ordered or not.</p>
<p>data Vector a = Vector a a a deriving (Show)<br><!-- 三个a类型同 --><br>vplus :: (Num t) =&gt; Vector t -&gt; Vector t -&gt; Vector t<br>(Vector i j k) <code>vplus</code> (Vector l m n) = Vector (i+l) (j+m) (k+n)</p>
<p>vectMult :: (Num t) =&gt; Vector t -&gt; t -&gt; Vector t<br>(Vector i j k) <code>vectMult</code> m = Vector (i<em>m) (j</em>m) (k*m)</p>
<p>scalarMult :: (Num t) =&gt; Vector t -&gt; Vector t -&gt; t<br>(Vector i j k) <code>scalarMult</code> (Vector l m n) = i<em>l + j</em>m + k*n</p>
<p>When declaring a data type, the part before the = is the type constructor and the constructors after it are value constructors</p>
<h2 id="Typeclass"><a href="#Typeclass" class="headerlink" title="Typeclass"></a>Typeclass</h2><p>Typeclasses are more like interfaces. We don’t make data from typeclasses. Instead, we first make our data type and then we think about what it can act like. If it can act like something that can be equated, we make it an instance of the Eq typeclass. If it can act like something that can be ordered, we make it an instance of the Ord typeclass.</p>
<p>first make type, then consider which typeclass it can be</p>
<p>Eq, Ord, Enum, Bounded, Show, Read. Haskell can derive the behavior of our types in these contexts if we use the deriving keyword when making our data type.</p>
<p>data Person = Person { firstName :: String<br>                     , lastName :: String<br>                     , age :: Int<br>                     }</p>
<p>data Person = Person { firstName :: String<br>                     , lastName :: String<br>                     , age :: Int<br>                     } deriving (Eq)</p>
<p>ghci&gt; let mikeD = Person {firstName = “Michael”, lastName = “Diamond”, age = 43}<br>ghci&gt; mikeD == mikeD<br>True<br>ghci&gt; let beastieBoys = [mca, adRock, mikeD]<br>ghci&gt; mikeD <code>elem</code> beastieBoys<br>True</p>
<p>data Person = Person { firstName :: String<br>                     , lastName :: String<br>                     , age :: Int<br>                     } deriving (Eq, Show, Read)</p>
<p>ghci&gt; let mikeD = Person {firstName = “Michael”, lastName = “Diamond”, age = 43}<br>ghci&gt; mikeD<br>Person {firstName = “Michael”, lastName = “Diamond”, age = 43}<br>ghci&gt; read “Person {firstName =\”Michael\”, lastName =\”Diamond\”, age = 43}” :: Person<br>Person {firstName = “Michael”, lastName = “Diamond”, age = 43}</p>
<p>data Bool = False | True deriving (Ord)<br>Because the False value constructor is specified first and the True value constructor is specified after it, we can consider True as greater than False.</p>
<p>Ord根据构造顺序赋偏序</p>
<p>Because all the value constructors are nullary (take no parameters, i.e. fields), we can make it part of the Enum typeclass. The Enum typeclass is for things that have predecessors and successors. We can also make it part of the Bounded typeclass, which is for things that have a lowest possible value and highest possible value. And while we’re at it, let’s also make it an instance of all the other derivable typeclasses and see what we can do with it.</p>
<p>data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday<br>           deriving (Eq, Ord, Show, Read, Bounded, Enum)</p>
<p>ghci&gt; minBound :: Day<br>Monday<br>ghci&gt; maxBound :: Day<br>Sunday<br>ghci&gt; pred Saturday<br>Friday<br>ghci&gt; [Thursday .. Sunday]<br>[Thursday,Friday,Saturday,Sunday]<br>ghci&gt; [minBound .. maxBound] :: [Day]<br>[Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday]</p>
<h2 id="Synonyms"><a href="#Synonyms" class="headerlink" title="Synonyms"></a>Synonyms</h2><p>type String = [Char]</p>
<p>we’re not actually making anything new (we did that with the data keyword), but we’re just making a synonym for an already existing type.</p>
<p>type PhoneNumber = String<br>type Name = String<br>type PhoneBook = [(Name,PhoneNumber)]</p>
<p>with parameter:</p>
<p>type AssocList k v = [(k,v)]<br>Now, a function that gets the value by a key in an association list can have a type of (Eq k) =&gt; k -&gt; AssocList k v -&gt; Maybe v. AssocList is a type constructor that takes two types and produces a concrete type, like AssocList Int String, for instance.</p>
<p>data Either a b = Left a | Right b deriving (Eq, Ord, Read, Show)</p>
<p>ghci&gt; :t Right “aaa”<br>Right “aaa” :: Either a String<br>ghci&gt; :t Left “aaa”<br>Left “aaa” :: Either String b</p>
<p>It has two value constructors. If the Left is used, then its contents are of type a and if Right is used, then its contents are of type b</p>
<p>However, when we’re interested in how some function failed or why, we usually use the result type of Either a b, where a is some sort of type that can tell us something about the possible failure and b is the type of a successful computation.</p>
<p>Hence, errors use the Left value constructor while results use Right.</p>
<p>lockerLookup :: Int -&gt; LockerMap -&gt; Either String Code<br>lockerLookup lockerNumber map =<br>    case Map.lookup lockerNumber map of<br>        Nothing -&gt; Left $ “Locker number “ ++ show lockerNumber ++ “ doesn’t exist!”<br>        Just (state, code) -&gt; if state /= Taken<br>                                then Right code<br>                                else Left $ “Locker “ ++ show lockerNumber ++ “ is already taken!”</p>
<p>用于不同类型返回值</p>
<h2 id="recursive"><a href="#recursive" class="headerlink" title="recursive"></a>recursive</h2><p>data List a = Empty | Cons a (List a) deriving (Show, Read, Eq, Ord)</p>
<p>cons is another word for :. You see, in lists, : is actually a constructor that takes a value and another list and returns a list</p>
<p>priority:</p>
<p>infixr 5 :-:<br>data List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord)</p>
<p>When we define functions as operators, we can use that to give them a fixity (but we don’t have to). A fixity states how tightly the operator binds and whether it’s left-associative or right-associative. For instance, <em>‘s fixity is infixl 7 </em> and +’s fixity is infixl 6. That means that they’re both left-associative (4 <em> 3 </em> 2 is (4 <em> 3) </em> 2) but <em> binds tighter than +, because it has a greater fixity, so 5 </em> 4 + 3 is (5 * 4) + 3.<br>eg:<br>infixr 5  ++<br>(++) :: [a] -&gt; [a] -&gt; [a]<br>[]     ++ ys = ys<br>(x:xs) ++ ys = x : (xs ++ ys)</p>
<p>data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)<br>In Haskell, we can’t really modify our tree, so we have to make a new sub-tree each time we decide to go left or right and in the end the insertion function returns a completely new tree, because Haskell doesn’t really have a concept of pointer, just values.<br>the type for our insertion function is going to be something like a -&gt; Tree a - &gt; Tree a</p>
<p>singleton :: a -&gt; Tree a<br>singleton x = Node x EmptyTree EmptyTree</p>
<p>treeInsert :: (Ord a) =&gt; a -&gt; Tree a -&gt; Tree a<br>treeInsert x EmptyTree = singleton x<br>treeInsert x (Node a left right)<br>    | x == a = Node x left right<br>    | x &lt; a  = Node a (treeInsert x left) right<br>    | x &gt; a  = Node a left (treeInsert x right)</p>
<p>treeElem :: (Ord a) =&gt; a -&gt; Tree a -&gt; Bool<br>treeElem x EmptyTree = False<br>treeElem x (Node a left right)<br>    | x == a = True<br>    | x &lt; a  = treeElem x left<br>    | x &gt; a  = treeElem x right</p>
<p>非常优雅的建树方式<br>ghci&gt; let nums = [8,6,4,1,7,3,5]<br>ghci&gt; let numsTree = foldr treeInsert EmptyTree nums<br>ghci&gt; numsTree<br>Node 5 (Node 3 (Node 1 EmptyTree EmptyTree) (Node 4 EmptyTree EmptyTree)) (Node 7 (Node 6 EmptyTree EmptyTree) (Node 8 EmptyTree EmptyTree))</p>
<h2 id="Create-Typeclass"><a href="#Create-Typeclass" class="headerlink" title="Create Typeclass"></a>Create Typeclass</h2><p>class Eq a where<br>    (==) :: a -&gt; a -&gt; Bool<br>    (/=) :: a -&gt; a -&gt; Bool<br>    x == y = not (x /= y)<br>    x /= y = not (x == y)</p>
<p>The a is the type variable and it means that a will play the role of the type that we will soon be making an instance of Eq.<br>It doesn’t have to be called a, it doesn’t even have to be one letter, it just has to be a lowercase word.</p>
<p>data TrafficLight = Red | Yellow | Green</p>
<p>Notice how we didn’t derive any class instances for it. That’s because we’re going to write up some instances by hand, even though we could derive them for types like Eq and Show. Here’s how we make it an instance of Eq.</p>
<p>instance Eq TrafficLight where<br>    Red == Red = True<br>    Green == Green = True<br>    Yellow == Yellow = True<br>    _ == _ = False</p>
<p>So class is for defining new typeclasses and instance is for making our types instances of typeclasses.</p>
<p>Because == was defined in terms of /= and vice versa in the class declaration, we only had to overwrite one of them in the instance declaration.</p>
<p>That’s called the minimal complete definition for the typeclass — the minimum of functions that we have to implement so that our type can behave like the class advertises.</p>
<p>If Eq was defined simply like this:</p>
<p>class Eq a where<br>    (==) :: a -&gt; a -&gt; Bool<br>    (/=) :: a -&gt; a -&gt; Bool<br>we’d have to implement both of these functions when making a type an instance of it, because Haskell wouldn’t know how these two functions are related.</p>
<p>we implemented == simply by doing pattern matching</p>
<p>class (Eq a) =&gt; Num a where</p>
<p>对于含参data<br>类型类可以有约束,意味着一个类型类可以作为另一个类型类的子类(例如,Num是Eq的子类),因此任何作为Num的类型也必须实现Eq.</p>
<p>在Haskell中,定义一个Num的子类并不要求您必须将所有类似Eq、Ord的行为全部重新定义.只需在定义子类时添加对父类的约束即可,这样就继承了父类的所有行为,无需手动重复定义.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Num</span> <span class="title">a</span>) =&gt; <span class="type">AdvancedNum</span> a <span class="keyword">where</span></span></span><br><span class="line">    <span class="comment">-- 在Num的基础上添加新的函数</span></span><br><span class="line">    square :: a -&gt; a</span><br><span class="line">    cube :: a -&gt; a</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在Haskell中,定义一个Num的子类并不要求您必须将所有类似Eq、Ord的行为全部重新定义.只需在定义子类时添加对父类的约束即可,这样就继承了父类的所有行为,无需手动重复定义.</p>
<p>具体来说,当您定义一个Num的子类时,Haskell允许您在子类声明中引入必要的类型类约束.例如,假设我们要定义一个新的类型类AdvancedNum,它是Num的子类,并增加了一些额外的功能.可以这样实现:</p>
<p>haskell<br>Copy code<br>class (Num a) =&gt; AdvancedNum a where<br>    — 在Num的基础上添加新的函数<br>    square :: a -&gt; a<br>    cube :: a -&gt; a<br>在这个定义中,(Num a) =&gt; AdvancedNum a表示AdvancedNum是Num的一个子类.为了成为AdvancedNum的实例,一个类型a必须首先是Num的实例.这里并不要求您重新实现Num或其父类(例如Eq和Ord)的所有功能,而是可以直接继承它们</p>
<p>instance Eq Maybe where</p>
<p>instance Eq (Maybe m) where<br>    Just x == Just y = x == y<br>    Nothing == Nothing = True<br>    _ == _ = False<br>整个type constructor一起声明<br>即concrete type</p>
<p>We use == on the contents of the Maybe but we have no assurance that what the Maybe contains can be used with Eq</p>
<p>instance (Eq m) =&gt; Eq (Maybe m) where<br>    Just x == Just y = x == y<br>    Nothing == Nothing = True<br>    _ == _ = False</p>
<p>do :info YourTypeClass in GHCI</p>
<h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">YesNo</span> a <span class="keyword">where</span></span></span><br><span class="line">    yesno :: a -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">YesNo</span> <span class="type">Int</span> <span class="keyword">where</span></span></span><br><span class="line">    yesno <span class="number">0</span> = <span class="type">False</span></span><br><span class="line">    yesno _ = <span class="type">True</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">YesNo</span> [a] <span class="keyword">where</span></span></span><br><span class="line">    yesno [] = <span class="type">False</span></span><br><span class="line">    yesno _ = <span class="type">True</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">YesNo</span> <span class="type">Bool</span> <span class="keyword">where</span></span></span><br><span class="line">    yesno = id  </span><br></pre></td></tr></table></figure>
<p>What’s id? It’s just a standard library function that takes a parameter and returns the same thing, which is what we would be writing here anyway.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">YesNo</span> (<span class="type">Maybe</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    yesno (<span class="type">Just</span> _) = <span class="type">True</span></span><br><span class="line">    yesno <span class="type">Nothing</span> = <span class="type">False</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">YesNo</span> (<span class="type">Tree</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    yesno <span class="type">EmptyTree</span> = <span class="type">False</span></span><br><span class="line">    yesno _ = <span class="type">True</span></span><br><span class="line"><span class="title">yesnoIf</span> :: (<span class="type">YesNo</span> y) =&gt; y -&gt; a -&gt; a -&gt; a</span><br><span class="line"><span class="title">yesnoIf</span> yesnoVal yesResult noResult = <span class="keyword">if</span> yesno yesnoVal <span class="keyword">then</span> yesResult <span class="keyword">else</span> noResult</span><br></pre></td></tr></table></figure>
<h2 id="functor"><a href="#functor" class="headerlink" title="functor"></a>functor</h2><p>class Functor f where<br>    fmap :: (a -&gt; b) -&gt; f a -&gt; f b</p>
<p>the f is not a concrete type (a type that a value can hold, like Int, Bool or Maybe String), but a type constructor that takes one type parameter</p>
<p>ghci&gt; :info map<br>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</p>
<p>instance Functor Maybe where<br>    fmap f (Just x) = Just (f x)<br>    fmap f Nothing = Nothing</p>
<p>fmap f共同作函数</p>
<p>ghci&gt; fmap (++ “ HEY GUYS IM INSIDE THE JUST”) (Just “Something serious.”)<br>Just “Something serious. HEY GUYS IM INSIDE THE JUST”<br>ghci&gt; fmap (++ “ HEY GUYS IM INSIDE THE JUST”) Nothing<br>Nothing<br>ghci&gt; fmap (<em>2) (Just 200)<br>Just 400<br>ghci&gt; fmap (</em>2) Nothing<br>Nothing</p>
<p>instance Functor Tree where<br>    fmap f EmptyTree = EmptyTree<br>    fmap f (Node x leftsub rightsub) = Node (f x) (fmap f leftsub) (fmap f rightsub)</p>
<p>非常优美的树递归</p>
<p>ghci&gt; fmap (*4) (foldr treeInsert EmptyTree [5,7,3,2,1,7])<br>Node 28 (Node 4 EmptyTree (Node 8 EmptyTree (Node 12 EmptyTree (Node 20 EmptyTree EmptyTree)))) EmptyTree</p>
<p>instance Functor (Either a) where<br>    fmap f (Right x) = Right (f x)<br>    fmap f (Left x) = Left x</p>
<p>functor针对最后一个类型同态映射,对于Either会取前一个参数<br>即<br>(b -&gt; c) -&gt; Either a b -&gt; Either a c<br>because that’s the same as<br>(b -&gt; c) -&gt; (Either a) b -&gt; (Either a) c</p>
<h2 id="kinds"><a href="#kinds" class="headerlink" title="kinds"></a>kinds</h2><p>types have their own little labels, called kinds<br>ghci&gt; :k Int<br>Int :: *</p>
<p>* means that the type is a concrete type. A concrete type is a type that doesn’t take any type parameters and values can only have types that are concrete types<br>called as star or type</p>
<p>ghci&gt; :k Maybe<br>Maybe :: <em> -&gt; </em><br>ghci&gt; :k Maybe Int<br>Maybe Int :: *</p>
<p>* -&gt; * means that the type constructor takes one concrete type and returns a concrete type</p>
<p>ghci&gt; :k Either<br>Either :: <em> -&gt; </em> -&gt; *</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://nebulyu.github.io/haskell%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nebulyu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nebulyu's Blog">
      <meta itemprop="description" content="施工中(*>.<*)">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Nebulyu's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/haskell%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/" class="post-title-link" itemprop="url">haskell函数进阶</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2024-12-01 00:00:00 / Modified: 00:16:06" itemprop="dateCreated datePublished" datetime="2024-12-01T00:00:00+00:00">2024-12-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/haskell/" itemprop="url" rel="index"><span itemprop="name">haskell</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Haskell-函数进阶"><a href="#Haskell-函数进阶" class="headerlink" title="Haskell 函数进阶"></a>Haskell 函数进阶</h1><p>本文会涉及 Haskell 中的部分进阶函数概念.这些功能是 Haskell 编程的基础,也是许多高级功能的核心.函数不仅是输入和输出的工具,它们在 Haskell 中是一等公民,可以像数据一样传递、组合和操作.这种特性使得 Haskell 编程语言能够通过组合简单的函数来构建复杂的程序结构.Haskell 还具有惰性求值、类型推导和强大的高阶函数功能,让它非常适合表达数学模型和处理抽象问题.由于haskell官方库的东西太多太杂,而且有很多完全是实验性质的内容,本文只涉及一些极为常用的部分.</p>
<h2 id="简化函数"><a href="#简化函数" class="headerlink" title="简化函数"></a>简化函数</h2><p>简化函数是 Curry 化的应用,最常见的用途就是省去这个函数紧接着的参数</p>
<p>示例<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">divideByTen</span> :: (<span class="type">Floating</span> a) =&gt; a -&gt; a</span><br><span class="line"><span class="title">divideByTen</span> = (/<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">isUpperAlphanum</span> :: <span class="type">Char</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">isUpperAlphanum</span> = (`elem` [<span class="string">&#x27;A&#x27;</span>..<span class="string">&#x27;Z&#x27;</span>])</span><br></pre></td></tr></table></figure><br>说明</p>
<ul>
<li><strong><code>divideByTen</code></strong>: 这个函数接受一个数字,将其除以 10.它实际上是通过 Currying 技术将除法操作简化成了一个只接受一个参数的函数.</li>
<li><strong><code>isUpperAlphanum</code></strong>: 检查字符是否属于大写英文字母.</li>
</ul>
<p><strong>注意</strong>:</p>
<ul>
<li><code>(-4)</code> 表示负号操作.</li>
<li><code>subtract 4</code> 表示减去 4 的操作.</li>
</ul>
<p><br></p>
<h2 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h2><p>Haskell 中的函数可以作为输入参数传递.</p>
<p><strong>类型 <code>(a -&gt; a)</code></strong>:表示 <code>f</code> 是一个将 <code>a</code> 类型值映射到 <code>a</code> 类型值的函数.</p>
<p>示例<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">applyTwice</span> :: (a -&gt; a) -&gt; a -&gt; a</span><br><span class="line"><span class="title">applyTwice</span> f x = f (f x)</span><br></pre></td></tr></table></figure><br>说明</p>
<ul>
<li><strong><code>applyTwice</code></strong>:这个函数接受一个函数 <code>f</code> 和一个值 <code>x</code>,然后将 <code>f</code> 应用两次于 <code>x</code>.例如,applyTwice (+3) 10 会先将 10 增加 3 得到 13,再把 13 增加 3 得到 16.</li>
</ul>
<p>更多示例<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">applyTill</span> :: (<span class="type">Ord</span> t1, <span class="type">Num</span> t1) =&gt; (t2 -&gt; t2) -&gt; t2 -&gt; t1 -&gt; t2</span><br><span class="line"><span class="title">applyTill</span> f x n </span><br><span class="line">    | n &gt; <span class="number">1</span> = f (applyTill f x (n - <span class="number">1</span>))</span><br><span class="line">    | otherwise = f x</span><br><span class="line"></span><br><span class="line"><span class="title">zipWith&#x27;</span> :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]</span><br><span class="line"><span class="title">zipWith&#x27;</span> _ [] _ = []</span><br><span class="line"><span class="title">zipWith&#x27;</span> _ _ [] = []</span><br><span class="line"><span class="title">zipWith&#x27;</span> f (x:xs) (y:ys) = f x y : zipWith&#x27; f xs ys</span><br><span class="line"></span><br><span class="line"><span class="title">flip&#x27;</span> :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c</span><br><span class="line"><span class="title">flip&#x27;</span> f y x = f x y</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong><code>applyTill</code></strong>: 这个函数会将函数 <code>f</code> 应用到 <code>x</code> 上 <code>n</code> 次,直到达到终止条件.例如,applyTill (+1) 0 5 会递归地把 +1 操作应用 5 次.</li>
<li><strong><code>zipWith&#39;</code></strong>: 按照给定的二元函数,将两个列表对应位置的元素进行组合.</li>
<li><strong><code>flip&#39;</code></strong>: 交换二元函数的参数顺序.</li>
</ul>
<p><br></p>
<h2 id="Map-and-Filter"><a href="#Map-and-Filter" class="headerlink" title="Map and Filter"></a>Map and Filter</h2><p>map 和 filter 是列表操作的两大经典函数,它们的核心思想是将函数作用于列表中的每个元素,或者根据条件筛选元素.map 是一种批量操作,它将给定的函数作用于列表中的每个元素.而 filter 则是基于条件对列表进行筛选.它们都是典型的高阶函数,因为它们接受其他函数作为参数.这种函数式操作使得代码更加简洁,避免了显式的循环结构.</p>
<p>示例<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">map</span> :: (a -&gt; b) -&gt; [a] -&gt; [b]</span><br><span class="line"><span class="title">map</span> _ [] = []</span><br><span class="line"><span class="title">map</span> f (x:xs) = f x : map f xs</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong><code>map</code></strong>:将给定的函数 <code>f</code> 应用于列表的每个元素.例如,map (*2) [1,2,3] 会返回 [2,4,6].</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">filter</span> :: (a -&gt; <span class="type">Bool</span>) -&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">filter</span> _ [] = []</span><br><span class="line"><span class="title">filter</span> p (x:xs) </span><br><span class="line">    | p x       = x : filter p xs</span><br><span class="line">    | otherwise = filter p xs</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>filter</code></strong>:根据谓词 <code>p</code>过滤列表中的元素.例如,filter (&gt;2) [1,2,3,4] 会返回 [3,4],筛选出大于 2 的元素.</li>
</ul>
<p><br></p>
<h2 id="Fold"><a href="#Fold" class="headerlink" title="Fold"></a>Fold</h2><p>折叠操作是一种将列表中的元素合并成一个单一结果的方法.Haskell 提供了 foldl 和 foldr 两种方式,分别从左到右和从右到左地遍历列表.它们本质上是一种将递归模式转化为迭代的方式,在处理列表时非常高效.</p>
<p>示例<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sum&#x27;</span> :: (<span class="type">Num</span> a) =&gt; [a] -&gt; a</span><br><span class="line"><span class="title">sum&#x27;</span> xs = foldl (<span class="type">CHUacc</span> x -&gt; acc + x) <span class="number">0</span> xs</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>sum’</strong> :使用 foldl 从左到右对列表求和.foldl 的第一个参数是一个累积函数,0 是初始值,xs 是要遍历的列表.</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">map&#x27;</span> :: (a -&gt; b) -&gt; [a] -&gt; [b]</span><br><span class="line"><span class="title">map&#x27;</span> f xs = foldr (<span class="type">CHUx</span> acc -&gt; f x : acc) [] xs</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>map’</strong> :使用 foldr 实现的 map,它将每个元素通过函数 f 转换后返回新的列表.</p>
</li>
<li><p><strong>折叠的关键</strong>:遍历列表并根据元素返回结果.</p>
</li>
<li><strong>区别</strong>:<code>foldl</code> 从左到右,<code>foldr</code> 从右到左,右折叠可以处理无限列表.</li>
</ul>
<p><br></p>
<h2 id="运算符-和-组合"><a href="#运算符-和-组合" class="headerlink" title="运算符 $ 和 组合 ."></a>运算符 $ 和 组合 <code>.</code></h2><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符 $"></a>运算符 $</h3><p>$ 运算符是 Haskell 中一个非常特殊的运算符,它的优先级非常低(低于所有常见的操作符).事实上, $ 运算符的优先级是最低的(0),所以它会吞噬掉表达式中多余的括号.<code>$</code> 运算符的作用是将它右边的表达式应用到左边的函数上,等价于将一个函数应用于一个表达式.</p>
<p>在实际使用中,$ 最主要的作用是用来 减少括号,特别是在嵌套的函数调用中,避免过多的括号.</p>
<p>示例<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; sqrt $ <span class="number">3</span> + <span class="number">4</span> + <span class="number">9</span></span><br><span class="line"><span class="title">ghci</span>&gt; map ($ <span class="number">3</span>) [(<span class="number">4</span>+), (<span class="number">10</span>*), (^<span class="number">2</span>), sqrt]</span><br></pre></td></tr></table></figure></p>
<ul>
<li>$ :使用 $ 运算符,表达式 3 + 4 + 9 会先被求值,然后传递给 sqrt 函数,等同于 sqrt (3 + 4 + 9).</li>
</ul>
<h3 id="组合"><a href="#组合" class="headerlink" title="组合."></a>组合<code>.</code></h3><p>. 运算符是 函数组合运算符,它的作用是将多个函数组合成一个函数.. 运算符的优先级是较高的(9),比大多数运算符都要高.它是右结合的,也就是说它会将最右边的函数优先组合..通过这个运算符,您可以把多个简单的函数“串联”起来,形成一个新的函数,从而避免冗长的函数调用.</p>
<p>组合运算符:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fn</span> = ceiling . negate . tan . cos . max <span class="number">50</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>.</code> :将多个函数组合起来,使得函数调用更直观.fn 是一个组合函数,它先求 x 和 50 的最大值,再进行 cos 和 tan 运算,最后取负并取整.</li>
</ul>
<h3 id="和-结合使用的例子"><a href="#和-结合使用的例子" class="headerlink" title="$ 和 . 结合使用的例子"></a>$ 和 . 结合使用的例子</h3><p>有时,我们会在同一个表达式中同时使用 $ 和 .,这通常是为了优化代码的结构,使其更加简洁.例如:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; ceiling . sqrt $ <span class="number">3</span> + <span class="number">4</span> + <span class="number">9</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p>在这个例子中,$ 用来减少括号的使用,ceiling . sqrt 则先计算平方根,然后对结果取整.$ 确保 3 + 4 + 9 会先被求值,然后传递给组合后的函数.</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://nebulyu.github.io/%E9%87%8D%E6%96%B0%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nebulyu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nebulyu's Blog">
      <meta itemprop="description" content="施工中(*>.<*)">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Nebulyu's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E9%87%8D%E6%96%B0%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2024-11-24 18:39:26 / Modified: 18:49:16" itemprop="dateCreated datePublished" datetime="2024-11-24T18:39:26+00:00">2024-11-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>motion:<br>  enable: false<br>  async: false<br>  transition:</p>
<pre><code># All available transition variants: https://theme-next.js.org/animate/
menu_item: 
post_block: 
post_header: 
post_body: 
coll_header: 
# Only for Pisces | Gemini.
sidebar: fadeInDown
此处注意不填会导致侧边栏无法出现
</code></pre><p>动画</p>
<p><a target="_blank" rel="noopener" href="https://ferguschen.github.io/2016/11/11/%E3%80%90%E9%9A%8F%E8%AE%B0%E3%80%91hexo-next%E9%83%A8%E7%BD%B2%E5%90%8E%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%8D%9A%E5%AE%A2/">https://ferguschen.github.io/2016/11/11/%E3%80%90%E9%9A%8F%E8%AE%B0%E3%80%91hexo-next%E9%83%A8%E7%BD%B2%E5%90%8E%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%8D%9A%E5%AE%A2/</a><br>渲染问题</p>
<p>back2top:<br>  enable: true</p>
<h1 id="Back-to-top-in-sidebar"><a href="#Back-to-top-in-sidebar" class="headerlink" title="Back to top in sidebar."></a>Back to top in sidebar.</h1><p>  sidebar: false</p>
<h1 id="Scroll-percent-label-in-b2t-button"><a href="#Scroll-percent-label-in-b2t-button" class="headerlink" title="Scroll percent label in b2t button."></a>Scroll percent label in b2t button.</h1><p>  scrollpercent: true</p>
<p>bookmark:<br>  enable: true</p>
<h1 id="Customize-the-color-of-the-bookmark"><a href="#Customize-the-color-of-the-bookmark" class="headerlink" title="Customize the color of the bookmark."></a>Customize the color of the bookmark.</h1><p>  color: “#222”</p>
<h1 id="If-auto-save-the-reading-progress-when-closing-the-page-or-clicking-the-bookmark-icon"><a href="#If-auto-save-the-reading-progress-when-closing-the-page-or-clicking-the-bookmark-icon" class="headerlink" title="If auto, save the reading progress when closing the page or clicking the bookmark-icon."></a>If auto, save the reading progress when closing the page or clicking the bookmark-icon.</h1><h1 id="If-manual-only-save-it-by-clicking-the-bookmark-icon"><a href="#If-manual-only-save-it-by-clicking-the-bookmark-icon" class="headerlink" title="If manual, only save it by clicking the bookmark-icon."></a>If manual, only save it by clicking the bookmark-icon.</h1><p>  save: auto</p>
<h1 id="Vanilla-JavaScript-plugin-for-lazyloading-images"><a href="#Vanilla-JavaScript-plugin-for-lazyloading-images" class="headerlink" title="Vanilla JavaScript plugin for lazyloading images."></a>Vanilla JavaScript plugin for lazyloading images.</h1><h1 id="For-more-information-https-apoorv-pro-lozad-js-demo"><a href="#For-more-information-https-apoorv-pro-lozad-js-demo" class="headerlink" title="For more information: https://apoorv.pro/lozad.js/demo/"></a>For more information: <a target="_blank" rel="noopener" href="https://apoorv.pro/lozad.js/demo/">https://apoorv.pro/lozad.js/demo/</a></h1><p>lazyload: true</p>
<p>fancybox<br>fancybox 可以在点击图片时放大该图片，并且可以快速浏览当前文章的所有图片</p>
<h1 id="FancyBox-is-a-tool-that-offers-a-nice-and-elegant-way-to-add-zooming-functionality-for-images"><a href="#FancyBox-is-a-tool-that-offers-a-nice-and-elegant-way-to-add-zooming-functionality-for-images" class="headerlink" title="FancyBox is a tool that offers a nice and elegant way to add zooming functionality for images."></a>FancyBox is a tool that offers a nice and elegant way to add zooming functionality for images.</h1><h1 id="For-more-information-https-fancyapps-com-fancybox"><a href="#For-more-information-https-fancyapps-com-fancybox" class="headerlink" title="For more information: https://fancyapps.com/fancybox/"></a>For more information: <a target="_blank" rel="noopener" href="https://fancyapps.com/fancybox/">https://fancyapps.com/fancybox/</a></h1><p>fancybox: true</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://nebulyu.github.io/haskell%E5%87%BD%E6%95%B0%E5%9F%BA%E6%9C%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nebulyu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nebulyu's Blog">
      <meta itemprop="description" content="施工中(*>.<*)">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Nebulyu's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/haskell%E5%87%BD%E6%95%B0%E5%9F%BA%E6%9C%AC/" class="post-title-link" itemprop="url">haskell函数基本</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-11-20 00:00:00" itemprop="dateCreated datePublished" datetime="2024-11-20T00:00:00+00:00">2024-11-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-11-21 00:05:32" itemprop="dateModified" datetime="2024-11-21T00:05:32+00:00">2024-11-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/haskell/" itemprop="url" rel="index"><span itemprop="name">haskell</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Haskell-函数基础语法"><a href="#Haskell-函数基础语法" class="headerlink" title="Haskell 函数基础语法"></a>Haskell 函数基础语法</h1><p>作为函数式编程语言,haskell里的函数是一个极为广阔且多变的概念,所有的内容基本都可以归纳为函数及函数的构造方法</p>
<h2 id="函数的类型和类型类"><a href="#函数的类型和类型类" class="headerlink" title="函数的类型和类型类"></a>函数的类型和类型类</h2><p>Haskell 与一些传统语言不同,在运行时具有类型推断能力.我们可以直接写一个数字,而不必详细说明它是一个数字,Haskell 会自动推断出它的类型,确保函数类型符合规定.</p>
<p>常见类型问题:</p>
<ul>
<li>所有的显式类型使用大写字母开头</li>
<li><code>::</code> 是一种“具有…类型”的表示符</li>
<li><code>Int</code> 表示有界整数类型,类似于c中的int和long,而 <code>Integer</code> 表示无界整数类型</li>
</ul>
<p>一个值得注意的点,在使用数组长度length函数时<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fromIntegral</span> :: (<span class="type">Num</span> b, <span class="type">Integral</span> a) =&gt; a -&gt; b</span><br><span class="line"><span class="title">length</span> :: [a] -&gt; <span class="type">Int</span></span><br></pre></td></tr></table></figure><br>不可直接加非int,属于讨厌的历史遗留问题</p>
<p><br></p>
<h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><ul>
<li><strong>类型变量 <code>a</code></strong>:表示多态性.强调的是相同类型,而不是不同类型.例如,<code>a -&gt; a -&gt; a</code> 表示函数的输入和输出类型相同,而<code>a -&gt; b -&gt; a</code> 则不在乎两个参数的类型是否相同,而重视第一个参数和结果的类型相同</li>
</ul>
<p><br></p>
<h3 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h3><ul>
<li>类型约束使用 <code>=&gt;</code> 表示.例如,<code>(Eq a) =&gt; a -&gt; a -&gt; Bool</code> 表示输入值的类型必须是 <code>Eq</code> 类型类的成员</li>
<li>Eq包含所有默认定义的类型,一般不用特意强调</li>
<li><code>Ord</code> 类型类涵盖了所有标准比较函数(如 <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>).例如,<code>compare</code> 函数用于比较两个 <code>Ord</code> 成员,返回一个 <code>Ordering</code> 类型,该类型可以是 <code>GT</code>, <code>LT</code> 或 <code>EQ</code>,分别表示大于、小于或等于.</li>
<li>注意,<code>Num</code> 类型不直接包含 <code>Ord</code>,因此在定义函数时需要同时包含 <code>Num</code> 和 <code>Ord</code> 约束</li>
</ul>
<p>以下可以<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">abs</span> :: (<span class="type">Num</span> a, <span class="type">Ord</span> a) =&gt; a -&gt; a</span><br><span class="line"><span class="title">abs</span> x = <span class="keyword">if</span> (x &gt; <span class="number">0</span>) <span class="keyword">then</span> x <span class="keyword">else</span> -x</span><br></pre></td></tr></table></figure><br>以下不行<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">abs</span> :: <span class="type">Num</span> a =&gt; a -&gt; a</span><br><span class="line"><span class="title">abs</span> x = <span class="keyword">if</span> (x &gt; <span class="number">0</span>) <span class="keyword">then</span> x <span class="keyword">else</span> -x</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>模式匹配是 Haskell 中非常重要的特性,可以用来简洁地定义函数.</p>
<p>可以省去if-else</p>
<p>例如,以下是一个简单的模式匹配函数:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">lucky</span> :: (<span class="type">Integral</span> a) =&gt; a -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">lucky</span> <span class="number">7</span> = <span class="string">&quot;LUCKY NUMBER SEVEN!&quot;</span></span><br><span class="line"><span class="title">lucky</span> x = <span class="string">&quot;Sorry, you&#x27;re out of luck, pal!&quot;</span></span><br></pre></td></tr></table></figure><br>在这个函数中,模式会从上到下依次匹配,一旦匹配成功,就会使用对应的函数体.注意,尽管haskell对于不同函数的定义顺序没有要求,但是对同一函数参数的不同情况从上至下匹配</p>
<p><br></p>
<h3 id="元组的模式匹配"><a href="#元组的模式匹配" class="headerlink" title="元组的模式匹配"></a>元组的模式匹配</h3><p>模式匹配不仅可以用于列表,也可以用于元组.例如:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">addVectors</span> :: (<span class="type">Num</span> a) =&gt; (a, a) -&gt; (a, a) -&gt; (a, a)</span><br><span class="line"><span class="title">addVectors</span> (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)</span><br></pre></td></tr></table></figure><br>这种方式比使用 <code>fst</code> 和 <code>snd</code> 更加直观和简洁.</p>
<p>如果我们只关心元组中的某些值,可以使用下划线 <code>_</code> 来忽略不重要的部分:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">first</span> :: (a, b, c) -&gt; a</span><br><span class="line"><span class="title">first</span> (x, _, _) = x</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="as-模式"><a href="#as-模式" class="headerlink" title="as 模式"></a>as 模式</h3><p><code>as</code> 模式可以让我们在模式匹配的同时引用整体.例如:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">capital</span> :: <span class="type">String</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">capital</span> <span class="string">&quot;&quot;</span> = <span class="string">&quot;Empty string, whoops!&quot;</span></span><br><span class="line"><span class="title">capital</span> all@(x:xs) = <span class="string">&quot;The first letter of &quot;</span> ++ all ++ <span class="string">&quot; is &quot;</span> ++ [x]</span><br></pre></td></tr></table></figure><br>在这个例子中,<code>all@(x:xs)</code> 匹配字符串的第一个字符和剩余部分,同时 <code>all</code> 引用了整个字符串.</p>
<p>牛逼之处,便捷拆分同时引用整体.</p>
<p><br></p>
<h3 id="守卫-Guards"><a href="#守卫-Guards" class="headerlink" title="守卫(Guards)"></a>守卫(Guards)</h3><p>守卫是对函数参数进行条件检查的另一种方式,使用 <code>|</code> 符号.本质上也是一种条件的化简.例如:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">bmiTell</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">bmiTell</span> bmi</span><br><span class="line">    | bmi &lt;= <span class="number">18.5</span> = <span class="string">&quot;You&#x27;re underweight, you emo, you!&quot;</span></span><br><span class="line">    | bmi &lt;= <span class="number">25.0</span> = <span class="string">&quot;You&#x27;re supposedly normal. Pffft, I bet you&#x27;re ugly!&quot;</span></span><br><span class="line">    | bmi &lt;= <span class="number">30.0</span> = <span class="string">&quot;You&#x27;re fat! Lose some weight, fatty!&quot;</span></span><br><span class="line">    | otherwise   = <span class="string">&quot;You&#x27;re a whale, congratulations!&quot;</span></span><br></pre></td></tr></table></figure><br><code>otherwise</code> 实际上等价于 <code>True</code>,它可以捕获所有未被前面条件捕获的情况.</p>
<p>我们也可以在守卫中使用 <code>where</code> 绑定局部变量,使代码更具可读性:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">bmiTell</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; a -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">bmiTell</span> weight height</span><br><span class="line">    | bmi &lt;= skinny = <span class="string">&quot;You&#x27;re underweight, you emo, you!&quot;</span></span><br><span class="line">    | bmi &lt;= normal = <span class="string">&quot;You&#x27;re supposedly normal. Pffft, I bet you&#x27;re ugly!&quot;</span></span><br><span class="line">    | bmi &lt;= fat    = <span class="string">&quot;You&#x27;re fat! Lose some weight, fatty!&quot;</span></span><br><span class="line">    | otherwise     = <span class="string">&quot;You&#x27;re a whale, congratulations!&quot;</span></span><br><span class="line">    <span class="keyword">where</span> bmi = weight / height ^ <span class="number">2</span></span><br><span class="line">          skinny = <span class="number">18.5</span></span><br><span class="line">          normal = <span class="number">25.0</span></span><br><span class="line">          fat = <span class="number">30.0</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="case-表达式"><a href="#case-表达式" class="headerlink" title="case 表达式"></a>case 表达式</h3><p><code>case</code> 表达式可以对某个值进行模式匹配:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">describeList</span> :: [a] -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">describeList</span> xs = <span class="string">&quot;The list is &quot;</span> ++ <span class="keyword">case</span> xs <span class="keyword">of</span></span><br><span class="line">    []  -&gt; <span class="string">&quot;empty.&quot;</span></span><br><span class="line">    [x] -&gt; <span class="string">&quot;a singleton list.&quot;</span></span><br><span class="line">    xs  -&gt; <span class="string">&quot;a longer list.&quot;</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="let-表达式和-where-绑定"><a href="#let-表达式和-where-绑定" class="headerlink" title="let 表达式和 where 绑定"></a><code>let</code> 表达式和 <code>where</code> 绑定</h2><p><code>let</code> 表达式和 <code>where</code> 绑定都可以用来定义局部变量,但它们的作用范围不同.</p>
<ul>
<li><code>where</code> 绑定的变量在整个函数中可见.</li>
<li><code>let</code> 表达式的作用范围更小,只在 <code>in</code> 之后的代码中有效.</li>
</ul>
<p>例如:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">cylinder</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; a -&gt; a</span><br><span class="line"><span class="title">cylinder</span> r h =</span><br><span class="line">    <span class="keyword">let</span> sideArea = <span class="number">2</span> * pi * r * h</span><br><span class="line">        topArea = pi * r ^ <span class="number">2</span></span><br><span class="line">    <span class="keyword">in</span>  sideArea + <span class="number">2</span> * topArea</span><br></pre></td></tr></table></figure><br><code>let</code> 绑定本身也是一个表达式,因此可以在任何地方使用,例如列表推导式中:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">calcBmis</span> :: (<span class="type">RealFloat</span> a) =&gt; [(a, a)] -&gt; [a]</span><br><span class="line"><span class="title">calcBmis</span> xs = [bmi | (w, h) &lt;- xs, <span class="keyword">let</span> bmi = w / h ^ <span class="number">2</span>, bmi &gt;= <span class="number">25.0</span>]</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>haskell中的递归较c系更为优美,主要体现在边界条件的处理上一目了然</p>
<p>递归函数通常包括一个前置基准条件来终止递归,例如 <code>quicksort [] = []</code>,然后通过递归调用进行计算.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">quicksort</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">quicksort</span> [] = []</span><br><span class="line"><span class="title">quicksort</span> (x:xs) = </span><br><span class="line">    <span class="keyword">let</span> smallerSorted = quicksort [a | a &lt;- xs, a &lt;= x]</span><br><span class="line">        biggerSorted = quicksort [a | a &lt;- xs, a &gt; x]</span><br><span class="line">    <span class="keyword">in</span>  smallerSorted ++ [x] ++ biggerSorted</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h2><p>Haskell 中的 lambda 表达式使用 <code>\</code> 表示,这主要是因为<code>\</code>看起来比较像$\lambda$.例如:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">numLongChains</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">numLongChains</span> = length (filter (\xs -&gt; length xs &gt; <span class="number">15</span>) (map chain [<span class="number">1</span>..<span class="number">100</span>]))</span><br></pre></td></tr></table></figure><br><code>\xs -&gt; length xs &gt; 15</code> 定义了一个匿名函数,接受参数 <code>xs</code>,返回一个布尔值.</p>
<p><br></p>
<h1 id="柯里化-Curried"><a href="#柯里化-Curried" class="headerlink" title="柯里化 Curried"></a>柯里化 Curried</h1><p><strong>柯里化 (Currying)</strong> 是一种将一个接受多个参数的函数转换为一系列嵌套的单参数函数的技术.在 Haskell 和许多函数式编程语言中,所有函数默认都是柯里化的.这种技术源于逻辑学家 Haskell Curry 的工作,因此得名.是haskell比较实验性的一部分,直接把token分解放在了语言部分而非底层,其实c系语言在编译过程中接受新的token也是类似的过程.</p>
<p><br></p>
<h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>在柯里化中,一个多参数函数不直接接收所有参数,而是逐个接受参数,每次接受一个参数后,返回一个新的函数,用于处理剩余的参数.</p>
<p>例如：</p>
<ul>
<li>假设有一个函数 <code>f(x, y, z)</code>,它接收三个参数.</li>
<li>在柯里化的形式下,它可以看作 <code>f(x)(y)(z)</code>.</li>
<li>即调用 <code>f(x)</code> 返回一个函数 <code>g(y)</code>,然后调用 <code>g(y)</code> 返回另一个函数 <code>h(z)</code>,最后调用 <code>h(z)</code> 计算并返回最终结果.</li>
</ul>
<p><br></p>
<h2 id="Haskell-中的实现"><a href="#Haskell-中的实现" class="headerlink" title="Haskell 中的实现"></a>Haskell 中的实现</h2><p>Haskell 默认将所有函数看作柯里化函数.这意味着一个定义为 <code>a -&gt; b -&gt; c -&gt; d</code> 的函数被视为：</p>
<ol>
<li>首先接受一个参数 <code>a</code>,返回一个类型为 <code>b -&gt; c -&gt; d</code> 的函数.</li>
<li>然后,这个函数再接受参数 <code>b</code>,返回类型为 <code>c -&gt; d</code> 的函数.</li>
<li>最后,这个函数接受参数 <code>c</code>,返回最终结果 <code>d</code>.</li>
</ol>
<p>示例,定义一个接受三个参数的函数：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">addThree</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">addThree</span> x y z = x + y + z</span><br></pre></td></tr></table></figure>
<p>在实际使用中,<code>addThree</code> 可以被拆解为：</p>
<ol>
<li><code>addThree 1</code> 返回一个函数,该函数接受两个参数 <code>y</code> 和 <code>z</code>.</li>
<li><code>addThree 1 2</code> 返回另一个函数,该函数接受一个参数 <code>z</code>.</li>
<li>最后,<code>addThree 1 2 3</code> 直接计算并返回结果.</li>
</ol>
<p>以下代码说明了这一过程：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">let</span> addTwo = addThree <span class="number">1</span> <span class="number">2</span>  <span class="comment">-- addTwo 是一个函数,类型为 Int -&gt; Int</span></span><br><span class="line"><span class="title">addTwo</span> <span class="number">3</span>                  <span class="comment">-- 结果为 6</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="柯里化与部分应用"><a href="#柯里化与部分应用" class="headerlink" title="柯里化与部分应用"></a>柯里化与部分应用</h2><p>柯里化的直接好处之一是 <strong>部分应用</strong>,即只提供部分参数来创建一个新函数.这在 Haskell 中很常见：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">multThree</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">multThree</span> x y z = x * y * z</span><br><span class="line"></span><br><span class="line"><span class="title">let</span> doubleWithSix = multThree <span class="number">6</span></span><br><span class="line"><span class="title">doubleWithSix</span> <span class="number">2</span> <span class="number">3</span>  <span class="comment">-- 等价于 multThree 6 2 3,结果为 36</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="非柯里化-Uncurried"><a href="#非柯里化-Uncurried" class="headerlink" title="非柯里化 (Uncurried)"></a>非柯里化 (Uncurried)</h2><p>对比柯里化,非柯里化函数会接受所有参数作为一个元组.例如：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">addThreeUncurried</span> :: (<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">addThreeUncurried</span> (x, y, z) = x + y + z</span><br></pre></td></tr></table></figure>
<p>调用方式：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">addThreeUncurried</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment">-- 参数必须打包为一个元组</span></span><br></pre></td></tr></table></figure>
<p>Haskell 中的柯里化使得函数更加灵活,而非柯里化则更接近传统的多参数函数形式.</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://nebulyu.github.io/haskell%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nebulyu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nebulyu's Blog">
      <meta itemprop="description" content="施工中(*>.<*)">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Nebulyu's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/haskell%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">haskell基本语法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2024-11-19 00:00:00 / Modified: 16:42:40" itemprop="dateCreated datePublished" datetime="2024-11-19T00:00:00+00:00">2024-11-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/haskell/" itemprop="url" rel="index"><span itemprop="name">haskell</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="语法入门"><a href="#语法入门" class="headerlink" title="语法入门"></a>语法入门</h1><p>haskell作为一个实验性强于实践性的语言,有很多基础语法与传统的c系差异巨大,以往的知识,除了算法,难以直接代入,基本上就是要完全重新开始学.</p>
<p>本文主要面向对c,cpp等命令式编程语言熟悉的读者,主要的内容在于一些思维陷阱和新颖语法的记录,对于haskell中非常基础并且和其他语言相似的部分不会着墨.</p>
<p>关于教材与参考:</p>
<p>不要在入门的时候再看什么中文教材了,尤其是《Haskell函数式编程入门》这种教材.它具有典型的缺陷,比如一次性引入过多新知识而没有完整解释,包含大量与程序无关的冗长内容,对某些可能已经更改的语法细节过度纠结,缺乏渐进的示例,语言表述不准确,甚至有些内容显得玄妙或晦涩.这种教材更适合作为字典使用,而不是入门教材.</p>
<p>推荐 <a target="_blank" rel="noopener" href="https://learnyouahaskell.com/ ">learn you a haskell</a>.这个教材简明易懂,作为入门来说非常适合,英语也比较平白无华,属于说人话而不怎么说废话的教材.更好的是在线版本免费</p>
<p>haskell可以下载安装后使用vscode作为ide, 常见解释器ghci 即 glasgow haskell compiler iterative, 便于入门学习</p>
<p><br></p>
<h2 id="基本常识"><a href="#基本常识" class="headerlink" title="基本常识"></a>基本常识</h2><p>不等于用<code>/=</code>来表示</p>
<p>Haskell中用空格来表示参数直接的间隔,不需要<code>,</code><br>比如<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">add</span> <span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>如果你看到类似 <code>bar (bar 3)</code> 的表达式,它并不是将 <code>bar</code> 和 <code>3</code> 作为参数传递给 <code>bar</code>,而是先用 <code>3</code> 调用函数 <code>bar</code>,得到一个结果,然后再用这个结果调用一次 <code>bar</code>.在C语言中,类似于 <code>bar(bar(3))</code>.</p>
<p>Haskell中的函数定义不依赖于文本顺序.这个意味着在程序文本中随意调换不同函数的顺序不会有什么影响.</p>
<p>函数名称以小写字母开头,类型名称以大写字母开头.这个并不只是约定俗成的传统,而是系统强制的要求</p>
<p>haskell中没有常见意义里的循环遍历,而是采用函数的方式处理,基础语法中暂不涉及,放在后面函数部分中</p>
<p><br></p>
<h2 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h2><p>具体格式为<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">if</span> condition <span class="keyword">then</span> action1 <span class="keyword">else</span> action2</span><br></pre></td></tr></table></figure></p>
<p><code>else</code> 是强制要求的.</p>
<p><br></p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>在haskell中数组的本质:语法糖,对列表的简写,下面的写法是完全等价的<br>$[a_1,a_i,a_n] == a_1:a_i:a_n:[] == a_1:a_i:a_n$<br>其中<code>x:xs</code>代表元素<code>x</code>连接列表<code>xs</code>,<code>[]</code>代表空集</p>
<p>由于列表本质是同类元素连接的属性,一个列表中绝对只能含有完全同类的元素</p>
<p>字符串也是一个语法糖,其完全等价于字符数组<br><code>&quot;Ciallo&quot; == [&#39;C&#39;,&#39;i&#39;,&#39;a&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;] == &#39;C&#39;:&#39;i&#39;:&#39;a&#39;:&#39;l&#39;:&#39;l&#39;:&#39;o&#39;:[]</code></p>
<p>集合中的空集,注意:<code>[]</code>、<code>[[]]</code> 和 <code>[[],[],[]]</code> 是完全不同的.第一个是空列表,第二个是包含一个空列表的列表,第三个是包含三个空列表的列表.</p>
<p>数组下标从0开始,下标取值:<code>!!</code></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [<span class="number">9.4</span>,<span class="number">33.2</span>,<span class="number">96.2</span>,<span class="number">11.2</span>,<span class="number">23.25</span>] !! <span class="number">1</span></span><br><span class="line"><span class="number">33.2</span></span><br></pre></td></tr></table></figure>
<p><code>++</code> 用于合并数组,两个操作数必须都是数组.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="string">&quot;114&quot;</span> ++ <span class="string">&quot;514&quot;</span></span><br><span class="line"><span class="string">&quot;114514&quot;</span></span><br></pre></td></tr></table></figure>
<p>比较大小:同类型按字典序比较.</p>
<p><code>head</code> 和 <code>tail</code> 表示列表的头部和尾部,<code>init</code> 和 <code>last</code> 表示列表的初始部分和最后一个元素.</p>
<p><code>take</code> 从列表前面取若干元素,<code>drop</code> 从列表中删除前若干元素.</p>
<p><code>head _______________________tail</code><br><code>|[-----------------------------]</code><br><code>********************************</code><br><code>[-----------------------------]|</code><br><code>init________________________last</code></p>
<p><code>elem</code> 判断元素是否存在于列表中.</p>
<p>生成数列示例:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; take <span class="number">24</span> [<span class="number">13</span>,<span class="number">26</span>..]</span><br></pre></td></tr></table></figure>
<p>循环:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; take <span class="number">10</span> (cycle [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; take <span class="number">12</span> (cycle <span class="string">&quot;LOL &quot;</span>)</span><br><span class="line"><span class="string">&quot;LOL LOL LOL &quot;</span></span><br></pre></td></tr></table></figure>
<p>重复:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; take <span class="number">10</span> (repeat <span class="number">5</span>)</span><br><span class="line">[<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p>管道符号前面的部分称为输出函数,<code>x</code> 是变量,<code>N</code> 是输入集合,<code>x &lt;= 10</code> 是谓词.这意味着集合包含了所有满足谓词的自然数的两倍值.</p>
<p><code>&lt;-</code> 表示属于:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [x*<span class="number">2</span> | x &lt;- [<span class="number">1</span>..<span class="number">10</span>]]</span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; [x*<span class="number">2</span> | x &lt;- [<span class="number">1</span>..<span class="number">10</span>], x*<span class="number">2</span> &gt;= <span class="number">12</span>]</span><br><span class="line">[<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; [ x*y | x &lt;- [<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>], y &lt;- [<span class="number">8</span>,<span class="number">10</span>,<span class="number">11</span>]]</span><br><span class="line">[<span class="number">16</span>,<span class="number">20</span>,<span class="number">22</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">55</span>,<span class="number">80</span>,<span class="number">100</span>,<span class="number">110</span>]</span><br></pre></td></tr></table></figure>
<p>组合名词和形容词:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> nouns = [<span class="string">&quot;hobo&quot;</span>,<span class="string">&quot;frog&quot;</span>,<span class="string">&quot;pope&quot;</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> adjectives = [<span class="string">&quot;lazy&quot;</span>,<span class="string">&quot;grouchy&quot;</span>,<span class="string">&quot;scheming&quot;</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [adjective ++ <span class="string">&quot; &quot;</span> ++ noun | adjective &lt;- adjectives, noun &lt;- nouns]</span><br><span class="line">[<span class="string">&quot;lazy hobo&quot;</span>,<span class="string">&quot;lazy frog&quot;</span>,<span class="string">&quot;lazy pope&quot;</span>,<span class="string">&quot;grouchy hobo&quot;</span>,<span class="string">&quot;grouchy frog&quot;</span>,<span class="string">&quot;grouchy pope&quot;</span>,<span class="string">&quot;scheming hobo&quot;</span>,<span class="string">&quot;scheming frog&quot;</span>,<span class="string">&quot;scheming pope&quot;</span>]</span><br></pre></td></tr></table></figure>
<p><code>_</code> 表示任意值,仅关心其存在:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">length&#x27;</span> xs = sum [<span class="number">1</span> | _ &lt;- xs]</span><br></pre></td></tr></table></figure>
<p>与数论中对1求和相似.</p>
<p>过滤偶数示例:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> xxs = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>]]</span><br><span class="line"><span class="title">ghci</span>&gt; [ [ x | x &lt;- xs, even x ] | xs &lt;- xxs]</span><br><span class="line">[[<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">6</span>]]</span><br></pre></td></tr></table></figure>
<p>首先从 <code>xxs</code> 中取出每个子列表 <code>xs</code>,然后再从 <code>xs</code> 中取出符合条件的元素.</p>
<p><br></p>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>元组,tuple,可以包含列表,例如字符串.</p>
<p>元组更加严格,因为每种不同大小的元组都有自己的类型,所以不能编写通用函数来向元组追加元素.</p>
<p>没有一元元组,或者说一元元组就是单个元素本身.</p>
<p><code>fst</code> 和 <code>snd</code> 只能用于二元组.</p>
<p><code>zip</code> 自动截取:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; zip [<span class="number">5</span>..<span class="number">15</span>] [<span class="string">&quot;im&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;turtle&quot;</span>]</span><br><span class="line">[(<span class="number">5</span>,<span class="string">&quot;im&quot;</span>),(<span class="number">6</span>,<span class="string">&quot;a&quot;</span>),(<span class="number">7</span>,<span class="string">&quot;turtle&quot;</span>)]</span><br></pre></td></tr></table></figure>
<p>求满足条件的直角三角形:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> rightTriangles&#x27; = [ (a,b,c) | c &lt;- [<span class="number">1</span>..<span class="number">10</span>], b &lt;- [<span class="number">1</span>..c], a &lt;- [<span class="number">1</span>..b], a^<span class="number">2</span> + b^<span class="number">2</span> == c^<span class="number">2</span>, a+b+c == <span class="number">24</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; rightTriangles&#x27;</span><br><span class="line">[(<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>)]</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://nebulyu.github.io/%E6%B5%B7%E4%B8%8A%E7%94%9F%E6%98%8E%E6%9C%88,%E5%A4%A9%E6%B6%AF%E5%85%B1%E6%AD%A4%E6%97%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nebulyu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nebulyu's Blog">
      <meta itemprop="description" content="施工中(*>.<*)">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Nebulyu's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E6%B5%B7%E4%B8%8A%E7%94%9F%E6%98%8E%E6%9C%88,%E5%A4%A9%E6%B6%AF%E5%85%B1%E6%AD%A4%E6%97%B6/" class="post-title-link" itemprop="url">海上生明月,天涯共此时</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-09-29 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-29T00:00:00+01:00">2024-09-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-11-16 23:08:27" itemprop="dateModified" datetime="2024-11-16T23:08:27+00:00">2024-11-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%8B%B1%E5%9B%BD%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index"><span itemprop="name">英国随笔</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%8B%B1%E5%9B%BD%E9%9A%8F%E7%AC%94/%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>忍无可忍后,写下此文</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/%E6%B5%B7%E4%B8%8A%E7%94%9F%E6%98%8E%E6%9C%88,%E5%A4%A9%E6%B6%AF%E5%85%B1%E6%AD%A4%E6%97%B6/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://nebulyu.github.io/icpc2023%E6%9D%AD%E5%B7%9E%E6%B8%B8%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nebulyu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nebulyu's Blog">
      <meta itemprop="description" content="施工中(*>.<*)">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Nebulyu's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/icpc2023%E6%9D%AD%E5%B7%9E%E6%B8%B8%E8%AE%B0/" class="post-title-link" itemprop="url">icpc2023杭州游记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-12-13 00:00:00" itemprop="dateCreated datePublished" datetime="2023-12-13T00:00:00+00:00">2023-12-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-09-24 23:29:10" itemprop="dateModified" datetime="2024-09-24T23:29:10+01:00">2024-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI-XCPC%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">OI-XCPC竞赛</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI-XCPC%E7%AB%9E%E8%B5%9B/ACM/" itemprop="url" rel="index"><span itemprop="name">ACM</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI-XCPC%E7%AB%9E%E8%B5%9B/ACM/%E6%B8%B8%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">游记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>xcpc比赛的最后一舞</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/icpc2023%E6%9D%AD%E5%B7%9E%E6%B8%B8%E8%AE%B0/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://nebulyu.github.io/icpc2023%E5%90%88%E8%82%A5%E6%B8%B8%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nebulyu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nebulyu's Blog">
      <meta itemprop="description" content="施工中(*>.<*)">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Nebulyu's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/icpc2023%E5%90%88%E8%82%A5%E6%B8%B8%E8%AE%B0/" class="post-title-link" itemprop="url">icpc2023合肥游记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-29 00:00:00" itemprop="dateCreated datePublished" datetime="2023-11-29T00:00:00+00:00">2023-11-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-09-24 23:29:12" itemprop="dateModified" datetime="2024-09-24T23:29:12+01:00">2024-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI-XCPC%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">OI-XCPC竞赛</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI-XCPC%E7%AB%9E%E8%B5%9B/ACM/" itemprop="url" rel="index"><span itemprop="name">ACM</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI-XCPC%E7%AB%9E%E8%B5%9B/ACM/%E6%B8%B8%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">游记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>发烧友你们好（</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/icpc2023%E5%90%88%E8%82%A5%E6%B8%B8%E8%AE%B0/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://nebulyu.github.io/ccpc2023%E6%B7%B1%E5%9C%B3%E6%B8%B8%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nebulyu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nebulyu's Blog">
      <meta itemprop="description" content="施工中(*>.<*)">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Nebulyu's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/ccpc2023%E6%B7%B1%E5%9C%B3%E6%B8%B8%E8%AE%B0/" class="post-title-link" itemprop="url">ccpc2023深圳游记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-18 00:00:00" itemprop="dateCreated datePublished" datetime="2023-11-18T00:00:00+00:00">2023-11-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-09-24 23:30:05" itemprop="dateModified" datetime="2024-09-24T23:30:05+01:00">2024-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI-XCPC%E7%AB%9E%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">OI-XCPC竞赛</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI-XCPC%E7%AB%9E%E8%B5%9B/ACM/" itemprop="url" rel="index"><span itemprop="name">ACM</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI-XCPC%E7%AB%9E%E8%B5%9B/ACM/%E6%B8%B8%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">游记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>第一次xcpc线下赛。箱子酱全程鞭打，忠实奴仆被迫营业。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/ccpc2023%E6%B7%B1%E5%9C%B3%E6%B8%B8%E8%AE%B0/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://nebulyu.github.io/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%85%A8%E5%AE%B6%E6%A1%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nebulyu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nebulyu's Blog">
      <meta itemprop="description" content="施工中(*>.<*)">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Nebulyu's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%85%A8%E5%AE%B6%E6%A1%B6/" class="post-title-link" itemprop="url">多项式全家桶</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-07 00:00:00" itemprop="dateCreated datePublished" datetime="2023-11-07T00:00:00+00:00">2023-11-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-11-16 07:40:35" itemprop="dateModified" datetime="2023-11-16T07:40:35+00:00">2023-11-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ACM/" itemprop="url" rel="index"><span itemprop="name">ACM</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ACM/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>多项式全家桶</p>
<p><br></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%85%A8%E5%AE%B6%E6%A1%B6/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/home/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/home/page/5/">5</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/home/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">nebulyu's</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>



  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","per_page":true,"mhchem":true,"js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML"}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
