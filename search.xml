<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello world</title>
    <url>/2022/07/17/hello-world/</url>
    <content><![CDATA[<h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><p>时隔两年，终于成功的搭建了hexo博客，中途踩坑无数，希望这是最后一个helloworld</p>
]]></content>
  </entry>
  <entry>
    <title>2022.9.18icpc网赛摸鱼记</title>
    <url>/2022/09/21/2022.9.18icpc/</url>
    <content><![CDATA[<h4 id="2022-9-18icpc网赛"><a href="#2022-9-18icpc网赛" class="headerlink" title="2022.9.18icpc网赛"></a>2022.9.18icpc网赛</h4><p><a href="https://pintia.cn/problem-sets/1571150153619189760">https://pintia.cn/problem-sets/1571150153619189760</a></p>
<span id="more"></span>
<p>第一次参加正式的icpc比赛,尽管最近一直在打abc练手,但感觉还是力不从心.一是对icpc没有部分分的模式还不太熟悉,二是和队友的配合不够默契,三是码力下降不少,有两个本来可过的题寄了.幸亏队友还给力,一起口胡最后A掉4题.</p>
<p><br></p>
<h5 id="L"><a href="#L" class="headerlink" title="L"></a>L</h5><p>开的第一个题,第一眼就是sam之类的字符串转移,直接跑了.后来和老哥一起分析时又口胡建图,猜了一手结论:每个点只用向最近的同一字母转移.<br>建图的思路没错,但是连边的可行条件分析没分析到位,直接判是否在t串中相邻,实际上应该把t串中前后全部字母组合ban掉.于是痛挂一题.<br><br></p>
<h5 id="H"><a href="#H" class="headerlink" title="H"></a>H</h5><p>倒序开题没有思路,跟榜去做签到题.直接用栈模拟操作,1发A.<br><br></p>
<h5 id="A"><a href="#A" class="headerlink" title="A"></a>A</h5><p>乍一看毫无头绪,不过数学大佬点明了关键性质,一块连续的1只有$(len+1)/2$个”有效1”.每一个”有效1”能消掉3个元素,若一个串中”有效1”不足$1/3$,z则需要操作补1.区间染色,前缀和求和,复杂度$O(q)$.第一发T了,加了个快读就直接过了<br><br></p>
<h5 id="C"><a href="#C" class="headerlink" title="C"></a>C</h5><p>考场上队友切掉的.答案就是叶子节点个数.<br>这个做法的正确性:对于所有的叶子节点,只能采用delete.考虑整棵树对每个节点只留下一个叶子,其余的全部删掉,然后shrink所有的单链,不断重复这个过程,可以发现所有的非叶子节点都可以被shrink.可以得到需要delete的只有叶节点<br><br></p>
<h5 id="D"><a href="#D" class="headerlink" title="D"></a>D</h5><p>在考试时看假了题,以为是01个数相等,还差点误导了队友,最后s大佬切了.<br>考完再看这题才发觉是水题,直接dfs预处理,二分答案即可.<br><br></p>
<h5 id="K"><a href="#K" class="headerlink" title="K"></a>K</h5><p>由于太菜只会$n^3$dp,于是想到了记搜剪枝.但是剪枝的条件并没有思考完备,白白的写了半个小时的假题,不仅没想出怎么优化,最后甚至正确性都没有.似乎有神仙乱剪过了,后面再找std看看吧<br><br></p>
<h5 id="G"><a href="#G" class="headerlink" title="G"></a>G</h5><p>同样,由于太菜,只能想到裸暴力dp.一直在纠结$n^5$的复杂度,却忽视了选取多个连续时实际状态并不算多,写完心虚不敢久调,又浪费时间写了假题.<br><br><br>这场满打满算可以切掉7题,尽管第一次正式赛失误无可避免,但只搞掉4题还是有遗憾.根据最近打的3场比赛,目前最主要的目的并不是复习一些高级算法的用法,毕竟几乎用不到,而是多做一些dp,搜索之类的需要处理边界条件的题目,很久没做题带来的生疏大概就体现在细节不会写了吧.</p>
]]></content>
  </entry>
  <entry>
    <title>abc262</title>
    <url>/2022/09/21/abc262/</url>
    <content><![CDATA[<h1 id="abc262"><a href="#abc262" class="headerlink" title="abc262"></a>abc262</h1><p><a href="https://atcoder.jp/contests/abc262">https://atcoder.jp/contests/abc262</a></p>
<span id="more"></span>
<p>D:首先看数据范围,很明显是个$n^3$或$n^4$的题.首先枚举当前要用的数k,考虑到k的同余系下答案相等,先对序列取模,再更新背包.枚举k需要$O(n)$,序列中有n个数,每次更新背包需要$O(n^2)$,总复杂度$O(n^4)$.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">For</span>(id,<span class="number">1</span>,n)&#123;</span><br><span class="line">        ri v=ar[id]%M;</span><br><span class="line">        <span class="comment">//dp[i][j] 选用i个数,拼成剩余系下的j </span></span><br><span class="line">        <span class="built_in">iFor</span>(i,n,<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">For</span>(j,<span class="number">0</span>,M<span class="number">-1</span>)&#123;</span><br><span class="line">            dp[i][j]=(dp[i][j]+dp[i<span class="number">-1</span>][(j-v+M)%M])%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=(ans+dp[M][<span class="number">0</span>])%MOD; <span class="comment">//最后答案为用M个数拼成0</span></span><br></pre></td></tr></table></figure>
<p>E:考虑所有标记过点的出度总和S,与标记过点相连的同色的边数R,不同色的边数D,满足$S=D+2R$,即若D为偶数,则S必为偶数.于是原问题可转化为从原图中选出若干点,使其出度总和为偶数,求方案数.此时点的出度可直接分为奇偶,组合数求和即可<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(ri i=<span class="number">0</span>;i*<span class="number">2</span>&lt;=k;++i) ans=(ans+<span class="built_in">C</span>(c[<span class="number">0</span>],k-i*<span class="number">2</span>)*<span class="built_in">C</span>(c[<span class="number">1</span>],i*<span class="number">2</span>)%MOD)%MOD;</span><br></pre></td></tr></table></figure></p>
<p>F:根据字典序,找出k能到达的范围内最小值lead.如果选择转动操作,需要转动的点仅在lead后方.这样仅用分两种情况讨论,直接删和转后再删.对于直接删的情况,维护一个单调栈,每次更新时执行删除操作.<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For(i,1,n)&#123;</span><br><span class="line">        while(p&amp;&amp;ar[i]&lt;ar[sta1[p]]&amp;&amp;r)--r,--p;</span><br><span class="line">        ++p,sta1[p]=i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>如果旋转,旋转后的点删除不需要花费<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(p&amp;&amp;ar[i]&lt;ar[sta2[p]]&amp;&amp;(r&gt;=(sta2[p]&lt;ld)))r-=(sta2[p]&lt;ld),--p;</span><br><span class="line">        ++p,sta2[p]=i;</span><br></pre></td></tr></table></figure><br>最后比较两个答案的大小即可</p>
]]></content>
  </entry>
  <entry>
    <title>fhqtreap</title>
    <url>/2022/10/21/fhqtreap/</url>
    <content><![CDATA[<h1 id="fhqtreap"><a href="#fhqtreap" class="headerlink" title="fhqtreap"></a>fhqtreap</h1><p>这个神仙级nb的数据结构得名于神仙范皓强,既有treap的易写易懂,也有splay般易于区间处理的能力.<br><span id="more"></span><br><br></p>
<h2 id="列队"><a href="#列队" class="headerlink" title="列队"></a>列队</h2><p><a href="https://www.luogu.com.cn/problem/P3960">https://www.luogu.com.cn/problem/P3960</a><br>题意:一个nm的矩阵,每次取出一个指定位置的数,求出这个数的编号,并把矩阵里的数先向左补齐再想上补齐,最后把取出的数塞到右下角.其中$n,m,q\in(1,3e5)$<br>考虑每次更改的部分,只有当前的行和最后一列会有更改.于是对每一行和最后一列建立平衡树维护矩阵.但是这样做的空间复杂度是$O(nm)$,无法承受.<br>由于大部分数都不会被更改,每个点都去维护的话实际上浪费了大量空间.那么就考虑去合并这些不会被更改的点,更好的做法就是直接维护区间,有分裂的需求时再动态开点.一开始对每行插入$(1,m-1)$的区间,对末尾列直接插入每一个数.在split时开新点分割区间.<br>此处的treap按排名分裂.需要注意fhqtreap的合并顺序,以及新开的点与原树的相对位置.这个细节废了我一个下午.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mer</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x+y;</span><br><span class="line">    <span class="keyword">if</span>(rd[x]&gt;=rd[y])<span class="keyword">return</span> <span class="built_in">rs</span>(x)=<span class="built_in">mer</span>(<span class="built_in">rs</span>(x),y),<span class="built_in">upd</span>(x),x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">ls</span>(y)=<span class="built_in">mer</span>(x,<span class="built_in">ls</span>(y)),<span class="built_in">upd</span>(y),y; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splp</span><span class="params">(<span class="type">int</span> p,ll k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;=<span class="built_in">len</span>(p)) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> x=<span class="built_in">alc</span>(L[p]+k,R[p]);</span><br><span class="line">    R[p]=L[x]<span class="number">-1</span>,<span class="built_in">rs</span>(p)=<span class="built_in">mer</span>(x,<span class="built_in">rs</span>(p)),<span class="built_in">upd</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spl</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y,ll v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> x=y=<span class="number">0</span>,<span class="built_in">void</span>();</span><br><span class="line">    <span class="keyword">if</span>(sz[<span class="built_in">ls</span>(p)]&gt;=v) y=p,<span class="built_in">spl</span>(<span class="built_in">ls</span>(p),x,<span class="built_in">ls</span>(p),v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">splp</span>(p,v-sz[<span class="built_in">ls</span>(p)]),x=p,<span class="built_in">spl</span>(<span class="built_in">rs</span>(p),<span class="built_in">rs</span>(p),y,v-sz[<span class="built_in">ls</span>(p)]-<span class="built_in">len</span>(p));</span><br><span class="line">    <span class="built_in">upd</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>icpc2022济南游寄</title>
    <url>/2022/12/01/icpc2022%E6%B5%8E%E5%8D%97%E6%B8%B8%E5%AF%84/</url>
    <content><![CDATA[<p>第一次正式参加区域赛，不得不水一篇小作文了。</p>
<span id="more"></span>
<p>早上本来想睡个难得的好觉，突然起来发现有正式赛，于是飞速嗦了一碗粉，一路小跑润到机房。到了一看才十点，人都没来几个，就享受受刑前的快乐睡眠。<br>之前测环境已经测好了，预计不会出什么问题，但队长的vs自动补全没办法完全关掉，焦虑了一小会儿，决定用dev为主。</p>
<p>开场拿到题目，m题感觉可做，应该是个贪心，不过还是继续往前看看再说。<br>k题签到题一眼秒，写出来几乎没怎么调，8分钟a掉，还算不错。<br>签完k队友开始输出，我就去开题了。花了大量时间在金牌题上，感觉最短路倍增可写，就开始小推式子，中间花了十几分钟写了假题，最后意识到做法是n4的，结束表演转而跟榜。</p>
<p>大概这个时候z老师正在折磨s老师调e吧，看了acd，感觉没有一眼题。小猜了一个a的结论，目标区间一定连续，先除二后加减。<br>和z老师达成了共识，他继续折磨s老师写题，我就去玩c了。</p>
<p>一开始没什么思路，想着换根。上了两个厕所后，发现儿子的状态可以直接继承父亲，子树内顺序无限制，处理兄弟的状态就可以了。<br>于是大力推了一波式子，感觉很对。虽然看似n4，主定理分析后觉得可以n3。跟队友说了，都觉得行，于是飞速码题。<br>码完还有二十分钟，交一发t了，发现会被菊花卡掉。<br>z老师给出了一个优化，size相同的兄弟等价。乍一想很对，于是加上，wa，到结束都没调出来。后来发现size相同的兄弟子树可能不同，应该除掉自身子树的方案再乘上兄弟子树的方案才对。</p>
<p>跟大家一起去吃晚饭，见识到什么叫活不过一圈的菜。<br>最后尾银，滚榜滚到时整个人才放松下来。c没做出来有点遗憾，不过就算做出来了也不一定有au。<br>希望南京能冲一把au。</p>
]]></content>
  </entry>
  <entry>
    <title>单调数据结构小结</title>
    <url>/2022/09/16/%E5%8D%95%E8%B0%83/</url>
    <content><![CDATA[<p>复建的第一步!虽然仅仅水了一些单调栈和单调队列的题</p>
<span id="more"></span>
<h5 id="abc262-F"><a href="#abc262-F" class="headerlink" title="abc262 F"></a>abc262 F</h5><p><a href="https://atcoder.jp/contests/abc262/tasks/abc262_f">https://atcoder.jp/contests/abc262/tasks/abc262_f</a><br>根据字典序,找出k能到达的范围内最小值lead.如果选择转动操作,需要转动的点仅在lead后方.这样仅用分两种情况讨论,直接删和转后再删.对于直接删的情况,维护一个单调栈,每次更新时执行删除操作.<br><!-- more --></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;ar[i]&lt;ar[sta1[p]]&amp;&amp;r)--r,--p;</span><br><span class="line">        ++p,sta1[p]=i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果旋转,旋转后的点删除不需要花费<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(p&amp;&amp;ar[i]&lt;ar[sta2[p]]&amp;&amp;(r&gt;=(sta2[p]&lt;ld)))</span><br><span class="line">    r-=(sta2[p]&lt;ld),--p;</span><br><span class="line">++p,sta2[p]=i;</span><br></pre></td></tr></table></figure><br>最后比较两个答案的大小即可<br><br><br></p>
<h5 id="某大佬原创题"><a href="#某大佬原创题" class="headerlink" title="某大佬原创题"></a>某大佬原创题</h5><p>长度为n的数组 q个询问 每次询问给出一个长度L，最大化长度为L的连续子序列的最小值,$n,q\leq5e6,a_i\leq1e9$<br><br><br>对于每个点,可以记录成为min值的区间左右端点并更新答案,同时短区间的答案可由长区间继承.<br>关于这个做法的正确性,就是考虑是否每个点都对每个区间的答案进行过更新.对于长度大于$len=r-l+1$的区间,即使更新也不会使答案更优,没有必要考虑.对于长度短于$len$的区间,直接从比较过后的长区间继承,可以保证所有短区间都被更新到.<br>这样答案满足完全覆盖,不存在漏解的情况</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n) ans[r[i]-l[i]+<span class="number">1</span>]=<span class="built_in">max</span>(ans[r[i]-l[i]+<span class="number">1</span>],h[i]);</span><br><span class="line"><span class="built_in">iFor</span>(i,n<span class="number">-1</span>,<span class="number">1</span>) ans[i]=<span class="built_in">max</span>(ans[i],ans[i+<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<p><br><br></p>
<h5 id="luoguP1250"><a href="#luoguP1250" class="headerlink" title="luoguP1250"></a>luoguP1250</h5><p><a href="https://www.luogu.com.cn/problem/P1950">https://www.luogu.com.cn/problem/P1950</a></p>
<p>首先可以发现若将每一行分别作为常规单调栈矩形计数的问题,并不会影响上下层的结果,并且可以直接继承高度信息.于是就转化为做n次单调栈.<br>值得注意的是对于相连的等高项的处理,如果l[i],r[i]均只记录第一个更低位置,那么对于等高的i,i+1,这个区间内的矩形会重复计数.所以需要一个严格单调一个不严格来保证不重<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(tp2&amp;&amp;h[st2[tp2]]&gt;=h[j])&#123;</span><br><span class="line">                l[st2[tp2]]=j+<span class="number">1</span>,--tp2;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="keyword">while</span>(tp1&amp;&amp;h[st1[tp1]]&gt;h[j])&#123;</span><br><span class="line">                r[st1[tp1]]=j<span class="number">-1</span>,--tp1;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br></p>
<h5 id="HNOI2008水平可见直线"><a href="#HNOI2008水平可见直线" class="headerlink" title="HNOI2008水平可见直线"></a>HNOI2008水平可见直线</h5><p><a href="https://vijos.org/d/newbzoj/p/590c9879d3d8a13210993730">https://vijos.org/d/newbzoj/p/590c9879d3d8a13210993730</a><br>这题的本质就是半平面交.先按照斜率对全部直线排序,再依次塞入单调栈.被遮挡可以分为两种情况:1.k相同.那么b更大者一定更优;2.当前直线比栈顶直线位置更优,计算交点位置判断即可.<br><br><br></p>
<h5 id="luoguP2216"><a href="#luoguP2216" class="headerlink" title="luoguP2216"></a>luoguP2216</h5><p><a href="https://www.luogu.com.cn/problem/P2216">https://www.luogu.com.cn/problem/P2216</a></p>
<p>这题很显然是一个二维的滑动窗口.用n个单调队列维护每一行合法值,再将每一行最值塞进一个维护列的单调队列,每次移动后重置.每个点只会被扫描一次,复杂度$O(n^2)$<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">xq.<span class="built_in">reset</span>(),nq.<span class="built_in">reset</span>();</span><br><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,a) mxq[i].<span class="built_in">pb</span>(ar[i][rt],rt),mnq[i].<span class="built_in">pb</span>(ar[i][rt],rt);</span><br><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n<span class="number">-1</span>) xq.<span class="built_in">pb</span>(mxq[i].<span class="built_in">vl</span>(),i),nq.<span class="built_in">pb</span>(mnq[i].<span class="built_in">vl</span>(),i);</span><br><span class="line"><span class="built_in">For</span>(i,n,a)&#123;</span><br><span class="line">    xq.<span class="built_in">pb</span>(mxq[i].<span class="built_in">vl</span>(),i),nq.<span class="built_in">pb</span>(mnq[i].<span class="built_in">vl</span>(),i);</span><br><span class="line">    ans=<span class="built_in">min</span>(ans,xq.<span class="built_in">vl</span>()-nq.<span class="built_in">vl</span>());</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br><br></p>
]]></content>
  </entry>
  <entry>
    <title>数学归纳悖论</title>
    <url>/2022/09/28/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%82%96%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="数学归纳悖论"><a href="#数学归纳悖论" class="headerlink" title="数学归纳悖论"></a>数学归纳悖论</h1><span id="more"></span>
<p><br></p>
<h3 id="蓝眼睛问题"><a href="#蓝眼睛问题" class="headerlink" title="蓝眼睛问题"></a>蓝眼睛问题</h3><p>在一个岛上,有n个蓝眼睛的人,m个黄眼睛的人.一日一名游客前来游玩,聊天的时候说:你们中有人和我一样有蓝眼睛.知道自己有蓝眼睛的人会沮丧地紫砂.那么这个岛上的人多长时间后可以知道自己眼睛的颜色呢?</p>
<p>在有人做出回应前,所有人都只会沉思.随着大家又沉默了一个时刻,唯一可以得到的新信息就是大家又沉默了一个时刻.似乎无从下手,先从最简单的情况看看.</p>
<p>若n=1,则唯一的蓝眼睛拥有者会立刻知道自己拥有蓝眼睛,在$t=1$时刻直接紫砂</p>
<p>若n=2,两名蓝眼睛拥有者看到没人在第一时间紫砂,又能看到除自己外仅有以为蓝眼睛拥有者,于是可以肯定自己为蓝眼睛,在$t=2$时刻紫砂.</p>
<p>若n=3,对任意一名蓝眼睛的人来说,如果假设自己是黄眼睛,那么就能看到$t=2$时刻人群中剩下的两个蓝眼睛的人同时紫砂.而这个事件并没有发生,于是在$t=3$时刻推出自己也为蓝眼睛,三个人同时紫砂.</p>
<p>当n&gt;3,可以按照这个假设的方法,对人们沉默的轮数进行递归计算.假设自己是黄眼睛,那么所看见的n-1个蓝眼睛的人应该在n-1时刻同时紫砂.根据观察的事实相反,可以推出所有的蓝眼睛人在第n个时刻一起知道自己眼睛的颜色.</p>
<p>沉默的是本题唯一的可更新信息,比起传统的信息,不如说是一个面对所有人的广播,公开自己的推理结果.在一开始,当不止一个蓝眼睛人时,虽然每个人都知道有蓝眼睛人,但并不知道其他人知不知道有没有蓝眼睛,也不知道其他人知不知道自己知不知道有没有蓝眼睛,很像三体里的猜疑链.而游客的话打破了这个无限的猜疑链,让所有人的信息都同时对对方公开,此后的沉默都不只是单纯的个人推理结果,而是彼此可以再次利用的条件.</p>
<p>某大佬将这两个称为“强共识”和“弱共识”.在游客发言之前,“岛上有蓝眼人”是一个弱共识,或者说沉默共识,但不是一个强共识,或者说公开共识.在游客发言之后,“岛上有蓝眼人”被提升成了一个强共识,或者说公开共识.强共识包含了比弱共识更多的信息,所以当然可以导致更多的后果.<br><br></p>
<h3 id="三人猜数"><a href="#三人猜数" class="headerlink" title="三人猜数"></a>三人猜数</h3><p><a href="https://www.luogu.com.cn/problem/P5779">https://www.luogu.com.cn/problem/P5779</a><br>题意:三个人头上各有一个正整数,每个人只能看到其他两人头上的数,并且有一人头上的数是另两人头上数的和,三人一言不发猜数,最后第n轮时有一个人知道了自己头上的数m.求所有可能的数字组合.还有一个<del>似乎很好推出的</del>结论:数最大者最先猜到.</p>
<p>乍一看毫无思绪.<del>怎么看都不会做啊.</del>三个人之间傻看着,除了沉默,没有产生任何新的信息.就算有这个结论,也只能把确定有m-1个组合,如何验证每个组合的可行性呢?</p>
<p>从最简单的情况入手,假如第一个人看到其他两个人的数相等,由于自己的数不可能是0,就可以推出自己的数为其余二人数的和.即</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>)-&gt;n=<span class="number">1</span>,m=<span class="number">2</span>;</span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)-&gt;n=<span class="number">2</span>,m=<span class="number">2</span>;</span><br><span class="line">(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>)-&gt;n=<span class="number">3</span>,m=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>对于更复杂的情况,由于每个人的数只可能是$a+b,|a-b|$.可以考虑像蓝眼睛问题一样,先假设自己的数是$|a-b|$,如果被证伪,那么自己的数肯定是$a+b$.然后就可以把问题转移到前一个猜数的人,如果在自己为$|a-b|$的条件下,前面的人无法得出结果,那么这个猜测就不可行.于是可以递归处理.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(p==<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(v2==v3) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v2&gt;v3) <span class="keyword">return</span> <span class="built_in">dfs</span>(v2-v3,v2,v3,<span class="number">2</span>)+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">dfs</span>(v3-v2,v2,v3,<span class="number">3</span>)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(v1==v3) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(v1&gt;v3) <span class="keyword">return</span> <span class="built_in">dfs</span>(v1,v1-v3,v3,<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">dfs</span>(v1,v3-v1,v3,<span class="number">3</span>)+<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(v1==v2) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(v2&gt;v1) <span class="keyword">return</span> <span class="built_in">dfs</span>(v1,v2,v2-v1,<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">dfs</span>(v1,v2,v1-v2,<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而唯一可以用于判断的量化标准就是沉默的轮数.对于一组数,仅当有人猜出来的轮数与给定的n轮相同,才能成为可行解.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">1</span>)<span class="keyword">if</span>(<span class="built_in">dfs</span>(m,i,m-i,<span class="number">1</span>)==n)++T,ans[T].a=m,ans[T].b=i,ans[T].c=m-i;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">2</span>)<span class="keyword">if</span>(<span class="built_in">dfs</span>(i,m,m-i,<span class="number">2</span>)==n)++T,ans[T].a=i,ans[T].b=m,ans[T].c=m-i;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">3</span>)<span class="keyword">if</span>(<span class="built_in">dfs</span>(i,m-i,m,<span class="number">3</span>)==n)++T,ans[T].a=i,ans[T].b=m-i,ans[T].c=m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><br><del>信息真神奇啊</del></p>
]]></content>
  </entry>
  <entry>
    <title>最大流练习</title>
    <url>/2022/10/07/%E6%9C%80%E5%A4%A7%E6%B5%81/</url>
    <content><![CDATA[<h1 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h1><span id="more"></span>
<h2 id="飞行员配对问题"><a href="#飞行员配对问题" class="headerlink" title="飞行员配对问题"></a>飞行员配对问题</h2><p><a href="https://www.luogu.com.cn/problem/P2756">https://www.luogu.com.cn/problem/P2756</a><br>网络流24题里的入门一题.<br>两种人之内没有交集,整个图可以看作二分图,跑匈牙利算法<br>也可以根据每个外籍飞行员和英国飞行员之间配对关系连边,看作最大流<br>在图中额外加入源点和汇点,分别与两组点连边,最大流的结果就是所求匹配数<br>最后输出方案就直接扫描残量网络,若起于外国并终于英国的边被流过则说明这两个人配对<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">For</span>(p,<span class="number">1</span>,n1)&#123;</span><br><span class="line">        <span class="built_in">For</span>(i,<span class="number">0</span>,od[p]<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(e.f||e.t&lt;=n1) <span class="keyword">continue</span>;</span><br><span class="line">            cout&lt;&lt;p&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;e.t&lt;&lt;<span class="string">&quot;\n&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><br></p>
<h2 id="试题库问题"><a href="#试题库问题" class="headerlink" title="试题库问题"></a>试题库问题</h2><p><a href="https://www.luogu.com.cn/problem/P2763">https://www.luogu.com.cn/problem/P2763</a><br>每一题仍然只能选取一次,但每张卷子都要求多道题<br>将与源点连边的容量改为题数,判断最大流是否等于总题数<br>输出方案时同上题做法<br><br></p>
<h2 id="圆桌问题"><a href="#圆桌问题" class="headerlink" title="圆桌问题"></a>圆桌问题</h2><p><a href="https://www.luogu.com.cn/problem/P3254">https://www.luogu.com.cn/problem/P3254</a><br>试题库问题的升级版,每组点都有多种限流<br>将汇点连边的容量也改为要求就行了<br><br></p>
<h2 id="魔术球问题"><a href="#魔术球问题" class="headerlink" title="魔术球问题"></a>魔术球问题</h2><p><a href="https://www.luogu.com.cn/problem/P2765">https://www.luogu.com.cn/problem/P2765</a><br>题意:有n个柱子,每个柱子上可以放球,相邻的球必须满足编号和为完全平方数,最大化放球的数量</p>
<p>这一题并没有直接的给出建图的信息,需要从相邻编号和为平方的限制条件中得到球之间的合法转移关系,就可以依此建出隐式图.</p>
<p>匹配数+柱子个数=球个数,所以我们不断试图增加匹配,在残量网络上不断跑最大流,直到匹配的最大值,就可以使球的个数最多.如果加入一个点而无法使匹配增大,那么说明球的个数已经达到了最大值.</p>
<p>如果沿用之前直接基于每个球代表的编号点进行转移的思路,源点流出的流量可以经过中转点直接流向汇点,起不到寻找匹配的作用.这里就需要拆点,用两个点代表一个球,分别与源汇点相连,入点连向可以组成平方数的出点,每次最大流的结果就是匹配数.</p>
<p>最后记得每次保存增加点之前的边,如果到达上限就清空并还原残量网络,最后一次跑最大流就可以得到点之间的匹配关系<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    ++add;lim+=<span class="number">2</span>;<span class="type">int</span> totrec=tot;</span><br><span class="line">    <span class="built_in">ins</span>(S,lim<span class="number">-1</span>,<span class="number">1</span>),<span class="built_in">ins</span>(lim,T,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">For</span>(i,<span class="number">1</span>,n+add<span class="number">-1</span>)<span class="keyword">if</span>(<span class="built_in">check</span>(i,n+add)) <span class="built_in">ins</span>(<span class="number">2</span>+i*<span class="number">2</span><span class="number">-1</span>,lim,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dinic</span>();<span class="keyword">if</span>(add==mxf) <span class="keyword">continue</span>;</span><br><span class="line">    lim-=<span class="number">2</span>,tot=totrec;<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=tot;i+=<span class="number">2</span>)eg[i].f+=eg[i^<span class="number">1</span>].f,eg[i^<span class="number">1</span>].f=<span class="number">0</span>;</span><br><span class="line">mxf=<span class="number">0</span>,<span class="built_in">dinic</span>();</span><br></pre></td></tr></table></figure><br><br></p>
<h2 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h2><p><a href="https://atcoder.jp/contests/abc274/tasks/abc274_g">https://atcoder.jp/contests/abc274/tasks/abc274_g</a></p>
<p>题意:给出一张矩阵,某些点处有障碍.每个点可以放置一台摄像机,选取四个方向中任一方向,对障碍前所有方格进行监视.除了障碍,所有点均需被监视.求出最小所用摄像头数.</p>
<p>首先,可以很明显的看出,对于放置于某格某方向的摄像头,如果反向的格子为空,那么此摄像头放在反向一定不会使答案更劣.所以所有的摄像头都应该沿着障碍物放置(此处将矩阵的边缘视为障碍物).</p>
<p>对于一条边的覆盖,两个端点只要有一个有该方向的覆盖就足够.所以只会有方向向下或向右的摄像头(向左,向上同理).</p>
<p>现在题意被转化为,在一个联通块的上边缘和左边缘放置摄像头,使得达到全覆盖.似乎除了dp之外想不到其他的方法,但是状压dp的复杂度不对,插头dp更是没有必要.试着再次换一个角度,考虑每个点如果能达成覆盖需要满足的条件.当前仅当每个点能到达的最左点或最上点中至少其一放置摄像头,全图完成覆盖.现在题意是,有若干个二元组,每个二元组中至少一个数被选取,求最小选取数.</p>
<p>这张图其实是一张二分图,问题就变成求解二分图的最小覆盖.根据Dilworth定理,建图后跑最大流即可求出.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">iFor</span>(i,n,<span class="number">1</span>)<span class="built_in">iFor</span>(j,m,<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!mp[i][j])<span class="keyword">continue</span>;</span><br><span class="line">    dn[i][j]=rt[i][j]=p;</span><br><span class="line">    <span class="keyword">if</span>(mp[i+<span class="number">1</span>][j])dn[i][j]=dn[i+<span class="number">1</span>][j]; </span><br><span class="line">    <span class="keyword">if</span>(mp[i][j+<span class="number">1</span>])rt[i][j]=rt[i][j+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">con</span>(S,p,<span class="number">1</span>),<span class="built_in">con</span>(p+n*m,T,<span class="number">1</span>),<span class="built_in">con</span>(dn[i][j],rt[i][j]+n*m,INF); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
]]></content>
  </entry>
  <entry>
    <title>最小割练习</title>
    <url>/2022/10/21/%E6%9C%80%E5%B0%8F%E5%89%B2/</url>
    <content><![CDATA[<h1 id="最小割"><a href="#最小割" class="headerlink" title="最小割"></a>最小割</h1><span id="more"></span>
<p>有某位神仙说过,一切问题都是网络流.很多涉及到代价,贡献,依赖,互斥的问题都可以转化为最小割来处理.一般不会给出明显的图关系,很多时候需要根据图中信息建立隐式图.推荐两篇论文,hbt的《最小割模型在信息学竞赛中的应用》和pty的《浅析一类最小割问题》,透彻明晰的分析了几个最常用模型.</p>
<p><br></p>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>考虑最基本的只有一个非源汇节点的网络,最小割的结果就是源汇边容量的较小者.如果有两个非源汇节点链式相连,最小割的结果等于三条边容量的最小值.将中间的边容量设为无穷,则可表现两个点互斥,即必须二选一的限制.</p>
<p>如果中间的边容量有意义,那么他代表选取前者而放弃后者的代价.只有这条边流满,顶点才能分属不同点集.</p>
<p>对于依赖关系,可以考虑类似于否定否命题的思路构造.将任一非源汇点按出边入边拆为出点入点,可以代表选与不选,则两点互斥,依赖入点等价于与出点互斥.在某些情况下,入点和出点的区别并不会直接影响图的性质,就可以将两个点合并,此时目标点直接向依赖点连容量无限的边.也可以用代价的观点看成选后者而不选前者的代价无穷大,两者必须归属同一划分.</p>
<p>在原图解最小割的结果就是满足限制的最小代价.如果要求最大收益,一般预先将价值求和,再减去最小割.<br><br></p>
<h2 id="小M的作物"><a href="#小M的作物" class="headerlink" title="小M的作物"></a>小M的作物</h2><p><a href="https://www.luogu.com.cn/problem/P1361">https://www.luogu.com.cn/problem/P1361</a><br>题意:有n种作物,每一种可以种在A,B两个田里,分别收获$a_i,b_i$的价值.给出m种组合,若组合内所有作物都种在A,B内,额外获得$ea_i,eb_i$的价值.求出可以获得的最大价值.</p>
<p>首先不看额外附加的价值,直接贪心就是答案.贪心策略毫无疑问就是选取较大者,也可以转述为两者之和减去较小者.<del>很容易联想到</del>,最小割也可以用来求两者中的较小值.将权值作为容量,分别连向源汇,达到满流后,总流量就是二者中的较小者.最大价值可以预先存下所有价值的和,再减去最小割得到.</p>
<p>那么这个直接能无脑贪心的问题,为什么要去扯上最小割呢?最小割可以处理依赖关系下的求值,刚好能解决组合额外价值的计算.考虑将每种作物拆分为A,B两个点,分别代表选择田地A或B,再将组合建立虚拟点,可以发现图中的依赖关系,任一个组合能被选取仅当所有目标作物都选为对应的土地,即$ma_i$依赖于$a_j,(j \in {S_i})$全部被选取.</p>
<p><img src="E:\PD\pics\最小割1.png" style="zoom: 50%;" /></p>
<p>此处并不需要直接把代表作物的点拆出来,因为入点和出点之间的边容量为无穷,合并也不会影响结果.黑边的容量为无限.在最小割中,以代价或贡献的角度考虑,无限容量代表永远不割去此条边,即不选择依赖项直接选则目的项的代价无限大.这样就可以保证,要么不选此项,割掉其与源汇点的边,要么捆绑式选取所有依赖点.</p>
<p>求额外价值的方法和单个点一样,预先将价值加到总和中,最后减去最小割.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n)cin&gt;&gt;rec[i][<span class="number">0</span>],sum+=rec[i][<span class="number">0</span>];</span><br><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n)cin&gt;&gt;rec[i][<span class="number">1</span>],sum+=rec[i][<span class="number">1</span>];</span><br><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n)<span class="built_in">con</span>(S,i,rec[i][<span class="number">0</span>]),<span class="built_in">con</span>(i,T,rec[i][<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">    <span class="built_in">con</span>(S,p1,v1),<span class="built_in">con</span>(p2,T,v2),sum+=v1+v2;</span><br><span class="line">    <span class="built_in">For</span>(j,<span class="number">1</span>,k)&#123;ll p;cin&gt;&gt;p;<span class="built_in">con</span>(p1,p,INF),<span class="built_in">con</span>(p,p2,INF);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dinic</span>();</span><br><span class="line">cout&lt;&lt;sum-mxf;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="city-safety"><a href="#city-safety" class="headerlink" title="city safety"></a>city safety</h2><p><a href="https://codeforces.com/gym/103428/problem/H">https://codeforces.com/gym/103428/problem/H</a><br>题意：一棵树，加强第i 个点有$w_i$ 的花费，而如果距离某个点≤ d 的所有点都加强了，则会有$v_d$ 的收益，求最大净收益。<br>看起来像个树形dp,但是祖先的状态不好处理,转移方程写不出<del>太菜了</del>.于是考虑歪门邪道.</p>
<p>将贡献差分,将每个点处的贡献拆为n个点,建图,可以发现这是一个典型的依赖-代价图.于是考虑分别找出依赖关系和正负收益建图.<br>每个点都做一次dfs得到依赖关系,距离点p为d的贡献所对应的点依赖于距离点p为d-1的对应点,和原树中距离树节点p为d的所有树节点.对于所有依赖关系连上容量无限的单边.<br>源点向所有代表贡献的点连上容量为贡献差分的边,所有树节点向汇点连上容量为代价的边,就是最小割的经典模型.<br>预先对所有贡献求和,最后的结果就是总和减去最小割.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> d,<span class="type">int</span> f,<span class="type">int</span> S)</span></span>&#123;</span><br><span class="line">    <span class="built_in">con</span>(S+n*d,p,INF);</span><br><span class="line">    <span class="built_in">For</span>(i,<span class="number">0</span>,od2[p]<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ov2[p][i]^f)<span class="built_in">dfs2</span>(ov2[p][i],d+<span class="number">1</span>,p,S);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">For</span>(i,<span class="number">1</span>,n)&#123;ll v;cin&gt;&gt;v;<span class="built_in">con</span>(i,T,v);&#125;</span><br><span class="line">    ll pre=<span class="number">0</span>;</span><br><span class="line">    sum=n*bnf[n];</span><br><span class="line">    <span class="built_in">For</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">dfs2</span>(i,<span class="number">1</span>,<span class="number">0</span>,i);</span><br><span class="line">        <span class="built_in">For</span>(j,<span class="number">1</span>,n)&#123;<span class="built_in">con</span>(S,i+j*n,bnf[j]-bnf[j<span class="number">-1</span>]);<span class="keyword">if</span>(j&gt;<span class="number">1</span>)<span class="built_in">con</span>(i+j*n,i+j*n-	n,INF);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dinic</span>();</span><br><span class="line">    cout&lt;&lt;sum-mxf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="土地划分"><a href="#土地划分" class="headerlink" title="土地划分"></a>土地划分</h2><p><a href="https://www.luogu.com.cn/problem/P4210">https://www.luogu.com.cn/problem/P4210</a><br>题意:在一张无向联通图中,每个点归属点集1,点集n二者之一,分别获得$a_i,b_i$的收益.如果一条边两个顶点同属于点集1或点集n,则额外获得$Ea_i,Eb_i$的收益,若一条边两个顶点不属于同一点集,则会产生$Ec_i$的损失.求一种划分使得收益最大.</p>
<p>这个模型太眼熟了,可以用pty论文中的方法解决.<br>简单回顾一下模型,<del>知道的大佬可以直接跳过</del></p>
<h3 id="机械调度"><a href="#机械调度" class="headerlink" title="机械调度"></a>机械调度</h3><p>有n个任务,每个可以在机械A,B上完成,所选的方案记为二元组$(x,y)$.选择A或B会产生$A_i,B_i$的代价.对于每一组$(x,y)$,都会产生一组给定的代价,$v_1,v_2,v_3,v_4$.求一种方案使得总代价最小.</p>
<p>对于每个任务的代价,暂不考虑,可以最后再加到割边上去.现考虑二元组的影响,在原图上重新建边.</p>
<p><img src="E:\PD\texts\总结\浅析一类最小割问题(pty).png" style="zoom:150%;" /></p>
<p>边的容量必须满足以下限制</p>
<script type="math/tex; mode=display">
a+b=v1 \\
c+d=v2 \\
a+e+d=v3 \\
b+f+c=v4</script><p>其中可能出现类似$a+b+d$的方案,因为肯定不如$a+b$优,不用考虑.<br>在这个图中,点x,y具有类似于对称的性质,所以e,f可以直接取等,$e=f=(v3+v4-v1-v2)/2$.剩下的容量也可以直接怎么简单取,任何一种合法的选取最后并不影响答案的正确性.</p>
<script type="math/tex; mode=display">
a=(v1+v3)/2 \\
b=(v1-v3)/2 \\
c=(v2+v4)/2 \\
d=(v2-v4)/2 \\
e=f=(v3+v4-v1-v2)/2</script><p>然后以每个任务自身的代价连边,最后最小割就是答案.<br><br></p>
<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><p>回到本题,将所有的代价取负变为贡献,答案就是所有容量的和减去最小割.<br>与模型唯一的不同就是划分不同时的代价变成了贡献,那就预先把所有的贡献加和,再将容量的差加到相同划分的代价上,最后如果划分不同时结果会相抵消.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">For</span>(i,<span class="number">2</span>,n<span class="number">-1</span>)&#123;ll v;cin&gt;&gt;v;v*=<span class="number">2</span>,sum+=v,<span class="built_in">con</span>(S,i,v);&#125;</span><br><span class="line"><span class="built_in">For</span>(i,<span class="number">2</span>,n<span class="number">-1</span>)&#123;ll v;cin&gt;&gt;v;v*=<span class="number">2</span>,sum+=v,<span class="built_in">con</span>(i,T,v);&#125;</span><br><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">    <span class="type">int</span> p1,p2;ll v1,v2,v3;</span><br><span class="line">    cin&gt;&gt;p1&gt;&gt;p2&gt;&gt;v1&gt;&gt;v2&gt;&gt;v3;</span><br><span class="line">    sub+=v3,v1+=v3,v2+=v3;</span><br><span class="line">    v1*=<span class="number">2</span>,v2*=<span class="number">2</span>,sum+=v1+v2;</span><br><span class="line">    <span class="built_in">con</span>(S,p1,v1/<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">con</span>(S,p2,v1/<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">con</span>(p1,T,v2/<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">con</span>(p2,T,v2/<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">con</span>(p1,p2,(v1+v2)/<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">con</span>(p2,p1,(v1+v2)/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></p>
<h2 id="方格取数问题"><a href="#方格取数问题" class="headerlink" title="方格取数问题"></a>方格取数问题</h2><p><a href="https://www.luogu.com.cn/problem/P2774">https://www.luogu.com.cn/problem/P2774</a><br>题意:给定一个n*m的矩阵,要求取出若干个数,使总和最大,同时满足每个数在矩阵中的位置都不相邻</p>
<p>相邻不能同时取,这个条件给出了互斥性,暗示着可以根据矩阵中位置的奇偶性,将原图看作一张二分图,不相交的两侧分别代表奇偶点,代表两个点至少一条连向源汇的边被割掉,即至少弃掉一个点.原问题等价于二分图带权最大独立集.</p>
<p><img src="E:\PD\pics\p1.png" style="zoom:50%;" /></p>
<p>这个总和最大感觉不太好求,就转化问题,求一个取数组合使剩下的数均不相邻,且该组合最小.这种取法会将原二分图拆成两个不相连部分,与最大流的残量网络极其相像.最后的S,T集里的点就是目标取点.</p>
<p><img src="E:\PD\pics\p2.png" style="zoom:50%;" /></p>
<p><del>图中黑边为被删去的边,蓝边为可行边</del>此图有误,被删去的边可能流量在残量网络没有跑完,但经过调整后一定可以使每条边对应点的状态.<br><br></p>
<h2 id="圈地计划"><a href="#圈地计划" class="headerlink" title="圈地计划"></a>圈地计划</h2><p><a href="https://www.luogu.com.cn/problem/P1935">https://www.luogu.com.cn/problem/P1935</a><br>题意:一个nm矩阵,每个点位选择A或B,得到收益$a_{ij},b_{ij}$.若两个相邻的点选择不同,获得额外收益$C_{ij}+C_{kl}$.求所能获得的最大收益.</p>
<p>推荐先做这一题<a href="https://www.luogu.com.cn/problem/P1646,本题的简单版">https://www.luogu.com.cn/problem/P1646,本题的简单版</a>.</p>
<p>很显然,pty的模型可以直接套用,不过此处由于图的结构,需要做一些变换.此处用更好理解的虚拟点法,同时进行了和论文中变换本质相同的构造.</p>
<p>这是个有互斥属性的矩形问题,不妨想想方格取数中的解决方案,按奇偶来分类点.将所有的奇点反转,入点和出点交换,源汇边容量交换,就重新得到一张意义明确的类二分图.再按对相邻的依赖关系对虚拟店连边,就可以求出正确的最小割.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n)<span class="built_in">For</span>(j,<span class="number">1</span>,m)&#123;ll v;cin&gt;&gt;v;sum+=v;<span class="keyword">if</span>((i+j)&amp;<span class="number">1</span>)<span class="built_in">con</span>(S,p,v);<span class="keyword">else</span> <span class="built_in">con</span>(p,T,v);&#125;</span><br><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n)<span class="built_in">For</span>(j,<span class="number">1</span>,m)&#123;ll v;cin&gt;&gt;v;sum+=v;<span class="keyword">if</span>((i+j)&amp;<span class="number">1</span>)<span class="built_in">con</span>(p,T,v);<span class="keyword">else</span> <span class="built_in">con</span>(S,p,v);&#125;</span><br><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n)<span class="built_in">For</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">    ll v;cin&gt;&gt;v;</span><br><span class="line">    <span class="keyword">if</span>(i^<span class="number">1</span>)sum+=v,<span class="built_in">con</span>(S,eg,v),<span class="built_in">con</span>(eg,p,INF),<span class="built_in">con</span>(eg,x,INF);</span><br><span class="line">    <span class="keyword">if</span>(i^n)sum+=v,<span class="built_in">con</span>(S,eg,v),<span class="built_in">con</span>(eg,p,INF),<span class="built_in">con</span>(eg,x,INF);</span><br><span class="line">    <span class="keyword">if</span>(j^<span class="number">1</span>)sum+=v,<span class="built_in">con</span>(S,eg,v),<span class="built_in">con</span>(eg,p,INF),<span class="built_in">con</span>(eg,x,INF);</span><br><span class="line">    <span class="keyword">if</span>(j^m)sum+=v,<span class="built_in">con</span>(S,eg,v),<span class="built_in">con</span>(eg,p,INF),<span class="built_in">con</span>(eg,x,INF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="人员雇佣"><a href="#人员雇佣" class="headerlink" title="人员雇佣"></a>人员雇佣</h2><p><a href="https://www.luogu.com.cn/problem/P1791">https://www.luogu.com.cn/problem/P1791</a><br>题意:有n个员工,雇佣成本分别为$a_i$.若$i,j$两个员工同时雇佣,则获得收益$E_{i,j}$,如果其中一人被雇佣而另一人没有,则付出额外代价$E_{i,j}$.求最大收益.</p>
<p>用虚拟点的想法,拆点为选或不选,再将额外收益或惩罚连依赖边,最后再处理收益与惩罚的互斥性上遇到了麻烦,似乎并不好表示.</p>
<p>考虑边的意义.先将贡献加和转化问题为求最小代价,向源汇连收益和代价.点i向点j连容量为$2E_{i,j}$的边,表示两者不在同一集合的代价为$2E_{i,j}$,就搞定辣.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n)&#123;ll v;cin&gt;&gt;v;<span class="built_in">con</span>(i,T,v);&#125;</span><br><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n)<span class="built_in">For</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">    ll v;cin&gt;&gt;v;<span class="keyword">if</span>(i==j)<span class="keyword">continue</span>;</span><br><span class="line">    rec[j]+=v,sum+=v,<span class="built_in">con</span>(i,j,v*<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n)<span class="built_in">con</span>(S,i,rec[i]);</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>线段树练习</title>
    <url>/2022/09/23/%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="线段树练习"><a href="#线段树练习" class="headerlink" title="线段树练习"></a>线段树练习</h1><p>做了几题思维难度并不算太高的线段树题目,难点就是有巨巨巨多细节要注意.</p>
<span id="more"></span>
<h2 id="luoguP6327区间sin和"><a href="#luoguP6327区间sin和" class="headerlink" title="luoguP6327区间sin和"></a>luoguP6327区间sin和</h2><p><a href="https://www.luogu.com.cn/problem/P6327">https://www.luogu.com.cn/problem/P6327</a></p>
<p>题意:每次修改一个点,求区间sin值的和<br>区间sin和的信息不可加,但可以考虑和差化积公式,</p>
<script type="math/tex; mode=display">
sin(x+v)=sin(x)cos(v)+sin(v)cos(x)\\
cos(x+v)=cos(x)cos(v)-sin(x)sin(v)</script><p>同时记录cos和sin值就可以转化为线段树求和.<br>由于节点的tag不能直接和子节点的和相加,需要注意每次询问时先下放标签.还有浮点运算的常数极大,下放时先判一下0,不然很容易tle.<br><br></p>
<h2 id="luoguP1471方差"><a href="#luoguP1471方差" class="headerlink" title="luoguP1471方差"></a>luoguP1471方差</h2><p><a href="https://www.luogu.com.cn/problem/P1471">https://www.luogu.com.cn/problem/P1471</a></p>
<p>题意:每次修改一个点,求区间平均数和方差<br>首先是平均数的合并$a_3=(a_1n_1+a_2n_2)/(n_1+n_2)$<br>再考虑方差的更改,每次修改时可以$O(1)$的更新</p>
<script type="math/tex; mode=display">
D_1=\frac 1n\Sigma(x_i-a_1)^2\\
D_2=\frac 1n\Sigma(x_i+v-a_2)^2\\
D_2-D_1=\frac 1n\Sigma((x_i+v-a_2)^2-(x_i-a_1)^2)\\
       =\frac 1n\Sigma(v^2+a_2^2+2x_iv-2a_2v-2a_2x_i-a_1^2+2x_ia_1)\\
       =v^2+a_2^2-a_1^2-2a_2v+(2v-2a_2+2a_1)\frac 1n \Sigma x_i\\
       =v^2+a_2^2-a_1^2-2a_2v+2a_1v-2a_1a_2+2a_1^2\\
       =a_1^2+a_2^2+v^2+2a_1v-2a_2v-2a_1a_2</script><p>最后是方差的合并</p>
<script type="math/tex; mode=display">
D_1=\frac 1{n_1}\Sigma(x_1i-a_1)^2\\
D_2=\frac 1{n_2}\Sigma(x_2i-a_2)^2\\
D_3=\frac 1{n_1+n_2}\Sigma(x_i-a_3)^2\\
(n_1+n_2)D_3-D_1n_1-D_2n_2=\Sigma((x_i-a_3)^2-(x_i-a_j)^2)(j=1,2)\\
                          =\Sigma(a_3^2-a_j^2+2x_i(a_j-a_3))\\
                          =n_1(a_3^2-a_1^2)+2n_1a_1(a_1-a_3)\\
                          +n_2(a_3^2-a_2^2)+2n_2a_2(a_2-a_3)\\
                          =n_1a_1^2+n_2a_2^2-(n_1+n_2)a_3^2</script><p>最后特别要注意在合并方差时跨中点情况的判断,左右两段的长度应该取min(当前区间长度,询问区间长度)<br><br></p>
<h2 id="luoguP5142区间方差"><a href="#luoguP5142区间方差" class="headerlink" title="luoguP5142区间方差"></a>luoguP5142区间方差</h2><p><a href="https://www.luogu.com.cn/problem/P5142">https://www.luogu.com.cn/problem/P5142</a><br>基本与上题相同.longlong本身常数大,全局还带了一个$O(logn)$的求逆,无脑取模会t飞.本题需要先处理出inv数组,还要取模时判断优化,以免被卡常.<br><br></p>
<h2 id="What-a-Colorful-Wall"><a href="#What-a-Colorful-Wall" class="headerlink" title="What a Colorful Wall"></a>What a Colorful Wall</h2><p><a href="https://codeforces.com/gym/103443/problem/F">https://codeforces.com/gym/103443/problem/F</a></p>
<p>题意:n个有颜色的矩形按顺序放在平面上,被覆盖的部分颜色不可见,求最后可见的颜色数</p>
<p>矩形覆盖的问题很自然想到扫描线,先把矩形离散,按x坐标排序,并拆分为加入线段和删除线段两部分.线段树维护y轴,每个时刻先增删线段,每个节点挂一个可删堆维护当前区间内时间最大矩形的颜色,最后dfs全树,查询当前时刻能看到颜色种类.每次查询复杂度$O(nlogn)$,总共有n次询问,总复杂度$O(n^2logn)$,可以勉强卡过.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//黑科技可删堆</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HEAP</span>&#123;</span><br><span class="line">    priority_queue &lt;pii&gt; p,q;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(pii x)</span></span>&#123;p.<span class="built_in">push</span>(x);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(pii x)</span></span>&#123;q.<span class="built_in">push</span>(x);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mt</span><span class="params">()</span></span>&#123;<span class="keyword">while</span>(p.<span class="built_in">size</span>()&amp;&amp;q.<span class="built_in">size</span>()&amp;&amp;q.<span class="built_in">top</span>()==p.<span class="built_in">top</span>())p.<span class="built_in">pop</span>(),q.<span class="built_in">pop</span>();&#125;</span><br><span class="line">    <span class="function">pii <span class="title">top</span><span class="params">()</span></span>&#123;<span class="built_in">mt</span>();<span class="keyword">return</span> p.<span class="built_in">top</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;<span class="built_in">mt</span>();<span class="keyword">return</span> p.<span class="built_in">empty</span>();&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//此处和通常的线段树稍有不同,由于维护的实际上是矩形的边,表示颜色块需要边界-1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr) &#123;ar[p].<span class="built_in">add</span>(qii);<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;mid) <span class="built_in">add</span>(ls,l,mid);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;qr) <span class="built_in">add</span>(rs,mid,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr) &#123;ar[p].<span class="built_in">del</span>(qii);<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;mid) <span class="built_in">del</span>(ls,l,mid);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;qr) <span class="built_in">del</span>(rs,mid,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,pii pi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!ar[p].<span class="built_in">empty</span>()) pi=<span class="built_in">max</span>(pi,ar[p].<span class="built_in">top</span>());</span><br><span class="line">    <span class="keyword">if</span>(r-l==<span class="number">1</span>)&#123;ans[pi.second]=<span class="number">1</span>;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="built_in">dfs</span>(ls,l,mid,pi),<span class="built_in">dfs</span>(rs,mid,r,pi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    po=<span class="built_in">pii</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">For</span>(i,<span class="number">1</span>,ttx)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:vad[i]) qii=<span class="built_in">pii</span>(x.id,ocl[x.id]),ql=x.l,qr=x.r,<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>,tty);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:vde[i]) qii=<span class="built_in">pii</span>(x.id,ocl[x.id]),ql=x.l,qr=x.r,<span class="built_in">del</span>(<span class="number">1</span>,<span class="number">1</span>,tty);</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>,tty,po);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;<span class="built_in">For</span>(i,<span class="number">1</span>,n)cnt+=ans[i];</span><br><span class="line">    cout&lt;&lt;cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>一个更好的做法就是在每个时刻维护每种颜色可见的总长度,直接在增删线段时更新,不需要再dfs,复杂度$O(nlogn)$.</p>
<p>需要注意的是,如果直接用二维线段树或外层暴力内层线段树,虽然理论复杂度是$O(n^2logn)$的,但是常数巨大,无法通过(存疑).</p>
]]></content>
  </entry>
  <entry>
    <title>区间dp</title>
    <url>/2023/01/15/%E5%8C%BA%E9%97%B4dp/</url>
    <content><![CDATA[<h1 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h1><span id="more"></span>
<p><br></p>
<h2 id="Work-or-Rest"><a href="#Work-or-Rest" class="headerlink" title="Work or Rest"></a>Work or Rest</h2><p>题目链接:<a href="https://atcoder.jp/contests/abc285/tasks/abc285_e">https://atcoder.jp/contests/abc285/tasks/abc285_e</a></p>
<p>题意:在一个周期内任意安排假期,至少一天,使一个周期内总效率最大.每天的效率计算方法给定.</p>
<p>思路:对于任意一段长度为l的连续工作区间,总效率都相等,而且可以通过长度为l-1的效率得到,于是先将每个长度对应的效率预处理出来.</p>
<p>一看数据范围,确定是$n^2$或者$n^2logn$的算法.于是很自然的考虑区间dp.长度为l的区间可以由长度为i与l-i的区间拼出,且不会有后效性问题.由于循环不涉及顺序,那么直接顺推dp,复杂度$O(n^2)$.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        ans[i]=rec[i<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">For</span>(j,<span class="number">1</span>,i<span class="number">-1</span>)ans[i]=<span class="built_in">max</span>(ans[i],ans[i-j]+rec[j<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans[n];</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="Pre-Order"><a href="#Pre-Order" class="headerlink" title="Pre-Order"></a>Pre-Order</h2><p><a href="https://atcoder.jp/contests/abc252/tasks/abc252_g">https://atcoder.jp/contests/abc252/tasks/abc252_g</a></p>
]]></content>
  </entry>
</search>
