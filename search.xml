<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ABC324F</title>
    <url>/abc324F/</url>
    <content><![CDATA[<p>分数规划，拓扑排序</p>
<span id="more"></span>
<h2 id="Beautiful-Path"><a href="#Beautiful-Path" class="headerlink" title="Beautiful Path"></a>Beautiful Path</h2><p>题目链接:<a href="https://atcoder.jp/contests/abc324/tasks/abc324_f">https://atcoder.jp/contests/abc324/tasks/abc324_f</a></p>
<p>题意:给定一个有向无环简单图，每条边有两个属性,$cost,value$。要求选若干条边，组成一条点1到点n的路径，使得$\frac{\Sigma value_i}{\Sigma cost_i} $最大化。题目保证存在至少一条点1到点n的路径。其中$n,m \in[1,2e5]$<br>$cost,value\in[1,2e3]$</p>
<p>分析:题目要求式子的形式很明显提示了分数规划的思路。选取一个答案，并且判断答案是否可行，二分缩小规模得到最终答案。</p>
<p>图中找一条路径的要求可以转化为取边时存在之前状态的依赖，但更简单的想法是将图中的边重新赋权，由于DAG的特性，直接拓扑排序遍历全图，最后判断终点处权值是否非负。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>练习</category>
      </categories>
      <tags>
        <tag>分数规划</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>2022.9.18icpc网赛摸鱼记</title>
    <url>/2022.9.18icpc/</url>
    <content><![CDATA[<h4 id="2022-9-18icpc网赛"><a href="#2022-9-18icpc网赛" class="headerlink" title="2022.9.18icpc网赛"></a>2022.9.18icpc网赛</h4><p><a href="https://pintia.cn/problem-sets/1571150153619189760">https://pintia.cn/problem-sets/1571150153619189760</a></p>
<span id="more"></span>
<p>第一次参加正式的icpc比赛,尽管最近一直在打abc练手,但感觉还是力不从心.一是对icpc没有部分分的模式还不太熟悉,二是和队友的配合不够默契,三是码力下降不少,有两个本来可过的题寄了.幸亏队友还给力,一起口胡最后A掉4题.</p>
<p><br></p>
<h5 id="L"><a href="#L" class="headerlink" title="L"></a>L</h5><p>开的第一个题,第一眼就是sam之类的字符串转移,直接跑了.后来和老哥一起分析时又口胡建图,猜了一手结论:每个点只用向最近的同一字母转移.<br>建图的思路没错,但是连边的可行条件分析没分析到位,直接判是否在t串中相邻,实际上应该把t串中前后全部字母组合ban掉.于是痛挂一题.<br><br></p>
<h5 id="H"><a href="#H" class="headerlink" title="H"></a>H</h5><p>倒序开题没有思路,跟榜去做签到题.直接用栈模拟操作,1发A.<br><br></p>
<h5 id="A"><a href="#A" class="headerlink" title="A"></a>A</h5><p>乍一看毫无头绪,不过数学大佬点明了关键性质,一块连续的1只有$(len+1)/2$个”有效1”.每一个”有效1”能消掉3个元素,若一个串中”有效1”不足$1/3$,z则需要操作补1.区间染色,前缀和求和,复杂度$O(q)$.第一发T了,加了个快读就直接过了<br><br></p>
<h5 id="C"><a href="#C" class="headerlink" title="C"></a>C</h5><p>考场上队友切掉的.答案就是叶子节点个数.<br>这个做法的正确性:对于所有的叶子节点,只能采用delete.考虑整棵树对每个节点只留下一个叶子,其余的全部删掉,然后shrink所有的单链,不断重复这个过程,可以发现所有的非叶子节点都可以被shrink.可以得到需要delete的只有叶节点<br><br></p>
<h5 id="D"><a href="#D" class="headerlink" title="D"></a>D</h5><p>在考试时看假了题,以为是01个数相等,还差点误导了队友,最后s大佬切了.<br>考完再看这题才发觉是水题,直接dfs预处理,二分答案即可.<br><br></p>
<h5 id="K"><a href="#K" class="headerlink" title="K"></a>K</h5><p>由于太菜只会$n^3$dp,于是想到了记搜剪枝.但是剪枝的条件并没有思考完备,白白的写了半个小时的假题,不仅没想出怎么优化,最后甚至正确性都没有.似乎有神仙乱剪过了,后面再找std看看吧<br><br></p>
<h5 id="G"><a href="#G" class="headerlink" title="G"></a>G</h5><p>同样,由于太菜,只能想到裸暴力dp.一直在纠结$n^5$的复杂度,却忽视了选取多个连续时实际状态并不算多,写完心虚不敢久调,又浪费时间写了假题.<br><br><br>这场满打满算可以切掉7题,尽管第一次正式赛失误无可避免,但只搞掉4题还是有遗憾.根据最近打的3场比赛,目前最主要的目的并不是复习一些高级算法的用法,毕竟几乎用不到,而是多做一些dp,搜索之类的需要处理边界条件的题目,很久没做题带来的生疏大概就体现在细节不会写了吧.</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>游记</category>
      </categories>
      <tags>
        <tag>水文</tag>
      </tags>
  </entry>
  <entry>
    <title>icpc2022济南游寄</title>
    <url>/icpc2022%E6%B5%8E%E5%8D%97%E6%B8%B8%E5%AF%84/</url>
    <content><![CDATA[<p>第一次正式参加区域赛，不得不水一篇小作文了。</p>
<span id="more"></span>
<p>早上本来想睡个难得的好觉，突然起来发现有正式赛，于是飞速嗦了一碗粉，一路小跑润到机房。到了一看才十点，人都没来几个，就享受受刑前的快乐睡眠。<br>之前测环境已经测好了，预计不会出什么问题，但队长的vs自动补全没办法完全关掉，焦虑了一小会儿，决定用dev为主。</p>
<p>开场拿到题目，m题感觉可做，应该是个贪心，不过还是继续往前看看再说。<br>k题签到题一眼秒，写出来几乎没怎么调，8分钟a掉，还算不错。<br>签完k队友开始输出，我就去开题了。花了大量时间在金牌题上，感觉最短路倍增可写，就开始小推式子，中间花了十几分钟写了假题，最后意识到做法是n4的，结束表演转而跟榜。</p>
<p>大概这个时候z老师正在折磨s老师调e吧，看了acd，感觉没有一眼题。小猜了一个a的结论，目标区间一定连续，先除二后加减。<br>和z老师达成了共识，他继续折磨s老师写题，我就去玩c了。</p>
<p>一开始没什么思路，想着换根。上了两个厕所后，发现儿子的状态可以直接继承父亲，子树内顺序无限制，处理兄弟的状态就可以了。<br>于是大力推了一波式子，感觉很对。虽然看似n4，主定理分析后觉得可以n3。跟队友说了，都觉得行，于是飞速码题。<br>码完还有二十分钟，交一发t了，发现会被菊花卡掉。<br>z老师给出了一个优化，size相同的兄弟等价。乍一想很对，于是加上，wa，到结束都没调出来。后来发现size相同的兄弟子树可能不同，应该除掉自身子树的方案再乘上兄弟子树的方案才对。</p>
<p>跟大家一起去吃晚饭，见识到什么叫活不过一圈的菜。<br>最后尾银，滚榜滚到时整个人才放松下来。c没做出来有点遗憾，不过就算做出来了也不一定有au。<br>希望南京能冲一把au。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>游记</category>
      </categories>
      <tags>
        <tag>水文</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC289F</title>
    <url>/abc289F/</url>
    <content><![CDATA[<p>对称</p>
<span id="more"></span>
<h2 id="Teleporter-Takahashi"><a href="#Teleporter-Takahashi" class="headerlink" title="Teleporter Takahashi"></a>Teleporter Takahashi</h2><p>题目链接:<a href="https://atcoder.jp/contests/abc289/tasks/abc289_f">https://atcoder.jp/contests/abc289/tasks/abc289_f</a></p>
<p>题意:给出一个平面上的矩形,从给定的起点开始,每次在矩形内选一个整点,并将起点变为此整点的对称点,询问是否能在有限的操作后到达给定的终点,如果可行给出方案.其中所有的数都满足在$(1,1e6)$内.</p>
<p>分析:面对这种整体不好下手的问题可以先考虑简化的情形.在一维的情况下,从起点经过若干次一条线段上整点的对称到达终点.</p>
<p>还是没有思路,先手玩一波.将x按照A对称,得到2A-x.如果再以A为对称中点转回去,显然没有什么作用.试试做一些小的改动,分别以A-1,A+1为对称中点,可以得到x-2,x+2.那么可以得出,如果线段至少含有两个整点,就一定可以将x变为x+2n $(n\in R)$.</p>
<p>那么,如果起点和终点在线段同侧时的差为d,满足d是2的倍数,一定可以经过若干次这样的对称,其实就是d/2次,让起点和终点重合.如果d是奇数,那么一定无法达到目的.如果线段只含有一个整点,那么起点和终点要么一开始就重合,要么以此整点对称,否则一定不行.</p>
<p>在一维进行对称移动时,另一维每次取同样的对称中心,位置就不会改变,所以每一维可以独立处理.最后把每一维的处理结果叠加起来就是答案序列.</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>练习</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>abc262</title>
    <url>/abc262/</url>
    <content><![CDATA[<h1 id="abc262"><a href="#abc262" class="headerlink" title="abc262"></a>abc262</h1><p><a href="https://atcoder.jp/contests/abc262">https://atcoder.jp/contests/abc262</a></p>
<span id="more"></span>
<p>D:首先看数据范围,很明显是个$n^3$或$n^4$的题.首先枚举当前要用的数k,考虑到k的同余系下答案相等,先对序列取模,再更新背包.枚举k需要$O(n)$,序列中有n个数,每次更新背包需要$O(n^2)$,总复杂度$O(n^4)$.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">For</span>(id,<span class="number">1</span>,n)&#123;</span><br><span class="line">        ri v=ar[id]%M;</span><br><span class="line">        <span class="comment">//dp[i][j] 选用i个数,拼成剩余系下的j </span></span><br><span class="line">        <span class="built_in">iFor</span>(i,n,<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">For</span>(j,<span class="number">0</span>,M<span class="number">-1</span>)&#123;</span><br><span class="line">            dp[i][j]=(dp[i][j]+dp[i<span class="number">-1</span>][(j-v+M)%M])%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=(ans+dp[M][<span class="number">0</span>])%MOD; <span class="comment">//最后答案为用M个数拼成0</span></span><br></pre></td></tr></table></figure>
<p>E:考虑所有标记过点的出度总和S,与标记过点相连的同色的边数R,不同色的边数D,满足$S=D+2R$,即若D为偶数,则S必为偶数.于是原问题可转化为从原图中选出若干点,使其出度总和为偶数,求方案数.此时点的出度可直接分为奇偶,组合数求和即可<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(ri i=<span class="number">0</span>;i*<span class="number">2</span>&lt;=k;++i) ans=(ans+<span class="built_in">C</span>(c[<span class="number">0</span>],k-i*<span class="number">2</span>)*<span class="built_in">C</span>(c[<span class="number">1</span>],i*<span class="number">2</span>)%MOD)%MOD;</span><br></pre></td></tr></table></figure></p>
<p>F:根据字典序,找出k能到达的范围内最小值lead.如果选择转动操作,需要转动的点仅在lead后方.这样仅用分两种情况讨论,直接删和转后再删.对于直接删的情况,维护一个单调栈,每次更新时执行删除操作.<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For(i,1,n)&#123;</span><br><span class="line">        while(p&amp;&amp;ar[i]&lt;ar[sta1[p]]&amp;&amp;r)--r,--p;</span><br><span class="line">        ++p,sta1[p]=i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>如果旋转,旋转后的点删除不需要花费<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(p&amp;&amp;ar[i]&lt;ar[sta2[p]]&amp;&amp;(r&gt;=(sta2[p]&lt;ld)))r-=(sta2[p]&lt;ld),--p;</span><br><span class="line">        ++p,sta2[p]=i;</span><br></pre></td></tr></table></figure><br>最后比较两个答案的大小即可</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>练习</category>
      </categories>
      <tags>
        <tag>动归</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC296F</title>
    <url>/abc296F/</url>
    <content><![CDATA[<p>逆序,奇偶性分析</p>
<span id="more"></span>
<h2 id="Simultaneous-Swap"><a href="#Simultaneous-Swap" class="headerlink" title="Simultaneous Swap"></a>Simultaneous Swap</h2><p>题目链接:<a href="https://atcoder.jp/contests/abc296/tasks/abc296_f">https://atcoder.jp/contests/abc296/tasks/abc296_f</a></p>
<p>题意:给定两个长度都为n的序列$A,B$.你可以进行以下操作任意次,选取一组$i,j,k$,满足$i,j,k\in(1,n),i\neq j,k$,并交换$A_i,A_j$与$B_i,B_k$.请问是否可以最后将$A,B$序列变为相等.序列长度$n\in(1,2e5)$</p>
<p>分析:常规的构造想不出来,<del>太菜了</del>.但是这并不是一道构造题.</p>
<p>首先分析两个序列中的元素个数是否相同,如果不同那肯定不行.</p>
<p>如果$A,B$两个序列最后可以转化为相等,那么一定可以将他们同时转化为升序序列.反之也是同样,如果两个序列能被同时转化为升序,那么他们一定满足要求.</p>
<p>从升序的角度来观察一次交换的结果,如果交换的两个数相等,那么和不操作也没有什么区别.如果两数不同,一定会改变当前序列逆序对数,本质上是改变了序列逆序的奇偶性.</p>
<p>如果两个序列的逆序奇偶性相同,那么一定可以将他们的逆序数变得相等,再将逆序数一起归0,最后就得到了相等的上升序列.如果两个序列的逆序奇偶性不同,那么可以感性理解一下,两个序列一定无法全等.</p>
<p>还有一个额外的情况,如果任一序列中存在相等的元素,那么就可以在这个序列奇偶性不变的情况下改变另一个的奇偶性,保证能得到逆序数奇偶相同的序列,一定有解.</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>练习</category>
      </categories>
      <tags>
        <tag>逆序</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC035B</title>
    <url>/agc035B/</url>
    <content><![CDATA[<p>无向图中边的定向</p>
<span id="more"></span>
<h2 id="even-degrees"><a href="#even-degrees" class="headerlink" title="even degrees"></a>even degrees</h2><p>题目链接:<a href="https://atcoder.jp/contests/agc035/tasks/agc035_b">https://atcoder.jp/contests/agc035/tasks/agc035_b</a></p>
<p>题意:给出一张无向简单连通图,判断以下命题是否存在并给出一种方案,使得每个点的出度均为偶数.其中$n,m\in(1,1e5)$</p>
<p>分析:直接给无向边定向看起来不好下手,先从简单的情况考虑</p>
<p>对于一条链,每个点的度数为1或2,那么让两端点的出度为0,中间的任意,就可以得到答案.</p>
<p>扩展到树上.叶子结点的度数一定为1,那么所有的叶边一定由父亲出发指向叶子.考虑处理两个树上度数为奇的非叶结点,手玩容易发现,将树链反转,仅影响两端点度数的奇偶性,对其他的没有影响.如果有偶数个出度为奇的结点,一定可以通过若干次反转使整棵树满足条件;反之,如果只有奇数个出度为奇的结点,那么一定没有合法方案.</p>
<p>再看一张连通图上,可以先跑出一颗生成树.对于非树边任意定向,不会影响答案,奇数点的奇偶性不会改变.然后再按树的思路反转父边,最后一定满足要求.</p>
<p>综合一下可以推出,如果边数为奇,一定无解;反之亦然.</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>练习</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>CF104270I</title>
    <url>/cf104270I/</url>
    <content><![CDATA[<p>尺取+线段树</p>
<span id="more"></span>
<h2 id="Soldier-Game"><a href="#Soldier-Game" class="headerlink" title="Soldier Game"></a>Soldier Game</h2><p>题目链接:<a href="https://codeforces.com/gym/104270/problem/I">https://codeforces.com/gym/104270/problem/I</a></p>
<p>题意:给定一个序列$a_n$,要求将序列划为若干组,每组由一个或相邻的两个元素组成,组的权值就是组内元素的权值之和,每个元素在且仅在一组内,要求一种分组方式,使得组之间的极差最小.$n\in(1,1e5)$</p>
<p>分析:序列最值首先考虑二分,然而知道了极差并不能直接得到一组合法的构造方式,必须明确上下界.如果用二分套二分来得到上下界,其实也不能很好的告诉你如何划分序列,比如在一个数归属左右都可以,但是会影响后面的取值的情况里,单纯从一个方向构造不一定有合法解.</p>
<p>传统的最值转化判定的思路行不通,只能另辟蹊径.考虑分组操作的实质,就是用一些小线段对整个区间进行覆盖,如果这些线段能恰好完全覆盖整个区间,那么就可以构成一组合法解.</p>
<p>思路似乎已经明确,将原序列分为长度为1,2的子段,排序后从小到大枚举权值最小的线段,并向后合并直到原区间被完全覆盖,最后比较每次的权值极差就得到答案.</p>
<p>不过可能出现一种情况,线段$ [ a_{i-1},a_i] , [a_i,a_{i+1} ] $,同时存在,但$a_{i-1},a_i,a_{i+1}$没有其他的覆盖.如果每次只存覆盖次数,就无法处理这样的情况.</p>
<p>考虑重新设计状态,$sum[p][0/1][0/1]$表示所辖区间的左右端点分别在长度为$1/2$的线段内是否全覆盖.那么可以得到线段树式的转移<br><br><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sum[p][i][j]=(sum[ls][i][<span class="number">0</span>]&amp;sum[rs][<span class="number">0</span>][j])|(sum[ls][i][<span class="number">1</span>]&amp;sum[rs][<span class="number">1</span>][j]);</span><br></pre></td></tr></table></figure><br><br><br>$sum[1][0][0]$就表示整个序列是否被完整覆盖.</p>
<p>维护一个单调指针,对于每个确定的最小值线段,找到最小的上界线段满足全覆盖,记录极差,算完后再将当前的最小值线段删掉.单调指针和下界都是会访问连续的n个值,线段树每次修改$logn$,总复杂度$O(nlogn)$,可以通过本题.</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>练习</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC150B</title>
    <url>/arc150B/</url>
    <content><![CDATA[<p>数论分块</p>
<span id="more"></span>
<h2 id="Make-Divisible"><a href="#Make-Divisible" class="headerlink" title="Make Divisible"></a>Make Divisible</h2><p>题目链接:<a href="https://atcoder.jp/contests/arc150/tasks/arc150_b">https://atcoder.jp/contests/arc150/tasks/arc150_b</a></p>
<p>题意:给出A,B求出X,Y,满足$(A+X)|(B+Y)$,且最小化$X+Y$,其中$A,B \in (1,1e9)$</p>
<p>分析:设比值$k=(B+Y)/(A+X)$,则有</p>
<script type="math/tex; mode=display">
Y=kX+kA-B,Y>=0 \\
ans=X+Y=(k+1)X+kA-B</script><p>则可以得到X的限制</p>
<script type="math/tex; mode=display">
X>=B/k-A</script><p>一个更好的形式</p>
<script type="math/tex; mode=display">
x>=\lfloor(B-1)/k\rfloor-A+1</script><p>这样,我们可以枚举k来计算答案.</p>
<p>由数论分块可知,最多有$\sqrt B$个有效的k.于是不断地跳k,就可以在复杂度为根号的时间内解决问题.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll k=<span class="number">1</span>,ans=A+B;</span><br><span class="line"><span class="keyword">while</span>(k&lt;B)&#123;</span><br><span class="line">    ll x=<span class="built_in">max</span>(<span class="number">0ll</span>,(B<span class="number">-1</span>)/k-A+<span class="number">1</span>);</span><br><span class="line">    ans=<span class="built_in">min</span>(ans,(k+<span class="number">1</span>)*x+k*A-B);</span><br><span class="line">    ll r=(B<span class="number">-1</span>)/((B<span class="number">-1</span>)/k);</span><br><span class="line">    k=r+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>练习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论分块</tag>
      </tags>
  </entry>
  <entry>
    <title>sloppy city planning</title>
    <url>/sloppy_city_planning/</url>
    <content><![CDATA[<p>缩点+最短路</p>
<span id="more"></span>
<h2 id="sloppy-city-planning"><a href="#sloppy-city-planning" class="headerlink" title="sloppy city planning"></a>sloppy city planning</h2><p>题目链接:<a href="http://8.130.108.71/problem/H">http://8.130.108.71/problem/H</a></p>
<p>题意:在一张有向完全图上，现在可以付出给定的代价让一条边反向，求使整张图成为一个scc的最小代价</p>
<p>分析:首先考虑图中已有的环。很容易看出对于一个环边，没有必要进行任何更改，保持初始的强连通关系一定是最优解。可以放心的缩点辣。</p>
<p>缩点后得到的新图看似凌乱，但是可以发现一个性质——入度为0和出度为0的点都只有一个。这个图如果要成为一个scc，入度为0的点和出度为0的点一定在同一个scc内 <del>(废话)</del>。</p>
<p>把这两个看作起点和终点，也就一定有一条在这两个点之间的链，满足所有的边全部反向，由终点指向起点。通过起点和终点之间的联通关系，图中所有的点都可以借助这条直径互相到达。</p>
<p>反转这一条链上边的代价就是所求的答案，于是可以用最短路解决了。</p>
<p>需要注意本题较为卡常，似乎对spfa做了特殊的hack。另外有点卡空间，vector会因为各种各样的问题去世。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>练习</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>缩点</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>一道思维题:矩阵快速幂(bushi</title>
    <url>/%E4%BC%AA%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<p>检测智商</p>
<span id="more"></span>
<p>校赛中的一道神仙题,难点不在算法或者特别的技巧,专杀惯性思维</p>
<h2 id="luoguT319422-穷哥们也想发财"><a href="#luoguT319422-穷哥们也想发财" class="headerlink" title="luoguT319422 穷哥们也想发财"></a>luoguT319422 穷哥们也想发财</h2><p><a href="https://www.luogu.com.cn/problem/T319422">https://www.luogu.com.cn/problem/T319422</a></p>
<p>题意:已知列向量A,矩阵P,变量K,其中矩阵P满足对于j,有 $\sum^n a_{i,j}=1,a_i\in(0,1) .$. 求出 $ B=(P^T)^k*A $. ,其中$P^T$代表P的转置矩阵</p>
<p>数据范围: $ n\in (1,7e2),K\in(1,1e10) $</p>
<p>乍一看就是矩阵快速幂的模板,几乎不能更简单.</p>
<p>然而略加分析<del>或者tle了一发</del>可以发现,一般的矩乘快速幂,复杂度$O(n^3logK)$,在本题的数据大概能达到1e9级别,甚至做一次矩乘,都要大概3e8次运算,在double乘法的大常数下,只乘一次都会超时.</p>
<p>回看题目,发现有一个条件没有用到, $ \sum^n a_{i,j}=1,a_i\in(0,1) .$. 这个条件可以满足在自乘若干次后,矩阵P的内容趋于稳定,性质的证明涉及马尔科夫链.</p>
<p>于是就采用最原始的办法去做,不断的用P左乘A,比较A是否达到不动点.这个次数似乎与P的分布有关,不过应该不会太大,可以通过本题.</p>
<p>另外出题人特意提醒了用double,long double反而会有精度问题</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>练习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>区间dp</title>
    <url>/%E5%8C%BA%E9%97%B4dp/</url>
    <content><![CDATA[<h1 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h1><span id="more"></span>
<p><br></p>
<h2 id="Work-or-Rest"><a href="#Work-or-Rest" class="headerlink" title="Work or Rest"></a>Work or Rest</h2><p>题目链接:<a href="https://atcoder.jp/contests/abc285/tasks/abc285_e">https://atcoder.jp/contests/abc285/tasks/abc285_e</a></p>
<p>题意:在一个周期内任意安排假期,至少一天,使一个周期内总效率最大.每天的效率计算方法给定.</p>
<p>思路:对于任意一段长度为l的连续工作区间,总效率都相等,而且可以通过长度为l-1的效率得到,于是先将每个长度对应的效率预处理出来.</p>
<p>一看数据范围,确定是$n^2$或者$n^2logn$的算法.于是很自然的考虑区间dp.长度为l的区间可以由长度为i与l-i的区间拼出,且不会有后效性问题.由于循环不涉及顺序,那么直接顺推dp,复杂度$O(n^2)$.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        ans[i]=rec[i<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">For</span>(j,<span class="number">1</span>,i<span class="number">-1</span>)ans[i]=<span class="built_in">max</span>(ans[i],ans[i-j]+rec[j<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans[n];</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="Pre-Order"><a href="#Pre-Order" class="headerlink" title="Pre-Order"></a>Pre-Order</h2><p><a href="https://atcoder.jp/contests/abc252/tasks/abc252_g">https://atcoder.jp/contests/abc252/tasks/abc252_g</a></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动归</tag>
      </tags>
  </entry>
  <entry>
    <title>KDtree</title>
    <url>/kdtree/</url>
    <content><![CDATA[<h1 id="KDtree"><a href="#KDtree" class="headerlink" title="KDtree"></a>KDtree</h1><p><br></p>
<span id="more"></span>
<p>KDtree(K-Dimension tree)适用于处理与距离和位置有关的多维点对问题,本质上就是经过剪枝的暴力,难点在于估价函数的设计</p>
<p><br></p>
<h2 id="k远点对"><a href="#k远点对" class="headerlink" title="k远点对"></a>k远点对</h2><p>题目链接:<a href="https://www.luogu.com.cn/problem/P4357">https://www.luogu.com.cn/problem/P4357</a></p>
<p>题意:给出n个二维点,求出第K远点对的距离.其中$n\in(1,1e6),K\in(1,1e2)$</p>
<p>分析:按照最直接的思路,求出每一对点之间的距离再排序,时间复杂度会达到$O(n^2)$.</p>
<p>在这个暴力的过程中,很多点对都不会产生贡献,考虑合并处理区间优化.对点集排序,对于当前选择的两个点$a_l,a_r$,如果$x_l,x_r$与$y_l,y_r$的距离和小于当前答案,那么在$x_l,x_r$之间且$y_l,y_r$之间的点对一定对答案没有影响.</p>
<p>考虑用矩形来分割整个平面,再用点对递归分割子平面.每次选取一个维度上的中点,对当前子平面进行再划分,这样就构造出一颗二叉树.由于每个维度的区间中点不同,每次用nth_element得到,避免反复sort.KDtree的构造时间复杂度是$O(nlogn)$,与一般二分数据结构相同.</p>
<p>至于划分的维度,可以选用方差最大的维度,这样数据分布的比较开,可以保证树高,树的形态会更平衡.为了省事也可以按维度顺序轮流选择.</p>
<p>树上的每个结点维护一个矩形区间,表示子树在平面上的范围.</p>
<p>查询时,用当前点来更新答案.预测左右子树与询问点的最大距离,如果最大情况下对答案都没有贡献,就没有必要进入子树了.利用预测值还有一个优化,根据左右子树预测值的大小关系,决定子树的访问顺序.</p>
<p>单次询问的平均复杂度为$O(n^{(1-\frac{1}{k})})$,具体分析可以看这篇博客:<a href="https://blog.csdn.net/qq_50332374/article/details/123242226">https://blog.csdn.net/qq_50332374/article/details/123242226</a>. 需要注意的是,kdtree的单次查询最坏复杂度仍然是$O(n)$的,可能被刻意构造的数据卡死.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//估价函数</span></span><br><span class="line"><span class="function">ll <span class="title">edis</span><span class="params">(node &amp;p,PNT &amp;pn)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">For</span>(i,<span class="number">0</span>,<span class="number">1</span>)&#123;</span><br><span class="line">        ll t=<span class="built_in">max</span>(<span class="built_in">abs</span>(p.mx[i]-pn.x[i]),<span class="built_in">abs</span>(p.mn[i]-pn.x[i]));</span><br><span class="line">        res+=t*t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qry</span><span class="params">(node &amp;p,PNT &amp;pn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p.sz)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(K||<span class="built_in">dis</span>(p.pn,pn)&gt;=ans)<span class="built_in">add</span>(p.pn,pn);</span><br><span class="line">    ll dl=<span class="number">0</span>,dr=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(p.ls)dl=<span class="built_in">edis</span>(ar[p.ls],pn);</span><br><span class="line">    <span class="keyword">if</span>(p.rs)dr=<span class="built_in">edis</span>(ar[p.rs],pn);</span><br><span class="line">    <span class="keyword">if</span>(dl&gt;=dr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(K||dl&gt;=ans) <span class="built_in">qry</span>(ar[p.ls],pn);</span><br><span class="line">        <span class="keyword">if</span>(K||dr&gt;=ans) <span class="built_in">qry</span>(ar[p.rs],pn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(K||dr&gt;=ans) <span class="built_in">qry</span>(ar[p.rs],pn);</span><br><span class="line">        <span class="keyword">if</span>(K||dl&gt;=ans) <span class="built_in">qry</span>(ar[p.ls],pn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></p>
<h2 id="JZPFAR"><a href="#JZPFAR" class="headerlink" title="JZPFAR"></a>JZPFAR</h2><p>题目链接:<a href="https://www.luogu.com.cn/problem/P2093">https://www.luogu.com.cn/problem/P2093</a></p>
<p>题意:给出一个二维点集,m次查询,每次询问到指定的点距离第K大的点的标号</p>
<p>分析:和上题处理方法相同.不过这题比较卡常,可以设置全局变量避免反复传参,把维度的循环展开成判断.<del>最后还是没卡成,一发O2才过.</del></p>
<p><br></p>
<h2 id="SDOI2010-捉迷藏"><a href="#SDOI2010-捉迷藏" class="headerlink" title="[SDOI2010]捉迷藏"></a>[SDOI2010]捉迷藏</h2><p>题目链接:<a href="https://www.luogu.com.cn/problem/P2479">https://www.luogu.com.cn/problem/P2479</a></p>
<p>题意:给出一个二维点集,求出点集中的任意一点到其他点的最大和最小的距离之差的最小值</p>
<p>分析:需要注意最大值和最小值的估价函数的写法.最大估价考虑到较远的矩形边界的距离,而最小估价考虑到矩形内部的距离.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">emax</span><span class="params">(node &amp;p,PNT &amp;pn)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">For</span>(i,<span class="number">0</span>,<span class="number">1</span>)res+=<span class="built_in">max</span>(<span class="built_in">abs</span>(p.mx[i]-pn.x[i]),<span class="built_in">abs</span>(p.mn[i]-pn.x[i]));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">emin</span><span class="params">(node &amp;p,PNT &amp;pn)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">For</span>(i,<span class="number">0</span>,<span class="number">1</span>)&#123;</span><br><span class="line">        ll t1=<span class="built_in">max</span>(<span class="number">0ll</span>,pn.x[i]-p.mx[i]);</span><br><span class="line">        ll t2=<span class="built_in">max</span>(<span class="number">0ll</span>,p.mn[i]-pn.x[i]);</span><br><span class="line">        res+=t1+t2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="Mokia-简单题"><a href="#Mokia-简单题" class="headerlink" title="Mokia  简单题"></a>Mokia  简单题</h2><p>题目链接:<a href="https://www.luogu.com.cn/problem/P4390">https://www.luogu.com.cn/problem/P4390</a><br>        <a href="https://www.luogu.com.cn/problem/P4148">https://www.luogu.com.cn/problem/P4148</a></p>
<p>题意:在一个$n*n$矩阵中,单点修改,矩形范围查值.操作总数不超过$4e5$</p>
<p>分析:这次要求动态加点,如果直接把新点找个叶子挂上,可能会出现树结构的不平衡,要考虑用平衡树的方法维护kdtree.</p>
<p>由于kdree的每一层严格对应一个维度的划分,treap类随机乱选和splay改变父子关系肯定不行,只能考虑替罪羊树的局部重构.</p>
<p>精确查询的操作无法用估价函数剪枝,考虑用矩形覆盖的观点合并计算.</p>
<p>如果当前矩形被目标矩形全包,那么直接返回整个矩形的和.如果两者不相交,所有的子矩形也一定不产生共享,直接返回.</p>
<p>友情提醒一下两个矩形不相交只要满足任意一维不相交 <del>(我太菜了卡了好久)</del>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//被完全覆盖</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">icl</span><span class="params">(<span class="type">const</span> node &amp;p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">    X1&lt;=p.mn[<span class="number">0</span>]&amp;&amp;p.mx[<span class="number">0</span>]&lt;=X2&amp;&amp;</span><br><span class="line">    Y1&lt;=p.mn[<span class="number">1</span>]&amp;&amp;p.mx[<span class="number">1</span>]&lt;=Y2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有交集</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">out</span><span class="params">(<span class="type">const</span> node &amp;p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">    (X1&gt;p.mx[<span class="number">0</span>]||p.mn[<span class="number">0</span>]&gt;X2)||</span><br><span class="line">    (Y1&gt;p.mx[<span class="number">1</span>]||p.mn[<span class="number">1</span>]&gt;Y2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结点的二维点属于查询矩形</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">init</span><span class="params">(<span class="type">const</span> node &amp;p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">    p.pn.x[<span class="number">0</span>]&gt;=X1&amp;&amp;</span><br><span class="line">    p.pn.x[<span class="number">0</span>]&lt;=X2&amp;&amp;</span><br><span class="line">    p.pn.x[<span class="number">1</span>]&gt;=Y1&amp;&amp;</span><br><span class="line">    p.pn.x[<span class="number">1</span>]&lt;=Y2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qry</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">icl</span>(ar[p]))&#123;ans+=ar[p].sum;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">out</span>(ar[p]))&#123;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">init</span>(ar[p]))ans+=ar[p].pn.v;</span><br><span class="line">    <span class="built_in">qry</span>(ar[p].ls),<span class="built_in">qry</span>(ar[p].rs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>fhqtreap</title>
    <url>/fhqtreap/</url>
    <content><![CDATA[<h1 id="fhqtreap"><a href="#fhqtreap" class="headerlink" title="fhqtreap"></a>fhqtreap</h1><p>这个神仙级nb的数据结构得名于神仙范皓强,既有treap的易写易懂,也有splay般易于区间处理的能力.<br><span id="more"></span><br><br></p>
<h2 id="列队"><a href="#列队" class="headerlink" title="列队"></a>列队</h2><p><a href="https://www.luogu.com.cn/problem/P3960">https://www.luogu.com.cn/problem/P3960</a><br>题意:一个nm的矩阵,每次取出一个指定位置的数,求出这个数的编号,并把矩阵里的数先向左补齐再想上补齐,最后把取出的数塞到右下角.其中$n,m,q\in(1,3e5)$<br>考虑每次更改的部分,只有当前的行和最后一列会有更改.于是对每一行和最后一列建立平衡树维护矩阵.但是这样做的空间复杂度是$O(nm)$,无法承受.<br>由于大部分数都不会被更改,每个点都去维护的话实际上浪费了大量空间.那么就考虑去合并这些不会被更改的点,更好的做法就是直接维护区间,有分裂的需求时再动态开点.一开始对每行插入$(1,m-1)$的区间,对末尾列直接插入每一个数.在split时开新点分割区间.<br>此处的treap按排名分裂.需要注意fhqtreap的合并顺序,以及新开的点与原树的相对位置.这个细节废了我一个下午.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mer</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x+y;</span><br><span class="line">    <span class="keyword">if</span>(rd[x]&gt;=rd[y])<span class="keyword">return</span> <span class="built_in">rs</span>(x)=<span class="built_in">mer</span>(<span class="built_in">rs</span>(x),y),<span class="built_in">upd</span>(x),x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">ls</span>(y)=<span class="built_in">mer</span>(x,<span class="built_in">ls</span>(y)),<span class="built_in">upd</span>(y),y; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splp</span><span class="params">(<span class="type">int</span> p,ll k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;=<span class="built_in">len</span>(p)) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> x=<span class="built_in">alc</span>(L[p]+k,R[p]);</span><br><span class="line">    R[p]=L[x]<span class="number">-1</span>,<span class="built_in">rs</span>(p)=<span class="built_in">mer</span>(x,<span class="built_in">rs</span>(p)),<span class="built_in">upd</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spl</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y,ll v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> x=y=<span class="number">0</span>,<span class="built_in">void</span>();</span><br><span class="line">    <span class="keyword">if</span>(sz[<span class="built_in">ls</span>(p)]&gt;=v) y=p,<span class="built_in">spl</span>(<span class="built_in">ls</span>(p),x,<span class="built_in">ls</span>(p),v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">splp</span>(p,v-sz[<span class="built_in">ls</span>(p)]),x=p,<span class="built_in">spl</span>(<span class="built_in">rs</span>(p),<span class="built_in">rs</span>(p),y,v-sz[<span class="built_in">ls</span>(p)]-<span class="built_in">len</span>(p));</span><br><span class="line">    <span class="built_in">upd</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>圆方树</title>
    <url>/%E5%9C%86%E6%96%B9%E6%A0%91/</url>
    <content><![CDATA[<p>圆方树</p>
<p><br></p>
<span id="more"></span>
<h1 id="圆方树"><a href="#圆方树" class="headerlink" title="圆方树"></a>圆方树</h1><p>在仙人掌，无向点双连通分量图中，每条边至多只属于一个环。将原来的点视作圆点，环视作方点，重新建图，可以得到一颗圆点和方点交替的树。圆方树可以方便的处理涉及简单路径和仙人掌结构的问题。</p>
<p>广义圆方树没有对点双连通分量的限制，可以在任何图中构造。但他与一般圆方树最明显的差别就是把所有的割边视作一个环(误。一般来说，两者差别不大，为了简便，通常用广义圆方树就可以了。</p>
<p><br></p>
<h2 id="APIO2018-铁人两项"><a href="#APIO2018-铁人两项" class="headerlink" title="[APIO2018] 铁人两项"></a>[APIO2018] 铁人两项</h2><p>题目链接:<a href="https://www.luogu.com.cn/problem/P4630">https://www.luogu.com.cn/problem/P4630</a></p>
<p>题意:给一张无重边自环的图，要求选取不同的起点s,终点t,任意不同点c,满足s到c和c到t有不相交路径。求所有合法s,t,c的方案总数。其中$n \leq 1e5,m \leq 2e5$。</p>
<p>分析:分析题意可知，s,c,t一定在同一条链上，那么对于一条端点为s,t的链，链上所有点都是满足条件的c点。找到所有链覆盖的点，就得到了s,t确定时c的数量。</p>
<p>现在的问题转化为求固定端点的链覆盖，这个也并不好解决，需要引入圆方树的一个性质。</p>
<p>这里直接应用粉兔大佬博客 <a href="https://www.cnblogs.com/PinkRabbit/p/10446473.html">https://www.cnblogs.com/PinkRabbit/p/10446473.html</a> 中的原话，推导就不放了:<br><em>对于一个点双中的两点，它们之间简单路径的并集，恰好完全等于这个点双。即同一个点双中的两不同点 u,v 之间一定存在一条简单路径经过给定的在同一个点双内的一点 w。考虑两圆点在圆方树上的路径，与路径上经过的方点相邻的圆点的集合，就等于原图中两点简单路径上的点集。</em></p>
<p>s,t经过所有链上的点，等价于圆方树里s,t路径经过的所有圆点与方点相邻的圆点。这个结论虽然是从仙人掌图里推出来的，<del>不过看来这里也很好用</del>。</p>
<p>对s,t，c进行计数，就是对圆方树上s,t的路径做统计。方点无法直接和圆点并列处理，考虑用点权进行预处理。方点的权值就是所有相邻的圆点数，圆点权值设为0，这样c的数量就是路径中方点的权值和减去s,t两端了。</p>
<p>这样就转化为一个很经典的树形dp,可以换根，也可以直接做。每个点，每条边都遍历一次，复杂度为$O(m)$级别，轻松通过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建立圆方树，基于tarjan算法的改进</span></span><br><span class="line"><span class="comment">//最后需要--top，弹出根节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    dfn[p]=low[p]=++tim,stk[++top]=p;</span><br><span class="line">    ++cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:ov[p])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dfn[x])low[p]=<span class="built_in">min</span>(low[p],dfn[x]);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">dfs1</span>(x);</span><br><span class="line">            low[p]=<span class="built_in">min</span>(low[p],low[x]);</span><br><span class="line">            <span class="keyword">if</span>(low[x]==dfn[p])&#123;</span><br><span class="line">                ++n2;</span><br><span class="line">                <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(t^x)t=stk[top--],ov2[t].<span class="built_in">pb</span>(n2),ov2[n2].<span class="built_in">pb</span>(t);</span><br><span class="line">                <span class="comment">///此处不应用p做判断</span></span><br><span class="line">                ov2[n2].<span class="built_in">pb</span>(p),ov2[p].<span class="built_in">pb</span>(n2);</span><br><span class="line">                val[n2]=ov2[n2].<span class="built_in">size</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进行树dp,注意s,t有标号，答案要乘2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    siz[p]=(p&lt;=n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:ov2[p])&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==f)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(x,p);</span><br><span class="line">        ans+=val[p]*siz[p]*siz[x]*<span class="number">2</span>;</span><br><span class="line">        siz[p]+=siz[x];</span><br><span class="line">    &#125;</span><br><span class="line">    ans+=val[p]*siz[p]*(cnt-siz[p])*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="ABC318g-Typical-Path-Problem"><a href="#ABC318g-Typical-Path-Problem" class="headerlink" title="ABC318g Typical Path Problem"></a>ABC318g Typical Path Problem</h2><p>题目链接:<a href="https://atcoder.jp/contests/abc318/tasks/abc318_g">https://atcoder.jp/contests/abc318/tasks/abc318_g</a></p>
<p>题意:给一张简单无向连通图，给定s,c,t三个点，判断是否有起点s,终点t,经过点c的简单路径。其中$n,m \leq 2e5$。</p>
<p>分析:利用上一题的推导结果，可以将问题转化为，判断圆方树上s到t的链上是否有一个方点与c相邻。</p>
<p>这个可以用很多做法来解决了，注意到树中圆点和方点交替，可以用类似于普通树上点在路径的距离判断法来简单解决。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="comment">//dfs求点间距离</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:ov2[p])<span class="keyword">if</span>(!dis[x])dis[x]=dis[p]+<span class="number">1</span>,<span class="built_in">dfs2</span>(x); </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> q1,q2,q3;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">ffor</span>(i,<span class="number">1</span>,n2)dis[i]=<span class="number">0</span>;</span><br><span class="line">    dis[q1]=<span class="number">1</span>,<span class="built_in">dfs2</span>(q1);</span><br><span class="line">    <span class="type">int</span> d=dis[q3];</span><br><span class="line">    <span class="built_in">ffor</span>(i,<span class="number">1</span>,n2)dis[i]=<span class="number">0</span>;</span><br><span class="line">    dis[q2]=<span class="number">1</span>,<span class="built_in">dfs2</span>(q2);</span><br><span class="line">    <span class="comment">//手玩几种情况，可以发现如果s,t之间的距离+3&gt;=c到s,t的距离和，则合法</span></span><br><span class="line">    <span class="keyword">if</span>(d+<span class="number">3</span>&gt;=dis[q1]+dis[q3])cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>;<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="静态仙人掌最短路"><a href="#静态仙人掌最短路" class="headerlink" title="静态仙人掌最短路"></a>静态仙人掌最短路</h2><p>题目链接:<a href="https://www.luogu.com.cn/problem/P5236">https://www.luogu.com.cn/problem/P5236</a></p>
<p>题意:给一张仙人掌图，即任意一条边至多只出现在一条简单回路的无向连通图。给出若干询问，每次给出一组点对，求出点对的最短距离。其中$n,q\leq1e4,m\leq2e4,w_i\leq1e5$。</p>
<p>分析:如果不管环，那么仙人掌就是一颗树 <del>（废话</del>。一个树形图之前求最短路是很容易的，求LCA并减去距离前缀就可以了。</p>
<p>把仙人掌根据圆方树的构造建图，考虑在树上处理点对间距离。圆点之间可以直接求，圆点和方点的交边就比较麻烦了，需要保证圆点a-方点-圆点b的距离和等于圆点ab之间的距离。</p>
<p>通过为树选根定向的策略可以进行简化，对于树链圆点f-方点p-圆点s，设定f-p的边权为0，p-s的边权为f到s在原图中的距离，这样沿树链上行的时候就可以直接统计了。</p>
<p>如果在查询时出现了LCA为方点的情况，即圆点s1-方点p-圆点s2这样的树链，就需要快速处理出同一个BCC中点间距离。这个情况在一次查询中最多只出现一次。</p>
<p>总结一下，对于一个询问，先求点对的LCA<br>1.LCA是圆点，说明沿着树链的方向可以在原图中得到最短路，按照一般树上距离的方法来做。<br>2.LCA是方点，说明两侧分别沿树链上跳，最后在与LCA方点代表的环上的祖先处取到最短路。先上跳至与LCA相邻的祖先，再求出环上两点的距离。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;pil&gt;ov[N],ov2[N];</span><br><span class="line"><span class="type">int</span> dfn[N],low[N],tim;</span><br><span class="line"><span class="type">int</span> n,n2,m;</span><br><span class="line"><span class="type">int</span> stk[N],top;</span><br><span class="line"><span class="type">int</span> lop[N];</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,ll&gt;mp[N],sqmp[N];</span><br><span class="line">ll sqsum[N];</span><br><span class="line"><span class="comment">//根据BCC添加方点，并预处理环上两点距离</span></span><br><span class="line"><span class="comment">//这里出于偷懒就用了map</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_loop</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    ++n2;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>,len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(t^x)t=stk[top--],lop[++len]=t;</span><br><span class="line">    lop[++len]=p;	ov2[p].<span class="built_in">pb</span>(n2,<span class="number">0</span>);</span><br><span class="line">    ll sum=mp[lop[<span class="number">1</span>]][lop[len]],pre=sum;</span><br><span class="line">    <span class="built_in">ffor</span>(i,<span class="number">1</span>,len<span class="number">-1</span>)sum+=mp[lop[i]][lop[i+<span class="number">1</span>]];</span><br><span class="line">    sqsum[n2]=sum;</span><br><span class="line">    <span class="built_in">ffor</span>(i,<span class="number">1</span>,len<span class="number">-1</span>)&#123;</span><br><span class="line">        ll d=<span class="built_in">min</span>(pre,sum-pre);</span><br><span class="line">        sqmp[n2][lop[i]]=pre;</span><br><span class="line">        pre+=mp[lop[i]][lop[i+<span class="number">1</span>]];</span><br><span class="line">        ov2[n2].<span class="built_in">pb</span>(lop[i],d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据预处理，求出环sq上两点最短距离</span></span><br><span class="line"><span class="function">ll <span class="title">loop_dis</span><span class="params">(<span class="type">int</span> sq,<span class="type">int</span> p1,<span class="type">int</span> p2)</span></span>&#123;</span><br><span class="line">    ll d1=sqmp[sq][p1],d2=sqmp[sq][p2];</span><br><span class="line">    ll d=<span class="built_in">abs</span>(d1-d2);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(d,sqsum[sq]-d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建圆方树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    dfn[p]=low[p]=++tim,stk[++top]=p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e:ov[p])&#123;<span class="type">int</span> x=e.first;</span><br><span class="line">        <span class="keyword">if</span>(dfn[x])low[p]=<span class="built_in">min</span>(low[p],dfn[x]);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">dfs1</span>(x);</span><br><span class="line">            low[p]=<span class="built_in">min</span>(low[p],low[x]);</span><br><span class="line">            <span class="keyword">if</span>(low[x]==dfn[p])<span class="built_in">create_loop</span>(p,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> vis[N];</span><br><span class="line">ll dis[N];</span><br><span class="line"><span class="type">int</span> anc[N][M+<span class="number">1</span>],dep[N];</span><br><span class="line"><span class="comment">//倍增LCA预处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    vis[p]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">ffor</span>(i,<span class="number">1</span>,M)anc[p][i]=anc[anc[p][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e:ov2[p])&#123;<span class="type">int</span> x=e.first;</span><br><span class="line">        <span class="keyword">if</span>(vis[x])<span class="keyword">continue</span>;</span><br><span class="line">        dis[x]=dis[p]+e.second;</span><br><span class="line">        anc[x][<span class="number">0</span>]=p,dep[x]=dep[p]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> p1,<span class="type">int</span> p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[p2]&gt;dep[p1])<span class="built_in">swap</span>(p1,p2);</span><br><span class="line">    <span class="built_in">rfor</span>(i,M,<span class="number">0</span>)<span class="keyword">if</span>(dep[anc[p1][i]]&gt;=dep[p2])p1=anc[p1][i];</span><br><span class="line">    <span class="keyword">if</span>(p1==p2)<span class="keyword">return</span> p1;</span><br><span class="line">    <span class="built_in">rfor</span>(i,M,<span class="number">0</span>)<span class="keyword">if</span>(anc[p1][i]^anc[p2][i])p1=anc[p1][i],p2=anc[p2][i];</span><br><span class="line">    <span class="keyword">return</span> anc[p1][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//跳到与LCA相邻的祖先</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">JMP</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l)</span></span>&#123;</span><br><span class="line">    <span class="built_in">rfor</span>(i,M,<span class="number">0</span>)<span class="keyword">if</span>(dep[anc[p][i]]&gt;dep[l])p=anc[p][i];</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n2=n;</span><br><span class="line">    <span class="built_in">ffor</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dfn[i])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(i),top=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ffor</span>(i,<span class="number">1</span>,n)<span class="keyword">if</span>(!vis[i])<span class="built_in">dfs2</span>(i),anc[i][<span class="number">0</span>]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">ffor</span>(i,<span class="number">1</span>,q)&#123;</span><br><span class="line">        <span class="type">int</span> p1,p2;cin&gt;&gt;p1&gt;&gt;p2;</span><br><span class="line">        <span class="type">int</span> l=<span class="built_in">LCA</span>(p1,p2);ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//LCA为圆点，同树的处理</span></span><br><span class="line">        <span class="keyword">if</span>(l&lt;=n)ans=dis[p1]+dis[p2]-dis[l]*<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//LCA为方点，答案为到祖先的距离和+祖先间的最短路</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> f1=<span class="built_in">JMP</span>(p1,l),f2=<span class="built_in">JMP</span>(p2,l);</span><br><span class="line">            ans=dis[p1]-dis[f1]+dis[p2]-dis[f2]+<span class="built_in">loop_dis</span>(l,f1,f2);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>缩点</tag>
        <tag>圆方树</tag>
        <tag>连通性</tag>
      </tags>
  </entry>
  <entry>
    <title>区间中的不动点</title>
    <url>/%E5%8C%BA%E9%97%B4%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%8A%A8%E7%82%B9/</url>
    <content><![CDATA[<h1 id="区间中的不动点"><a href="#区间中的不动点" class="headerlink" title="区间中的不动点"></a>区间中的不动点</h1><p><br></p>
<span id="more"></span>
<p><br></p>
<h2 id="花神游历各国"><a href="#花神游历各国" class="headerlink" title="花神游历各国"></a>花神游历各国</h2><p>题目链接:<a href="https://www.luogu.com.cn/problem/P4145">https://www.luogu.com.cn/problem/P4145</a></p>
<p>题意:给定一个序列,每次操作将一段指定的区间中每一个数开方后取整,或者求一段区间的和.数据范围$n,m \leq 1e5 \quad a_i\leq1e12$.</p>
<p>解析:很明显不能直接暴力,应该考虑区间数据结构来维护.而开方不能合并计算,打tag延迟计算的方式并不适用.</p>
<p>观察开方运算,发现即使最大的数,$1e12$,在6次开方计算后也会变成1,且值为1的数在开方运算中不再改变.其实本质上就是这个开方后取整运算构成的群都会回归到1这个不动点.如果一段连续的区间都为1,那么这个区间在后续的操作中都不再改变.</p>
<p>可以利用这个性质,维护区间是否全部都是不动点,如果已经都是了就不用再下放修改了.每个点最多修改6次,最后总复杂度仍然是$O(mlogn)$.</p>
<p><br></p>
<h2 id="The-Child-and-Sequence"><a href="#The-Child-and-Sequence" class="headerlink" title="The Child and Sequence"></a>The Child and Sequence</h2><p>题目链接:<a href="https://codeforces.com/problemset/problem/438/D">https://codeforces.com/problemset/problem/438/D</a></p>
<p>题意:给定一个序列,每次操作将一段指定的区间对给定的模数取模,或者求一段区间的和.数据范围$n,m \leq 1e5 \quad a_i\leq1e9$.</p>
<p>解析:很明显,取模运算也没有区间可并性,只能从运算本身的特点入手.</p>
<p>一个数在取模后,得到的结果一定小于他的二分之一.证明涉及数论.不过可以感性理解一下,如果模数小于二分之一,得到的结果一定小于模数；如果模数大于二分之一,那么结果等于原数减模数,仍然小于二分之一.</p>
<p>每次以二分之一的程度减少,有效操作的次数就是$logx$.对于这个$a_i\leq1e9$的范围足够了.</p>
<p>那么我们可以维护区间最大值,如果模数大于最大值,没有必要操作,直接return,否则下放计算后重新统计最大值.总复杂度$O(mlognloga_i)$</p>
<p><br></p>
<h2 id="鸡格线"><a href="#鸡格线" class="headerlink" title="鸡格线"></a>鸡格线</h2><p>题目链接:<a href="https://ac.nowcoder.com/acm/contest/46800/G">https://ac.nowcoder.com/acm/contest/46800/G</a></p>
<p>题意:给定一个序列,每次操作将一段指定的区间中的每个数做$f(x)=round(10\sqrt x)$的变换k次,其中round为四舍五入函数,或者所有数的和.数据范围$n,m \leq 1e5 \quad a_i\leq1e9$.</p>
<p>解析:这个及格线算法看起来就是一个升级版的开方,不过还有一些不同之处.</p>
<p>普通的开方运算中,不动点只有0和1.而这个运算中看似只有0和100,但是<del>打表</del>可以发现,99也是不动点.$f(99)=round(10\sqrt 99) \simeq round(99.4987)=99$.大于100的数会回归100,而小于99的数会回归99.线段树的tag维护子区间的叶子结点是否满足任意一个不动点.</p>
<p>对于$a_i\leq1e9$的范围,最多10次就可以回归到100的不动点,总复杂度$O(mlogn)$.不过需要注意最好直接在叶子结点做k次运算,不然二分下放次数过多可能会被卡常.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mdf</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sg[p]) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        sum-=ar[l];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;++i)&#123;</span><br><span class="line">            ar[l]=<span class="built_in">round</span>(<span class="number">10.0</span>*<span class="built_in">sqrt</span>(ar[l]*<span class="number">1.0</span>));</span><br><span class="line">            <span class="keyword">if</span>(ar[l]==<span class="number">100</span>||ar[l]==<span class="number">0</span>||ar[l]==<span class="number">99</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ar[l]==<span class="number">100</span>||ar[l]==<span class="number">0</span>||ar[l]==<span class="number">99</span>)sg[p]=<span class="number">1</span>;</span><br><span class="line">        sum+=ar[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=mid) <span class="built_in">mdf</span>(ls,l,mid,ql,qr);</span><br><span class="line">    <span class="keyword">if</span>(qr&gt;mid) <span class="built_in">mdf</span>(rs,mid+<span class="number">1</span>,r,ql,qr);</span><br><span class="line">    sg[p]=(sg[ls]&amp;sg[rs]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>单调数据结构小结</title>
    <url>/%E5%8D%95%E8%B0%83/</url>
    <content><![CDATA[<p>复建的第一步!虽然仅仅水了一些单调栈和单调队列的题</p>
<span id="more"></span>
<h5 id="abc262-F"><a href="#abc262-F" class="headerlink" title="abc262 F"></a>abc262 F</h5><p><a href="https://atcoder.jp/contests/abc262/tasks/abc262_f">https://atcoder.jp/contests/abc262/tasks/abc262_f</a><br>根据字典序,找出k能到达的范围内最小值lead.如果选择转动操作,需要转动的点仅在lead后方.这样仅用分两种情况讨论,直接删和转后再删.对于直接删的情况,维护一个单调栈,每次更新时执行删除操作.<br><!-- more --></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;ar[i]&lt;ar[sta1[p]]&amp;&amp;r)--r,--p;</span><br><span class="line">        ++p,sta1[p]=i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果旋转,旋转后的点删除不需要花费<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(p&amp;&amp;ar[i]&lt;ar[sta2[p]]&amp;&amp;(r&gt;=(sta2[p]&lt;ld)))</span><br><span class="line">    r-=(sta2[p]&lt;ld),--p;</span><br><span class="line">++p,sta2[p]=i;</span><br></pre></td></tr></table></figure><br>最后比较两个答案的大小即可<br><br><br></p>
<h5 id="某大佬原创题"><a href="#某大佬原创题" class="headerlink" title="某大佬原创题"></a>某大佬原创题</h5><p>长度为n的数组 q个询问 每次询问给出一个长度L，最大化长度为L的连续子序列的最小值,$n,q\leq5e6,a_i\leq1e9$<br><br><br>对于每个点,可以记录成为min值的区间左右端点并更新答案,同时短区间的答案可由长区间继承.<br>关于这个做法的正确性,就是考虑是否每个点都对每个区间的答案进行过更新.对于长度大于$len=r-l+1$的区间,即使更新也不会使答案更优,没有必要考虑.对于长度短于$len$的区间,直接从比较过后的长区间继承,可以保证所有短区间都被更新到.<br>这样答案满足完全覆盖,不存在漏解的情况</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n) ans[r[i]-l[i]+<span class="number">1</span>]=<span class="built_in">max</span>(ans[r[i]-l[i]+<span class="number">1</span>],h[i]);</span><br><span class="line"><span class="built_in">iFor</span>(i,n<span class="number">-1</span>,<span class="number">1</span>) ans[i]=<span class="built_in">max</span>(ans[i],ans[i+<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<p><br><br></p>
<h5 id="luoguP1250"><a href="#luoguP1250" class="headerlink" title="luoguP1250"></a>luoguP1250</h5><p><a href="https://www.luogu.com.cn/problem/P1950">https://www.luogu.com.cn/problem/P1950</a></p>
<p>首先可以发现若将每一行分别作为常规单调栈矩形计数的问题,并不会影响上下层的结果,并且可以直接继承高度信息.于是就转化为做n次单调栈.<br>值得注意的是对于相连的等高项的处理,如果l[i],r[i]均只记录第一个更低位置,那么对于等高的i,i+1,这个区间内的矩形会重复计数.所以需要一个严格单调一个不严格来保证不重<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(tp2&amp;&amp;h[st2[tp2]]&gt;=h[j])&#123;</span><br><span class="line">                l[st2[tp2]]=j+<span class="number">1</span>,--tp2;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="keyword">while</span>(tp1&amp;&amp;h[st1[tp1]]&gt;h[j])&#123;</span><br><span class="line">                r[st1[tp1]]=j<span class="number">-1</span>,--tp1;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br></p>
<h5 id="HNOI2008水平可见直线"><a href="#HNOI2008水平可见直线" class="headerlink" title="HNOI2008水平可见直线"></a>HNOI2008水平可见直线</h5><p><a href="https://vijos.org/d/newbzoj/p/590c9879d3d8a13210993730">https://vijos.org/d/newbzoj/p/590c9879d3d8a13210993730</a><br>这题的本质就是半平面交.先按照斜率对全部直线排序,再依次塞入单调栈.被遮挡可以分为两种情况:1.k相同.那么b更大者一定更优;2.当前直线比栈顶直线位置更优,计算交点位置判断即可.<br><br><br></p>
<h5 id="luoguP2216"><a href="#luoguP2216" class="headerlink" title="luoguP2216"></a>luoguP2216</h5><p><a href="https://www.luogu.com.cn/problem/P2216">https://www.luogu.com.cn/problem/P2216</a></p>
<p>这题很显然是一个二维的滑动窗口.用n个单调队列维护每一行合法值,再将每一行最值塞进一个维护列的单调队列,每次移动后重置.每个点只会被扫描一次,复杂度$O(n^2)$<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">xq.<span class="built_in">reset</span>(),nq.<span class="built_in">reset</span>();</span><br><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,a) mxq[i].<span class="built_in">pb</span>(ar[i][rt],rt),mnq[i].<span class="built_in">pb</span>(ar[i][rt],rt);</span><br><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n<span class="number">-1</span>) xq.<span class="built_in">pb</span>(mxq[i].<span class="built_in">vl</span>(),i),nq.<span class="built_in">pb</span>(mnq[i].<span class="built_in">vl</span>(),i);</span><br><span class="line"><span class="built_in">For</span>(i,n,a)&#123;</span><br><span class="line">    xq.<span class="built_in">pb</span>(mxq[i].<span class="built_in">vl</span>(),i),nq.<span class="built_in">pb</span>(mnq[i].<span class="built_in">vl</span>(),i);</span><br><span class="line">    ans=<span class="built_in">min</span>(ans,xq.<span class="built_in">vl</span>()-nq.<span class="built_in">vl</span>());</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br><br></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>单调性</tag>
      </tags>
  </entry>
  <entry>
    <title>扫描线</title>
    <url>/%E6%89%AB%E6%8F%8F%E7%BA%BF/</url>
    <content><![CDATA[<h1 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h1><span id="more"></span>
<h2 id="What-a-Colorful-Wall"><a href="#What-a-Colorful-Wall" class="headerlink" title="What a Colorful Wall"></a>What a Colorful Wall</h2><p><a href="https://codeforces.com/gym/103443/problem/F">https://codeforces.com/gym/103443/problem/F</a></p>
<p>题意:n个有颜色的矩形按顺序放在平面上,被覆盖的部分颜色不可见,求最后可见的颜色数</p>
<p>矩形覆盖的问题很自然想到扫描线,先把矩形离散,按x坐标排序,并拆分为加入线段和删除线段两部分.线段树维护y轴,每个时刻先增删线段,每个节点挂一个可删堆维护当前区间内时间最大矩形的颜色,最后dfs全树,查询当前时刻能看到颜色种类.每次查询复杂度$O(nlogn)$,总共有n次询问,总复杂度$O(n^2logn)$,可以勉强卡过.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//黑科技可删堆</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HEAP</span>&#123;</span><br><span class="line">    priority_queue &lt;pii&gt; p,q;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(pii x)</span></span>&#123;p.<span class="built_in">push</span>(x);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(pii x)</span></span>&#123;q.<span class="built_in">push</span>(x);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mt</span><span class="params">()</span></span>&#123;<span class="keyword">while</span>(p.<span class="built_in">size</span>()&amp;&amp;q.<span class="built_in">size</span>()&amp;&amp;q.<span class="built_in">top</span>()==p.<span class="built_in">top</span>())p.<span class="built_in">pop</span>(),q.<span class="built_in">pop</span>();&#125;</span><br><span class="line">    <span class="function">pii <span class="title">top</span><span class="params">()</span></span>&#123;<span class="built_in">mt</span>();<span class="keyword">return</span> p.<span class="built_in">top</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;<span class="built_in">mt</span>();<span class="keyword">return</span> p.<span class="built_in">empty</span>();&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//此处和通常的线段树稍有不同,由于维护的实际上是矩形的边,表示颜色块需要边界-1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr) &#123;ar[p].<span class="built_in">add</span>(qii);<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;mid) <span class="built_in">add</span>(ls,l,mid);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;qr) <span class="built_in">add</span>(rs,mid,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr) &#123;ar[p].<span class="built_in">del</span>(qii);<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;mid) <span class="built_in">del</span>(ls,l,mid);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;qr) <span class="built_in">del</span>(rs,mid,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,pii pi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!ar[p].<span class="built_in">empty</span>()) pi=<span class="built_in">max</span>(pi,ar[p].<span class="built_in">top</span>());</span><br><span class="line">    <span class="keyword">if</span>(r-l==<span class="number">1</span>)&#123;ans[pi.second]=<span class="number">1</span>;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="built_in">dfs</span>(ls,l,mid,pi),<span class="built_in">dfs</span>(rs,mid,r,pi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    po=<span class="built_in">pii</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">For</span>(i,<span class="number">1</span>,ttx)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:vad[i]) qii=<span class="built_in">pii</span>(x.id,ocl[x.id]),ql=x.l,qr=x.r,<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>,tty);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:vde[i]) qii=<span class="built_in">pii</span>(x.id,ocl[x.id]),ql=x.l,qr=x.r,<span class="built_in">del</span>(<span class="number">1</span>,<span class="number">1</span>,tty);</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>,tty,po);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;<span class="built_in">For</span>(i,<span class="number">1</span>,n)cnt+=ans[i];</span><br><span class="line">    cout&lt;&lt;cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>一个更好的做法就是在每个时刻维护每种颜色可见的总长度,直接在增删线段时更新,不需要再dfs,复杂度$O(nlogn)$.</p>
<p>需要注意的是,如果直接用二维线段树或外层暴力内层线段树,虽然理论复杂度是$O(n^2logn)$的,但是常数巨大,无法通过(存疑).</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>数学归纳悖论</title>
    <url>/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%82%96%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="数学归纳悖论"><a href="#数学归纳悖论" class="headerlink" title="数学归纳悖论"></a>数学归纳悖论</h1><span id="more"></span>
<p><br></p>
<h3 id="蓝眼睛问题"><a href="#蓝眼睛问题" class="headerlink" title="蓝眼睛问题"></a>蓝眼睛问题</h3><p>在一个岛上,有n个蓝眼睛的人,m个黄眼睛的人.一日一名游客前来游玩,聊天的时候说:你们中有人和我一样有蓝眼睛.知道自己有蓝眼睛的人会沮丧地紫砂.那么这个岛上的人多长时间后可以知道自己眼睛的颜色呢?</p>
<p>在有人做出回应前,所有人都只会沉思.随着大家又沉默了一个时刻,唯一可以得到的新信息就是大家又沉默了一个时刻.似乎无从下手,先从最简单的情况看看.</p>
<p>若n=1,则唯一的蓝眼睛拥有者会立刻知道自己拥有蓝眼睛,在$t=1$时刻直接紫砂</p>
<p>若n=2,两名蓝眼睛拥有者看到没人在第一时间紫砂,又能看到除自己外仅有以为蓝眼睛拥有者,于是可以肯定自己为蓝眼睛,在$t=2$时刻紫砂.</p>
<p>若n=3,对任意一名蓝眼睛的人来说,如果假设自己是黄眼睛,那么就能看到$t=2$时刻人群中剩下的两个蓝眼睛的人同时紫砂.而这个事件并没有发生,于是在$t=3$时刻推出自己也为蓝眼睛,三个人同时紫砂.</p>
<p>当n&gt;3,可以按照这个假设的方法,对人们沉默的轮数进行递归计算.假设自己是黄眼睛,那么所看见的n-1个蓝眼睛的人应该在n-1时刻同时紫砂.根据观察的事实相反,可以推出所有的蓝眼睛人在第n个时刻一起知道自己眼睛的颜色.</p>
<p>沉默的是本题唯一的可更新信息,比起传统的信息,不如说是一个面对所有人的广播,公开自己的推理结果.在一开始,当不止一个蓝眼睛人时,虽然每个人都知道有蓝眼睛人,但并不知道其他人知不知道有没有蓝眼睛,也不知道其他人知不知道自己知不知道有没有蓝眼睛,很像三体里的猜疑链.而游客的话打破了这个无限的猜疑链,让所有人的信息都同时对对方公开,此后的沉默都不只是单纯的个人推理结果,而是彼此可以再次利用的条件.</p>
<p>某大佬将这两个称为“强共识”和“弱共识”.在游客发言之前,“岛上有蓝眼人”是一个弱共识,或者说沉默共识,但不是一个强共识,或者说公开共识.在游客发言之后,“岛上有蓝眼人”被提升成了一个强共识,或者说公开共识.强共识包含了比弱共识更多的信息,所以当然可以导致更多的后果.<br><br></p>
<h3 id="三人猜数"><a href="#三人猜数" class="headerlink" title="三人猜数"></a>三人猜数</h3><p><a href="https://www.luogu.com.cn/problem/P5779">https://www.luogu.com.cn/problem/P5779</a><br>题意:三个人头上各有一个正整数,每个人只能看到其他两人头上的数,并且有一人头上的数是另两人头上数的和,三人一言不发猜数,最后第n轮时有一个人知道了自己头上的数m.求所有可能的数字组合.还有一个<del>似乎很好推出的</del>结论:数最大者最先猜到.</p>
<p>乍一看毫无思绪.<del>怎么看都不会做啊.</del>三个人之间傻看着,除了沉默,没有产生任何新的信息.就算有这个结论,也只能把确定有m-1个组合,如何验证每个组合的可行性呢?</p>
<p>从最简单的情况入手,假如第一个人看到其他两个人的数相等,由于自己的数不可能是0,就可以推出自己的数为其余二人数的和.即</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>)-&gt;n=<span class="number">1</span>,m=<span class="number">2</span>;</span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)-&gt;n=<span class="number">2</span>,m=<span class="number">2</span>;</span><br><span class="line">(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>)-&gt;n=<span class="number">3</span>,m=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>对于更复杂的情况,由于每个人的数只可能是$a+b,|a-b|$.可以考虑像蓝眼睛问题一样,先假设自己的数是$|a-b|$,如果被证伪,那么自己的数肯定是$a+b$.然后就可以把问题转移到前一个猜数的人,如果在自己为$|a-b|$的条件下,前面的人无法得出结果,那么这个猜测就不可行.于是可以递归处理.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(p==<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(v2==v3) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v2&gt;v3) <span class="keyword">return</span> <span class="built_in">dfs</span>(v2-v3,v2,v3,<span class="number">2</span>)+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">dfs</span>(v3-v2,v2,v3,<span class="number">3</span>)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(v1==v3) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(v1&gt;v3) <span class="keyword">return</span> <span class="built_in">dfs</span>(v1,v1-v3,v3,<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">dfs</span>(v1,v3-v1,v3,<span class="number">3</span>)+<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(v1==v2) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(v2&gt;v1) <span class="keyword">return</span> <span class="built_in">dfs</span>(v1,v2,v2-v1,<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">dfs</span>(v1,v2,v1-v2,<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而唯一可以用于判断的量化标准就是沉默的轮数.对于一组数,仅当有人猜出来的轮数与给定的n轮相同,才能成为可行解.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">1</span>)<span class="keyword">if</span>(<span class="built_in">dfs</span>(m,i,m-i,<span class="number">1</span>)==n)++T,ans[T].a=m,ans[T].b=i,ans[T].c=m-i;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">2</span>)<span class="keyword">if</span>(<span class="built_in">dfs</span>(i,m,m-i,<span class="number">2</span>)==n)++T,ans[T].a=i,ans[T].b=m,ans[T].c=m-i;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">3</span>)<span class="keyword">if</span>(<span class="built_in">dfs</span>(i,m-i,m,<span class="number">3</span>)==n)++T,ans[T].a=i,ans[T].b=m-i,ans[T].c=m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><br><del>信息真神奇啊</del></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>最大流练习</title>
    <url>/%E6%9C%80%E5%A4%A7%E6%B5%81/</url>
    <content><![CDATA[<h1 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h1><span id="more"></span>
<h2 id="飞行员配对问题"><a href="#飞行员配对问题" class="headerlink" title="飞行员配对问题"></a>飞行员配对问题</h2><p><a href="https://www.luogu.com.cn/problem/P2756">https://www.luogu.com.cn/problem/P2756</a><br>网络流24题里的入门一题.<br>两种人之内没有交集,整个图可以看作二分图,跑匈牙利算法<br>也可以根据每个外籍飞行员和英国飞行员之间配对关系连边,看作最大流<br>在图中额外加入源点和汇点,分别与两组点连边,最大流的结果就是所求匹配数<br>最后输出方案就直接扫描残量网络,若起于外国并终于英国的边被流过则说明这两个人配对<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">For</span>(p,<span class="number">1</span>,n1)&#123;</span><br><span class="line">        <span class="built_in">For</span>(i,<span class="number">0</span>,od[p]<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(e.f||e.t&lt;=n1) <span class="keyword">continue</span>;</span><br><span class="line">            cout&lt;&lt;p&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;e.t&lt;&lt;<span class="string">&quot;\n&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><br></p>
<h2 id="试题库问题"><a href="#试题库问题" class="headerlink" title="试题库问题"></a>试题库问题</h2><p><a href="https://www.luogu.com.cn/problem/P2763">https://www.luogu.com.cn/problem/P2763</a><br>每一题仍然只能选取一次,但每张卷子都要求多道题<br>将与源点连边的容量改为题数,判断最大流是否等于总题数<br>输出方案时同上题做法<br><br></p>
<h2 id="圆桌问题"><a href="#圆桌问题" class="headerlink" title="圆桌问题"></a>圆桌问题</h2><p><a href="https://www.luogu.com.cn/problem/P3254">https://www.luogu.com.cn/problem/P3254</a><br>试题库问题的升级版,每组点都有多种限流<br>将汇点连边的容量也改为要求就行了<br><br></p>
<h2 id="魔术球问题"><a href="#魔术球问题" class="headerlink" title="魔术球问题"></a>魔术球问题</h2><p><a href="https://www.luogu.com.cn/problem/P2765">https://www.luogu.com.cn/problem/P2765</a><br>题意:有n个柱子,每个柱子上可以放球,相邻的球必须满足编号和为完全平方数,最大化放球的数量</p>
<p>这一题并没有直接的给出建图的信息,需要从相邻编号和为平方的限制条件中得到球之间的合法转移关系,就可以依此建出隐式图.</p>
<p>匹配数+柱子个数=球个数,所以我们不断试图增加匹配,在残量网络上不断跑最大流,直到匹配的最大值,就可以使球的个数最多.如果加入一个点而无法使匹配增大,那么说明球的个数已经达到了最大值.</p>
<p>如果沿用之前直接基于每个球代表的编号点进行转移的思路,源点流出的流量可以经过中转点直接流向汇点,起不到寻找匹配的作用.这里就需要拆点,用两个点代表一个球,分别与源汇点相连,入点连向可以组成平方数的出点,每次最大流的结果就是匹配数.</p>
<p>最后记得每次保存增加点之前的边,如果到达上限就清空并还原残量网络,最后一次跑最大流就可以得到点之间的匹配关系<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    ++add;lim+=<span class="number">2</span>;<span class="type">int</span> totrec=tot;</span><br><span class="line">    <span class="built_in">ins</span>(S,lim<span class="number">-1</span>,<span class="number">1</span>),<span class="built_in">ins</span>(lim,T,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">For</span>(i,<span class="number">1</span>,n+add<span class="number">-1</span>)<span class="keyword">if</span>(<span class="built_in">check</span>(i,n+add)) <span class="built_in">ins</span>(<span class="number">2</span>+i*<span class="number">2</span><span class="number">-1</span>,lim,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dinic</span>();<span class="keyword">if</span>(add==mxf) <span class="keyword">continue</span>;</span><br><span class="line">    lim-=<span class="number">2</span>,tot=totrec;<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=tot;i+=<span class="number">2</span>)eg[i].f+=eg[i^<span class="number">1</span>].f,eg[i^<span class="number">1</span>].f=<span class="number">0</span>;</span><br><span class="line">mxf=<span class="number">0</span>,<span class="built_in">dinic</span>();</span><br></pre></td></tr></table></figure><br><br></p>
<h2 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h2><p><a href="https://atcoder.jp/contests/abc274/tasks/abc274_g">https://atcoder.jp/contests/abc274/tasks/abc274_g</a></p>
<p>题意:给出一张矩阵,某些点处有障碍.每个点可以放置一台摄像机,选取四个方向中任一方向,对障碍前所有方格进行监视.除了障碍,所有点均需被监视.求出最小所用摄像头数.</p>
<p>首先,可以很明显的看出,对于放置于某格某方向的摄像头,如果反向的格子为空,那么此摄像头放在反向一定不会使答案更劣.所以所有的摄像头都应该沿着障碍物放置(此处将矩阵的边缘视为障碍物).</p>
<p>对于一条边的覆盖,两个端点只要有一个有该方向的覆盖就足够.所以只会有方向向下或向右的摄像头(向左,向上同理).</p>
<p>现在题意被转化为,在一个联通块的上边缘和左边缘放置摄像头,使得达到全覆盖.似乎除了dp之外想不到其他的方法,但是状压dp的复杂度不对,插头dp更是没有必要.试着再次换一个角度,考虑每个点如果能达成覆盖需要满足的条件.当前仅当每个点能到达的最左点或最上点中至少其一放置摄像头,全图完成覆盖.现在题意是,有若干个二元组,每个二元组中至少一个数被选取,求最小选取数.</p>
<p>这张图其实是一张二分图,问题就变成求解二分图的最小覆盖.根据Dilworth定理,建图后跑最大流即可求出.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">iFor</span>(i,n,<span class="number">1</span>)<span class="built_in">iFor</span>(j,m,<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!mp[i][j])<span class="keyword">continue</span>;</span><br><span class="line">    dn[i][j]=rt[i][j]=p;</span><br><span class="line">    <span class="keyword">if</span>(mp[i+<span class="number">1</span>][j])dn[i][j]=dn[i+<span class="number">1</span>][j]; </span><br><span class="line">    <span class="keyword">if</span>(mp[i][j+<span class="number">1</span>])rt[i][j]=rt[i][j+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">con</span>(S,p,<span class="number">1</span>),<span class="built_in">con</span>(p+n*m,T,<span class="number">1</span>),<span class="built_in">con</span>(dn[i][j],rt[i][j]+n*m,INF); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>最小割练习</title>
    <url>/%E6%9C%80%E5%B0%8F%E5%89%B2/</url>
    <content><![CDATA[<h1 id="最小割"><a href="#最小割" class="headerlink" title="最小割"></a>最小割</h1><span id="more"></span>
<p>有某位神仙说过,一切问题都是网络流.很多涉及到代价,贡献,依赖,互斥的问题都可以转化为最小割来处理.一般不会给出明显的图关系,很多时候需要根据图中信息建立隐式图.推荐两篇论文,hbt的《最小割模型在信息学竞赛中的应用》和pty的《浅析一类最小割问题》,透彻明晰的分析了几个最常用模型.</p>
<p><br></p>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>考虑最基本的只有一个非源汇节点的网络,最小割的结果就是源汇边容量的较小者.如果有两个非源汇节点链式相连,最小割的结果等于三条边容量的最小值.将中间的边容量设为无穷,则可表现两个点互斥,即必须二选一的限制.</p>
<p>如果中间的边容量有意义,那么他代表选取前者而放弃后者的代价.只有这条边流满,顶点才能分属不同点集.</p>
<p>对于依赖关系,可以考虑类似于否定否命题的思路构造.将任一非源汇点按出边入边拆为出点入点,可以代表选与不选,则两点互斥,依赖入点等价于与出点互斥.在某些情况下,入点和出点的区别并不会直接影响图的性质,就可以将两个点合并,此时目标点直接向依赖点连容量无限的边.也可以用代价的观点看成选后者而不选前者的代价无穷大,两者必须归属同一划分.</p>
<p>在原图解最小割的结果就是满足限制的最小代价.如果要求最大收益,一般预先将价值求和,再减去最小割.<br><br></p>
<h2 id="小M的作物"><a href="#小M的作物" class="headerlink" title="小M的作物"></a>小M的作物</h2><p><a href="https://www.luogu.com.cn/problem/P1361">https://www.luogu.com.cn/problem/P1361</a><br>题意:有n种作物,每一种可以种在A,B两个田里,分别收获$a_i,b_i$的价值.给出m种组合,若组合内所有作物都种在A,B内,额外获得$ea_i,eb_i$的价值.求出可以获得的最大价值.</p>
<p>首先不看额外附加的价值,直接贪心就是答案.贪心策略毫无疑问就是选取较大者,也可以转述为两者之和减去较小者.<del>很容易联想到</del>,最小割也可以用来求两者中的较小值.将权值作为容量,分别连向源汇,达到满流后,总流量就是二者中的较小者.最大价值可以预先存下所有价值的和,再减去最小割得到.</p>
<p>那么这个直接能无脑贪心的问题,为什么要去扯上最小割呢?最小割可以处理依赖关系下的求值,刚好能解决组合额外价值的计算.考虑将每种作物拆分为A,B两个点,分别代表选择田地A或B,再将组合建立虚拟点,可以发现图中的依赖关系,任一个组合能被选取仅当所有目标作物都选为对应的土地,即$ma_i$依赖于$a_j,(j \in {S_i})$全部被选取.</p>
<p><img src="E:\PD\pics\最小割1.png" style="zoom: 50%;" /></p>
<p>此处并不需要直接把代表作物的点拆出来,因为入点和出点之间的边容量为无穷,合并也不会影响结果.黑边的容量为无限.在最小割中,以代价或贡献的角度考虑,无限容量代表永远不割去此条边,即不选择依赖项直接选则目的项的代价无限大.这样就可以保证,要么不选此项,割掉其与源汇点的边,要么捆绑式选取所有依赖点.</p>
<p>求额外价值的方法和单个点一样,预先将价值加到总和中,最后减去最小割.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n)cin&gt;&gt;rec[i][<span class="number">0</span>],sum+=rec[i][<span class="number">0</span>];</span><br><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n)cin&gt;&gt;rec[i][<span class="number">1</span>],sum+=rec[i][<span class="number">1</span>];</span><br><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n)<span class="built_in">con</span>(S,i,rec[i][<span class="number">0</span>]),<span class="built_in">con</span>(i,T,rec[i][<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">    <span class="built_in">con</span>(S,p1,v1),<span class="built_in">con</span>(p2,T,v2),sum+=v1+v2;</span><br><span class="line">    <span class="built_in">For</span>(j,<span class="number">1</span>,k)&#123;ll p;cin&gt;&gt;p;<span class="built_in">con</span>(p1,p,INF),<span class="built_in">con</span>(p,p2,INF);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dinic</span>();</span><br><span class="line">cout&lt;&lt;sum-mxf;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="city-safety"><a href="#city-safety" class="headerlink" title="city safety"></a>city safety</h2><p><a href="https://codeforces.com/gym/103428/problem/H">https://codeforces.com/gym/103428/problem/H</a><br>题意：一棵树，加强第i 个点有$w_i$ 的花费，而如果距离某个点≤ d 的所有点都加强了，则会有$v_d$ 的收益，求最大净收益。<br>看起来像个树形dp,但是祖先的状态不好处理,转移方程写不出<del>太菜了</del>.于是考虑歪门邪道.</p>
<p>将贡献差分,将每个点处的贡献拆为n个点,建图,可以发现这是一个典型的依赖-代价图.于是考虑分别找出依赖关系和正负收益建图.<br>每个点都做一次dfs得到依赖关系,距离点p为d的贡献所对应的点依赖于距离点p为d-1的对应点,和原树中距离树节点p为d的所有树节点.对于所有依赖关系连上容量无限的单边.<br>源点向所有代表贡献的点连上容量为贡献差分的边,所有树节点向汇点连上容量为代价的边,就是最小割的经典模型.<br>预先对所有贡献求和,最后的结果就是总和减去最小割.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> d,<span class="type">int</span> f,<span class="type">int</span> S)</span></span>&#123;</span><br><span class="line">    <span class="built_in">con</span>(S+n*d,p,INF);</span><br><span class="line">    <span class="built_in">For</span>(i,<span class="number">0</span>,od2[p]<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ov2[p][i]^f)<span class="built_in">dfs2</span>(ov2[p][i],d+<span class="number">1</span>,p,S);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">For</span>(i,<span class="number">1</span>,n)&#123;ll v;cin&gt;&gt;v;<span class="built_in">con</span>(i,T,v);&#125;</span><br><span class="line">    ll pre=<span class="number">0</span>;</span><br><span class="line">    sum=n*bnf[n];</span><br><span class="line">    <span class="built_in">For</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">dfs2</span>(i,<span class="number">1</span>,<span class="number">0</span>,i);</span><br><span class="line">        <span class="built_in">For</span>(j,<span class="number">1</span>,n)&#123;<span class="built_in">con</span>(S,i+j*n,bnf[j]-bnf[j<span class="number">-1</span>]);<span class="keyword">if</span>(j&gt;<span class="number">1</span>)<span class="built_in">con</span>(i+j*n,i+j*n-	n,INF);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dinic</span>();</span><br><span class="line">    cout&lt;&lt;sum-mxf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="土地划分"><a href="#土地划分" class="headerlink" title="土地划分"></a>土地划分</h2><p><a href="https://www.luogu.com.cn/problem/P4210">https://www.luogu.com.cn/problem/P4210</a><br>题意:在一张无向联通图中,每个点归属点集1,点集n二者之一,分别获得$a_i,b_i$的收益.如果一条边两个顶点同属于点集1或点集n,则额外获得$Ea_i,Eb_i$的收益,若一条边两个顶点不属于同一点集,则会产生$Ec_i$的损失.求一种划分使得收益最大.</p>
<p>这个模型太眼熟了,可以用pty论文中的方法解决.<br>简单回顾一下模型,<del>知道的大佬可以直接跳过</del></p>
<h3 id="机械调度"><a href="#机械调度" class="headerlink" title="机械调度"></a>机械调度</h3><p>有n个任务,每个可以在机械A,B上完成,所选的方案记为二元组$(x,y)$.选择A或B会产生$A_i,B_i$的代价.对于每一组$(x,y)$,都会产生一组给定的代价,$v_1,v_2,v_3,v_4$.求一种方案使得总代价最小.</p>
<p>对于每个任务的代价,暂不考虑,可以最后再加到割边上去.现考虑二元组的影响,在原图上重新建边.</p>
<p><img src="E:\PD\texts\总结\浅析一类最小割问题(pty).png" style="zoom:150%;" /></p>
<p>边的容量必须满足以下限制</p>
<script type="math/tex; mode=display">
a+b=v1 \\
c+d=v2 \\
a+e+d=v3 \\
b+f+c=v4</script><p>其中可能出现类似$a+b+d$的方案,因为肯定不如$a+b$优,不用考虑.<br>在这个图中,点x,y具有类似于对称的性质,所以e,f可以直接取等,$e=f=(v3+v4-v1-v2)/2$.剩下的容量也可以直接怎么简单取,任何一种合法的选取最后并不影响答案的正确性.</p>
<script type="math/tex; mode=display">
a=(v1+v3)/2 \\
b=(v1-v3)/2 \\
c=(v2+v4)/2 \\
d=(v2-v4)/2 \\
e=f=(v3+v4-v1-v2)/2</script><p>然后以每个任务自身的代价连边,最后最小割就是答案.<br><br></p>
<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><p>回到本题,将所有的代价取负变为贡献,答案就是所有容量的和减去最小割.<br>与模型唯一的不同就是划分不同时的代价变成了贡献,那就预先把所有的贡献加和,再将容量的差加到相同划分的代价上,最后如果划分不同时结果会相抵消.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">For</span>(i,<span class="number">2</span>,n<span class="number">-1</span>)&#123;ll v;cin&gt;&gt;v;v*=<span class="number">2</span>,sum+=v,<span class="built_in">con</span>(S,i,v);&#125;</span><br><span class="line"><span class="built_in">For</span>(i,<span class="number">2</span>,n<span class="number">-1</span>)&#123;ll v;cin&gt;&gt;v;v*=<span class="number">2</span>,sum+=v,<span class="built_in">con</span>(i,T,v);&#125;</span><br><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">    <span class="type">int</span> p1,p2;ll v1,v2,v3;</span><br><span class="line">    cin&gt;&gt;p1&gt;&gt;p2&gt;&gt;v1&gt;&gt;v2&gt;&gt;v3;</span><br><span class="line">    sub+=v3,v1+=v3,v2+=v3;</span><br><span class="line">    v1*=<span class="number">2</span>,v2*=<span class="number">2</span>,sum+=v1+v2;</span><br><span class="line">    <span class="built_in">con</span>(S,p1,v1/<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">con</span>(S,p2,v1/<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">con</span>(p1,T,v2/<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">con</span>(p2,T,v2/<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">con</span>(p1,p2,(v1+v2)/<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">con</span>(p2,p1,(v1+v2)/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></p>
<h2 id="方格取数问题"><a href="#方格取数问题" class="headerlink" title="方格取数问题"></a>方格取数问题</h2><p><a href="https://www.luogu.com.cn/problem/P2774">https://www.luogu.com.cn/problem/P2774</a><br>题意:给定一个n*m的矩阵,要求取出若干个数,使总和最大,同时满足每个数在矩阵中的位置都不相邻</p>
<p>相邻不能同时取,这个条件给出了互斥性,暗示着可以根据矩阵中位置的奇偶性,将原图看作一张二分图,不相交的两侧分别代表奇偶点,代表两个点至少一条连向源汇的边被割掉,即至少弃掉一个点.原问题等价于二分图带权最大独立集.</p>
<p><img src="E:\PD\pics\p1.png" style="zoom:50%;" /></p>
<p>这个总和最大感觉不太好求,就转化问题,求一个取数组合使剩下的数均不相邻,且该组合最小.这种取法会将原二分图拆成两个不相连部分,与最大流的残量网络极其相像.最后的S,T集里的点就是目标取点.</p>
<p><img src="E:\PD\pics\p2.png" style="zoom:50%;" /></p>
<p><del>图中黑边为被删去的边,蓝边为可行边</del>此图有误,被删去的边可能流量在残量网络没有跑完,但经过调整后一定可以使每条边对应点的状态.<br><br></p>
<h2 id="圈地计划"><a href="#圈地计划" class="headerlink" title="圈地计划"></a>圈地计划</h2><p><a href="https://www.luogu.com.cn/problem/P1935">https://www.luogu.com.cn/problem/P1935</a><br>题意:一个nm矩阵,每个点位选择A或B,得到收益$a_{ij},b_{ij}$.若两个相邻的点选择不同,获得额外收益$C_{ij}+C_{kl}$.求所能获得的最大收益.</p>
<p>推荐先做这一题<a href="https://www.luogu.com.cn/problem/P1646,本题的简单版">https://www.luogu.com.cn/problem/P1646,本题的简单版</a>.</p>
<p>很显然,pty的模型可以直接套用,不过此处由于图的结构,需要做一些变换.此处用更好理解的虚拟点法,同时进行了和论文中变换本质相同的构造.</p>
<p>这是个有互斥属性的矩形问题,不妨想想方格取数中的解决方案,按奇偶来分类点.将所有的奇点反转,入点和出点交换,源汇边容量交换,就重新得到一张意义明确的类二分图.再按对相邻的依赖关系对虚拟店连边,就可以求出正确的最小割.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n)<span class="built_in">For</span>(j,<span class="number">1</span>,m)&#123;ll v;cin&gt;&gt;v;sum+=v;<span class="keyword">if</span>((i+j)&amp;<span class="number">1</span>)<span class="built_in">con</span>(S,p,v);<span class="keyword">else</span> <span class="built_in">con</span>(p,T,v);&#125;</span><br><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n)<span class="built_in">For</span>(j,<span class="number">1</span>,m)&#123;ll v;cin&gt;&gt;v;sum+=v;<span class="keyword">if</span>((i+j)&amp;<span class="number">1</span>)<span class="built_in">con</span>(p,T,v);<span class="keyword">else</span> <span class="built_in">con</span>(S,p,v);&#125;</span><br><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n)<span class="built_in">For</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">    ll v;cin&gt;&gt;v;</span><br><span class="line">    <span class="keyword">if</span>(i^<span class="number">1</span>)sum+=v,<span class="built_in">con</span>(S,eg,v),<span class="built_in">con</span>(eg,p,INF),<span class="built_in">con</span>(eg,x,INF);</span><br><span class="line">    <span class="keyword">if</span>(i^n)sum+=v,<span class="built_in">con</span>(S,eg,v),<span class="built_in">con</span>(eg,p,INF),<span class="built_in">con</span>(eg,x,INF);</span><br><span class="line">    <span class="keyword">if</span>(j^<span class="number">1</span>)sum+=v,<span class="built_in">con</span>(S,eg,v),<span class="built_in">con</span>(eg,p,INF),<span class="built_in">con</span>(eg,x,INF);</span><br><span class="line">    <span class="keyword">if</span>(j^m)sum+=v,<span class="built_in">con</span>(S,eg,v),<span class="built_in">con</span>(eg,p,INF),<span class="built_in">con</span>(eg,x,INF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="人员雇佣"><a href="#人员雇佣" class="headerlink" title="人员雇佣"></a>人员雇佣</h2><p><a href="https://www.luogu.com.cn/problem/P1791">https://www.luogu.com.cn/problem/P1791</a><br>题意:有n个员工,雇佣成本分别为$a_i$.若$i,j$两个员工同时雇佣,则获得收益$E_{i,j}$,如果其中一人被雇佣而另一人没有,则付出额外代价$E_{i,j}$.求最大收益.</p>
<p>用虚拟点的想法,拆点为选或不选,再将额外收益或惩罚连依赖边,最后再处理收益与惩罚的互斥性上遇到了麻烦,似乎并不好表示.</p>
<p>考虑边的意义.先将贡献加和转化问题为求最小代价,向源汇连收益和代价.点i向点j连容量为$2E_{i,j}$的边,表示两者不在同一集合的代价为$2E_{i,j}$,就搞定辣.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n)&#123;ll v;cin&gt;&gt;v;<span class="built_in">con</span>(i,T,v);&#125;</span><br><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n)<span class="built_in">For</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">    ll v;cin&gt;&gt;v;<span class="keyword">if</span>(i==j)<span class="keyword">continue</span>;</span><br><span class="line">    rec[j]+=v,sum+=v,<span class="built_in">con</span>(i,j,v*<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n)<span class="built_in">con</span>(S,i,rec[i]);</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树维护修改</title>
    <url>/%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%BB%B4%E6%8A%A4%E4%BF%AE%E6%94%B9/</url>
    <content><![CDATA[<h1 id="线段树维护修改"><a href="#线段树维护修改" class="headerlink" title="线段树维护修改"></a>线段树维护修改</h1><span id="more"></span>
<h2 id="luoguP6327区间sin和"><a href="#luoguP6327区间sin和" class="headerlink" title="luoguP6327区间sin和"></a>luoguP6327区间sin和</h2><p><a href="https://www.luogu.com.cn/problem/P6327">https://www.luogu.com.cn/problem/P6327</a></p>
<p>题意:每次修改一个点,求区间sin值的和<br>区间sin和的信息不可加,但可以考虑和差化积公式,</p>
<script type="math/tex; mode=display">
sin(x+v)=sin(x)cos(v)+sin(v)cos(x)\\
cos(x+v)=cos(x)cos(v)-sin(x)sin(v)</script><p>同时记录cos和sin值就可以转化为线段树求和.<br>由于节点的tag不能直接和子节点的和相加,需要注意每次询问时先下放标签.还有浮点运算的常数极大,下放时先判一下0,不然很容易tle.<br><br></p>
<h2 id="luoguP1471方差"><a href="#luoguP1471方差" class="headerlink" title="luoguP1471方差"></a>luoguP1471方差</h2><p><a href="https://www.luogu.com.cn/problem/P1471">https://www.luogu.com.cn/problem/P1471</a></p>
<p>题意:每次修改一个点,求区间平均数和方差<br>首先是平均数的合并$a_3=(a_1n_1+a_2n_2)/(n_1+n_2)$<br>再考虑方差的更改,每次修改时可以$O(1)$的更新</p>
<script type="math/tex; mode=display">
D_1=\frac 1n\Sigma(x_i-a_1)^2\\
D_2=\frac 1n\Sigma(x_i+v-a_2)^2\\
D_2-D_1=\frac 1n\Sigma((x_i+v-a_2)^2-(x_i-a_1)^2)\\
       =\frac 1n\Sigma(v^2+a_2^2+2x_iv-2a_2v-2a_2x_i-a_1^2+2x_ia_1)\\
       =v^2+a_2^2-a_1^2-2a_2v+(2v-2a_2+2a_1)\frac 1n \Sigma x_i\\
       =v^2+a_2^2-a_1^2-2a_2v+2a_1v-2a_1a_2+2a_1^2\\
       =a_1^2+a_2^2+v^2+2a_1v-2a_2v-2a_1a_2</script><p>最后是方差的合并</p>
<script type="math/tex; mode=display">
D_1=\frac 1{n_1}\Sigma(x_1i-a_1)^2\\
D_2=\frac 1{n_2}\Sigma(x_2i-a_2)^2\\
D_3=\frac 1{n_1+n_2}\Sigma(x_i-a_3)^2\\
(n_1+n_2)D_3-D_1n_1-D_2n_2=\Sigma((x_i-a_3)^2-(x_i-a_j)^2)(j=1,2)\\
                          =\Sigma(a_3^2-a_j^2+2x_i(a_j-a_3))\\
                          =n_1(a_3^2-a_1^2)+2n_1a_1(a_1-a_3)\\
                          +n_2(a_3^2-a_2^2)+2n_2a_2(a_2-a_3)\\
                          =n_1a_1^2+n_2a_2^2-(n_1+n_2)a_3^2</script><p>最后特别要注意在合并方差时跨中点情况的判断,左右两段的长度应该取min(当前区间长度,询问区间长度)<br><br></p>
<h2 id="luoguP5142区间方差"><a href="#luoguP5142区间方差" class="headerlink" title="luoguP5142区间方差"></a>luoguP5142区间方差</h2><p><a href="https://www.luogu.com.cn/problem/P5142">https://www.luogu.com.cn/problem/P5142</a><br>基本与上题相同.longlong本身常数大,全局还带了一个$O(logn)$的求逆,无脑取模会t飞.本题需要先处理出inv数组,还要取模时判断优化,以免被卡常.<br><br></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>线规单纯形</title>
    <url>/%E7%BA%BF%E8%A7%84%E5%8D%95%E7%BA%AF%E5%BD%A2/</url>
    <content><![CDATA[<p>trivival风格的一篇线规博客</p>
<p><br></p>
<span id="more"></span>
<h1 id="单纯形算法"><a href="#单纯形算法" class="headerlink" title="单纯形算法"></a>单纯形算法</h1><h2 id="标准型"><a href="#标准型" class="headerlink" title="标准型"></a>标准型</h2><p>线性规划是对有限制的最优化线性问题的求解。<br>人话来说，给出若干个限制方程，其中的所有变量次数都为一次。要求在满足所有限制的情况下，安排各变量的取值，使得一个由这些线性变量组合得到的目标函数取得最值。</p>
<p>更加形式化的给出上述描述</p>
<script type="math/tex; mode=display">
\Sigma_j c_{i,j} x_{j} \leqslant b_i\\
x_i \geqslant 0 \\
maximize: \quad
z=\Sigma_i a_i x_i</script><p>这个形式也被称为线规的标准式，可以写成矩阵的形式</p>
<script type="math/tex; mode=display">
maximize \quad
z=AX\\
CX \leqslant B\\
C=\{ c_{i,j} \}</script><p>如果不等号的方向与标准型不同，或者要求最小化木匾函数，系数取负就可以了。</p>
<p>如果决策变量$x_i$没有非负限制，将$x_i$拆为两个变量$x_{i1} \leq 0,x_{i2} \leq 0 ,x_i=x_{i1}-x_{i2}$</p>
<p>由于不等式不如等式方便处理，将$\Sigma_j c_{i,j} x_{j} \leqslant b_i$改成$\Sigma_j c_{i,j} x_{j} + f_i = b_i$<br>$x_i$作主元，参与最优化的决策变量。$f_i$是自由变量。</p>
<p>如果初始有n个决策变量，m个限制方程，那么新扩展的线性方程组就有$n+m$个变量。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>如果$n &gt; m$会存在自由的决策变量，答案是无界的。下面只考虑$n \leq m$的情况。</p>
<p>对于上述限制，考虑会有确定的最值的情况。<br>如果$z=\Sigma_i a_i x_i,a_i\leqslant0$，那么在各个方向上都存在单调性，$x_i$尽可能去满足限制的较小值，最优情况下取到$0$。</p>
<p>由于有辅助变量的存在，我们可以在上述方程组中进行换元，即用一个辅助变量代替主元，成为决策变量。从实现上来说，就是在决策变量的方程中把主元$x_i$用$\Sigma_{j\neq i}v_j x_j + v_t f_t$代替，并且将$f_t$在原$x_i$的方程中系数定为1，调整参数矩阵。这个操作命名为pivot，意为转轴，将主元和自由元转换。</p>
<p>很容易想到一个逼近最优解的办法，尝试不断的将$a_i &gt; 0 $的主元替换，直到所有$a_i \leq 0$。那么该如何选取自由变量$f_t$呢？只有$x_i = v_{i,t} f_t ,v_{i,t} \leq 0$的情况下，换元后新的$a_t$会非正。考虑最优化每次选取$f_t$的收益，我们找$v_{i,t}$最大的$f_t$。</p>
<p>综上可以得到一个算法，每次选一个$a_i&gt;0$的主元，用最大$v_{i,t}\geq 0$的自由元代替。如果不存在$a_i&gt;0$的主元，代表此时已经找到$z$的最优解。如果找不到$v_{i,t}\geq 0$的自由元，那么$x_i$没有上界，答案无界。</p>
<p>至于可能存在的无解情况，考虑在$\Sigma_j c_{i,j} x_{j} \leqslant b_i$中,如果$c_{i,j}&gt;0,b_i&lt;0$，那么这个限制就不可能被满足。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>辅助变量并不需要显式的表示在方程中表示，本质就是不等式的常数部分。</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// m个约束 n个决策变量 </span></span><br><span class="line">ld ar[M][N];<span class="type">int</span> n,m;</span><br><span class="line"><span class="comment">// ar[0][0] 最优解</span></span><br><span class="line"><span class="comment">// ar[0][c] 目标函数系数</span></span><br><span class="line"><span class="comment">// ar[r][0] 限制方程常数部分 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//换元</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pivot</span><span class="params">(<span class="type">int</span> fre,<span class="type">int</span> bas)</span></span>&#123;</span><br><span class="line">    ld t=-ar[fre][bas];ar[fre][bas]=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">ffor</span>(j,<span class="number">0</span>,n)ar[fre][j]/=t;</span><br><span class="line">    <span class="built_in">ffor</span>(i,<span class="number">0</span>,m)<span class="keyword">if</span>(<span class="built_in">fabs</span>(ar[i][bas])&gt;EPS&amp;&amp;i!=fre)&#123;</span><br><span class="line">        t=ar[i][bas],ar[i][bas]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">ffor</span>(j,<span class="number">0</span>,n)ar[i][j]+=t*ar[fre][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">simplex</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 判断无解，并将所有的限制方程变为可换元的形式</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> bas=<span class="number">0</span>,fre=<span class="number">0</span>;ld mn=-EPS;</span><br><span class="line">        <span class="built_in">ffor</span>(i,<span class="number">1</span>,m)<span class="keyword">if</span>(ar[i][<span class="number">0</span>]&lt;mn)mn=ar[fre=i][<span class="number">0</span>];<span class="keyword">if</span>(!fre)<span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">ffor</span>(j,<span class="number">1</span>,n)<span class="keyword">if</span>(ar[fre][j]&gt;EPS)&#123;bas=j;<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(!bas)&#123;cout&lt;&lt;<span class="string">&quot;Infeasible&quot;</span>;<span class="keyword">return</span> ;&#125;</span><br><span class="line">        <span class="built_in">pivot</span>(fre,bas);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 主要部分，并判断解时候有界</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> bas=<span class="number">0</span>,fre=<span class="number">0</span>;ld mn=EPS,mx=INF;</span><br><span class="line">        <span class="built_in">ffor</span>(j,<span class="number">1</span>,n)<span class="keyword">if</span>(ar[<span class="number">0</span>][j]&gt;mn)mn=ar[<span class="number">0</span>][bas=j];<span class="keyword">if</span>(!bas)<span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">ffor</span>(i,<span class="number">1</span>,m)<span class="keyword">if</span>(ar[i][bas]&lt;-EPS&amp;&amp;(-ar[i][<span class="number">0</span>]/ar[i][bas])&lt;mx)</span><br><span class="line">        mx=-ar[i][<span class="number">0</span>]/ar[i][bas],fre=i;</span><br><span class="line">        <span class="keyword">if</span>(!fre)&#123;cout&lt;&lt;<span class="string">&quot;Unbounded&quot;</span>;<span class="keyword">return</span> ;&#125;</span><br><span class="line">        <span class="built_in">pivot</span>(fre,bas);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h2 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h2><p>这个线性不等式的形式含义是什么呢？观察不等式$\Sigma_j c_{i,j} x_{j} \leqslant b_i$，很自然的想到这是一个半平面的表示。即一个n维超平面将空间分割为两部分，并去下半部分。</p>
<p>那么不等式$CX \leqslant B$就是若干个这样超平面的交，对于向量组$X$，满足不等式的范围也是$X$的合法取值。</p>
<p>再看$z=\Sigma_i a_i x_i$，即$\Sigma_i a_i x_i - z = 0$也是一个超平面，在各维的导数是$a_i$，截距是$a_i/z$。</p>
<p>那么原问题可以理解为，在一个满足限制的半平面交中，平移一个平面，使得该平面始终与半平面交相交，并最大化截距的绝对值。</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="uoj-线规模板"><a href="#uoj-线规模板" class="headerlink" title="uoj 线规模板"></a>uoj 线规模板</h2><p>题目链接:<a href="https://uoj.ac/problem/179">https://uoj.ac/problem/179</a></p>
<p>题意:给出一组标准型线规，求解或判断线规解的类型</p>
<p>代码:</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ffor(i,a,b) for(int i=a;i&lt;=b;++i) </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ld=<span class="type">long</span> <span class="type">double</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e2</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ld EPS=<span class="number">1e-9</span>;</span><br><span class="line"><span class="type">const</span> ld INF=<span class="number">1e15</span>;</span><br><span class="line"><span class="comment">// m个约束 n个决策变量 </span></span><br><span class="line">ld ar[N][N];</span><br><span class="line"><span class="type">int</span> id[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="comment">// ar[0] 目标函数</span></span><br><span class="line"><span class="comment">// ar[r][0] 常数部分 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将主元bas变为非基变量</span></span><br><span class="line"><span class="comment">// 将非基变量fre变为主元 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pivot</span><span class="params">(<span class="type">int</span> fre,<span class="type">int</span> bas)</span></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(id[fre+n],id[bas]);</span><br><span class="line">    ld t=-ar[fre][bas];ar[fre][bas]=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">ffor</span>(j,<span class="number">0</span>,n)ar[fre][j]/=t;</span><br><span class="line">    <span class="built_in">ffor</span>(i,<span class="number">0</span>,m)<span class="keyword">if</span>(<span class="built_in">fabs</span>(ar[i][bas])&gt;EPS&amp;&amp;i!=fre)&#123;</span><br><span class="line">        t=ar[i][bas],ar[i][bas]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">ffor</span>(j,<span class="number">0</span>,n)ar[i][j]+=t*ar[fre][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ty;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">simplex</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">ffor</span>(i,<span class="number">1</span>,n) id[i]=i;</span><br><span class="line">    <span class="comment">// 判断可解性 </span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> bas=<span class="number">0</span>,fre=<span class="number">0</span>;ld mn=-EPS;</span><br><span class="line">        <span class="built_in">ffor</span>(i,<span class="number">1</span>,m)<span class="keyword">if</span>(ar[i][<span class="number">0</span>]&lt;mn)mn=ar[fre=i][<span class="number">0</span>];<span class="keyword">if</span>(!fre)<span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">ffor</span>(j,<span class="number">1</span>,n)<span class="keyword">if</span>(ar[fre][j]&gt;EPS)&#123;bas=j;<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(!bas)&#123;ty=<span class="number">-1</span>;cout&lt;&lt;<span class="string">&quot;Infeasible&quot;</span>;<span class="keyword">return</span> ;&#125;</span><br><span class="line">        <span class="built_in">pivot</span>(fre,bas);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断有限性 </span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> bas=<span class="number">0</span>,fre=<span class="number">0</span>;ld mn=EPS,mx=INF;</span><br><span class="line">        <span class="built_in">ffor</span>(j,<span class="number">1</span>,n)<span class="keyword">if</span>(ar[<span class="number">0</span>][j]&gt;mn)mn=ar[<span class="number">0</span>][bas=j];<span class="keyword">if</span>(!bas)<span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">ffor</span>(i,<span class="number">1</span>,m)<span class="keyword">if</span>(ar[i][bas]&lt;-EPS&amp;&amp;(-ar[i][<span class="number">0</span>]/ar[i][bas])&lt;mx)</span><br><span class="line">        mx=-ar[i][<span class="number">0</span>]/ar[i][bas],fre=i;</span><br><span class="line">        <span class="keyword">if</span>(!fre)&#123;ty=<span class="number">-1</span>;cout&lt;&lt;<span class="string">&quot;Unbounded&quot;</span>;<span class="keyword">return</span> ;&#125;</span><br><span class="line">        <span class="built_in">pivot</span>(fre,bas);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ar[0][0] 目标函数最大值 </span></span><br><span class="line"><span class="type">int</span> rec[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">simplex</span>();</span><br><span class="line">    <span class="keyword">if</span>(ty==<span class="number">-1</span>)<span class="keyword">return</span> ;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">10</span>);</span><br><span class="line">    cout&lt;&lt;ar[<span class="number">0</span>][<span class="number">0</span>]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(ty==<span class="number">0</span>)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">// ar[rec[i]] 第i个决策变量的取值 </span></span><br><span class="line">    <span class="built_in">ffor</span>(i,n+<span class="number">1</span>,n+m)rec[id[i]]=i-n;</span><br><span class="line">    <span class="built_in">ffor</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cout&lt;&lt;(rec[i]?ar[rec[i]][<span class="number">0</span>]:<span class="number">0</span>)&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;ty;</span><br><span class="line">    <span class="built_in">ffor</span>(j,<span class="number">1</span>,n)cin&gt;&gt;ar[<span class="number">0</span>][j];</span><br><span class="line">    <span class="built_in">ffor</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="built_in">ffor</span>(j,<span class="number">1</span>,n)cin&gt;&gt;ar[i][j],ar[i][j]*=<span class="number">-1</span>;</span><br><span class="line">        cin&gt;&gt;ar[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">input</span>();</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

    </div>
</div>
<h2 id="NOI2008-志愿者招募"><a href="#NOI2008-志愿者招募" class="headerlink" title="NOI2008 志愿者招募"></a>NOI2008 志愿者招募</h2><p>题目链接:<a href="https://www.luogu.com.cn/problem/P3980">https://www.luogu.com.cn/problem/P3980</a></p>
<p>题面:项目需要$n$天才能完成，其中第$i$天至少需要$a_i$个人。布布通过了解得知，一共有$m$类志愿者可以招募,每类志愿者的数量都是无限多的。其中第$i$类可以从第$s_i$天工作到第$t_i$天，招募费用是每人$c_i$元。要求在完成项目的前提下，最小化花费。</p>
<p>题意:$n$天即有$n$个约束方程，$m$种人即$m$个决策变量，记为$x_i$。记每类志愿者选$k_i$人，最小化目标函数$z=\Sigma k_i c_i x_i$。</p>
<p>对于工作时间的限制,可以转化为此人在当前约束方程的系数。问题就被化归到一个标准型线规</p>
<p>代码:</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ffor(i,a,b) for(int i=a;i&lt;=b;++i) </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ld=<span class="type">double</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>,M=<span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ld EPS=<span class="number">1e-15</span>;</span><br><span class="line"><span class="type">const</span> ld INF=<span class="number">1e15</span>;</span><br><span class="line">ld ar[M][N],b[M],c[N],ans;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pivot</span><span class="params">(<span class="type">int</span> fre,<span class="type">int</span> bas)</span></span>&#123;</span><br><span class="line">    ans+=c[bas]*b[fre];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    ld t=ar[fre][bas];b[fre]/=t;</span><br><span class="line">    <span class="built_in">ffor</span>(j,<span class="number">1</span>,n)ar[fre][j]/=t;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="built_in">ffor</span>(j,<span class="number">1</span>,n)<span class="keyword">if</span>(j!=bas)c[j]-=c[bas]*ar[fre][j];</span><br><span class="line">    c[bas]*=-ar[fre][bas];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="built_in">ffor</span>(i,<span class="number">1</span>,m)<span class="keyword">if</span>(i!=fre&amp;&amp;<span class="built_in">fabs</span>(ar[i][bas])&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        t=ar[i][bas];b[i]-=t*b[fre];</span><br><span class="line">        <span class="built_in">ffor</span>(j,<span class="number">1</span>,n)<span class="keyword">if</span>(j!=bas)ar[i][j]-=t*ar[fre][j];</span><br><span class="line">        ar[i][bas]*=-ar[fre][bas];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">simplex</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="comment">// bas: 需要替换的主元 </span></span><br><span class="line">        <span class="comment">// fre: 上位的非基变量 </span></span><br><span class="line">        <span class="type">int</span> bas=<span class="number">0</span>,fre=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 系数全部非正，z取到最大值 </span></span><br><span class="line">        <span class="built_in">ffor</span>(i,<span class="number">1</span>,n)<span class="keyword">if</span>(c[i]&gt;EPS)&#123;bas=i;<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(!bas)<span class="keyword">return</span> ans;</span><br><span class="line">        <span class="comment">// mn: 最紧的上界 </span></span><br><span class="line">        ld mn=INF;</span><br><span class="line">        <span class="built_in">ffor</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ar[i][bas]&gt;EPS&amp;&amp;mn&gt;b[i]/ar[i][bas])</span><br><span class="line">            mn=b[i]/ar[i][bas],fre=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 无界 </span></span><br><span class="line">        <span class="keyword">if</span>(!fre)<span class="keyword">return</span> INF;</span><br><span class="line">        <span class="comment">//更换fre,bas的主元属性 </span></span><br><span class="line">        <span class="built_in">pivot</span>(fre,bas);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">int</span>(<span class="built_in">simplex</span>()+<span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">ffor</span>(i,<span class="number">1</span>,n)cin&gt;&gt;c[i];</span><br><span class="line">    <span class="built_in">ffor</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;cin&gt;&gt;l&gt;&gt;r&gt;&gt;b[i];</span><br><span class="line">        <span class="built_in">ffor</span>(j,l,r)ar[i][j]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">input</span>();</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

    </div>
</div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>ACM</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>筛法模板</title>
    <url>/%E7%AD%9B%E6%B3%95%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>自用筛法模板</p>
<p><br></p>
<span id="more"></span>
<p>具体的解析懒得再写了，直接把博客园里之前的一篇贴过来了</p>
<h1 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h1><h2 id="1-筛质数"><a href="#1-筛质数" class="headerlink" title="1.筛质数"></a>1.筛质数</h2><p>先看看线性筛本体，它的功能是判断质数，以及求最小质因数</p>
<p>1.记录minfactor,prime</p>
<p>2.对cur一直用prime数组筛去剩下的合数</p>
<p>这里判断质数的标准很简单，就是判断一个数的最小质因数是否就是它本身</p>
<p>由于是求最小质因数，$prime[j]&lt;=minfact[i]$,这样可以证明每个合数仅被它的最小质因数筛到，保证线性复杂度</p>
<h2 id="2-求-phi-n"><a href="#2-求-phi-n" class="headerlink" title="2.求$\phi(n)$"></a>2.求$\phi(n)$</h2><p>$\phi(p)=p-1$,利用这个性质，可在判断质数的同时筛出它的欧拉函数</p>
<p>由欧拉函数的积性性得,$\phi(mn)=\phi(m)\phi(n)$</p>
<p>当$minfact[i]=prime[j]$,即有重复质因子时，$\phi(p^k)=p^{k-1}(p-1)$,乘上p即可</p>
<p>不然乘上(p-1)</p>
<h2 id="3-求-mu-n"><a href="#3-求-mu-n" class="headerlink" title="3.求$\mu(n)$"></a>3.求$\mu(n)$</h2><p>$\mu(p)=-1$,利用这个性质，可在判断质数的同时筛出它的莫比乌斯函数</p>
<p>当$minfact[i]=prime[j]$,即有重复质因子时，$\mu(n)=0$</p>
<p>不然乘上$\mu(n)=-\mu(i)$</p>
<h2 id="4-求-d-n"><a href="#4-求-d-n" class="headerlink" title="4.求$d(n)$"></a>4.求$d(n)$</h2><p>比前面的两个函数要麻烦一些，求$d(n)$要记录n中最小质因子数$cnt[n]$</p>
<p>对于质数,$cnt[n]$很显然等于1</p>
<p>接着考虑$d(n)$,$n=\Pi^k_{i=1}p_i^{a_i}$,$d(n)=\Pi^k_{i=1}(p_i+1)$</p>
<p>如果$minfact[i]=prime[j]$,由牛顿二项式定理得，$d(n)=d(i)/(cnt[i]+1)*(cnt(i)+2)$</p>
<p>不然$d(n)=d(i)*d(prime[j])$</p>
<h2 id="5-求-sigma-n"><a href="#5-求-sigma-n" class="headerlink" title="5.求$\sigma(n)$"></a>5.求$\sigma(n)$</h2><p>类似于求$d(n)$,不过这次要记录一个数组$sum[i]=\Sigma_{i=0}^kp^i$,p表示n的最小质因数，$sum[i]$表示最小质因数的k次幂下的和</p>
<p>对于质数，$sum[i]$很显然等于p+1</p>
<p>接着考虑$\sigma(n)$,$\sigma(n)=\Pi_{i=1}^k\Sigma_{j=0}^{a_i}p^j_i$</p>
<p>如果$minfact[i]=prime[j]$,在求和式中加入一项$p^{k+1}$,等同于乘$(sum[i]*p+1)/sum[i]$</p>
<p>不然$\sigma(n)=\sigma(i)*\sigma(prime[j])$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mf 最小质因数</span></span><br><span class="line"><span class="comment">//pr 质数 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">For</span>(i,<span class="number">2</span>,LIM)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!mf[i])mf[i]=pr[++TT]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>,p;j&lt;=TT&amp;&amp;(p=pr[j]*i)&lt;=LIM;++j)&#123;</span><br><span class="line">            mf[p]=pr[j];</span><br><span class="line">            <span class="keyword">if</span>(pr[j]^mf[i]);</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//phi 欧拉函数,小于x且与x互质的数的个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">For</span>(i,<span class="number">2</span>,LIM)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!mf[i])mf[i]=pr[++TT]=i,phi[i]=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>,p;j&lt;=TT&amp;&amp;(p=pr[j]*i)&lt;=LIM;++j)&#123;</span><br><span class="line">            mf[p]=pr[j];</span><br><span class="line">            <span class="keyword">if</span>(pr[j]^mf[i])phi[p]=phi[i]*(pr[j]<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;phi[p]=phi[i]*pr[j];<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mu 莫比乌斯函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">For</span>(i,<span class="number">2</span>,LIM)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!mf[i])mf[i]=pr[++TT]=i,mu[i]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>,p;j&lt;=TT&amp;&amp;(p=pr[j]*i)&lt;=LIM;++j)&#123;</span><br><span class="line">            mf[p]=pr[j];</span><br><span class="line">            <span class="keyword">if</span>(pr[j]^mf[i])mu[p]=-mu[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;mu[p]=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dn 约数个数</span></span><br><span class="line"><span class="comment">//pn 最小质因子的次数 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dn[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">For</span>(i,<span class="number">2</span>,LIM)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!mf[i])mf[i]=pr[++TT]=i,dn[i]=<span class="number">2</span>,pn[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>,p;j&lt;=TT&amp;&amp;(p=pr[j]*i)&lt;=LIM;++j)&#123;</span><br><span class="line">            mf[p]=pr[j];</span><br><span class="line">            <span class="keyword">if</span>(pr[j]^mf[i])	dn[p]=dn[i]&lt;&lt;<span class="number">1</span>,pn[p]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;dn[p]=dn[i]/(pn[i]+<span class="number">1</span>)*(pn[i]+<span class="number">2</span>),pn[p]=pn[i]+<span class="number">1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ps 最小质因数的幂次和 </span></span><br><span class="line"><span class="comment">//s 约数和 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">For</span>(i,<span class="number">2</span>,LIM)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!mf[i])mf[i]=pr[++TT]=i,s[i]=ps[i]=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>,p;j&lt;=TT&amp;&amp;(p=pr[j]*i)&lt;=LIM;++j)&#123;</span><br><span class="line">            mf[p]=pr[j];</span><br><span class="line">            <span class="keyword">if</span>(pr[j]^mf[i])ps[p]=pr[j]+<span class="number">1</span>,s[p]=ps[i]*(pr[j]+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;ps[p]=ps[i]*pr[j]+<span class="number">1</span>,s[p]=s[i]*(ps[i]*p+<span class="number">1</span>)/ps[i];<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="杜教筛"><a href="#杜教筛" class="headerlink" title="杜教筛"></a>杜教筛</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需先筛出phi与mu</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>,ll&gt; ansmu,ansphi;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_mu</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=LIM) <span class="keyword">return</span> mu[x];</span><br><span class="line">    <span class="keyword">if</span>(ansmu.<span class="built_in">count</span>(x)) <span class="keyword">return</span> ansmu[x];</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">2</span>,r;(r&lt;(<span class="number">1</span>&lt;&lt;<span class="number">31</span>)<span class="number">-1</span>)&amp;&amp;l&lt;=x;l=r+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r=x/(x/l);</span><br><span class="line">        ans-=(r-l+<span class="number">1</span>)*<span class="built_in">get_mu</span>(x/l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ansmu[x]=ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">get_phi</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=LIM) <span class="keyword">return</span> phi[x];</span><br><span class="line">    <span class="keyword">if</span>(ansphi.<span class="built_in">count</span>(x)) <span class="keyword">return</span> ansphi[x];</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">2</span>,r;(r&lt;(<span class="number">1</span>&lt;&lt;<span class="number">31</span>)<span class="number">-1</span>)&amp;&amp;l&lt;=x;l=r+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r=x/(x/l);</span><br><span class="line">        ans+=(r-l+<span class="number">1</span>)*<span class="built_in">get_phi</span>(x/l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ansphi[x]=(ll)x*(x+<span class="number">1ll</span>)/<span class="number">2ll</span>-ans;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello world</title>
    <url>/hello-world/</url>
    <content><![CDATA[<h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><p>时隔两年，终于成功的搭建了hexo博客，中途踩坑无数，希望这是最后一个helloworld</p>
<p>博客园旧址:<a href="https://www.cnblogs.com/nebulyu/">https://www.cnblogs.com/nebulyu/</a></p>
]]></content>
      <categories>
        <category>hexo blog</category>
      </categories>
  </entry>
  <entry>
    <title>博客维护log</title>
    <url>/%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4log/</url>
    <content><![CDATA[<p>记录博客框架与功能的更新</p>
<span id="more"></span>
<h2 id="2023-12-5"><a href="#2023-12-5" class="headerlink" title="2023.12.5"></a>2023.12.5</h2><p>根据这篇文章<a href="https://zhuanlan.zhihu.com/p/138500516把主页改成了自定义页面，但是还没有添加内容">https://zhuanlan.zhihu.com/p/138500516把主页改成了自定义页面，但是还没有添加内容</a></p>
<p>打算找个好看的主页模板蒯过来</p>
<h2 id="2023-10-30"><a href="#2023-10-30" class="headerlink" title="2023.10.30"></a>2023.10.30</h2><p>加入了代码折叠功能，主要参考 <a href="https://wty-yy.space/posts/44830/">https://wty-yy.space/posts/44830/</a></p>
<p>虽然还没有把旧博文加上折叠部分。可以考虑写一个自动化程序来实现。</p>
<p>加入了代码复制功能，主要参考 <a href="https://blog.csdn.net/CodeJoker_7/article/details/123235303">https://blog.csdn.net/CodeJoker_7/article/details/123235303</a></p>
<p>博客越来越像一个成品了</p>
<h2 id="2023-10-26"><a href="#2023-10-26" class="headerlink" title="2023.10.26"></a>2023.10.26</h2><p>选取了一些OI时期写的勉强能看小作文与题解，除了加上hexo的格式和标签之外基本没有做任何更改，保留了原汁原味的童真（</p>
<p>categories界面又改成减缩版了，细节整合进tag里</p>
<p>试图给categories加一个可折叠效果，但是失败了</p>
<h2 id="2023-10-25"><a href="#2023-10-25" class="headerlink" title="2023.10.25"></a>2023.10.25</h2><p>尝试自定义home page，重定向了left bar中的home，但是没成功的重定义一进去的主页</p>
<p>将博文分类进子文件夹中，并更改了permant link，url更好看了（</p>
<p>考虑将OI时期的文章迁过来</p>
<h2 id="2023-10-24"><a href="#2023-10-24" class="headerlink" title="2023.10.24"></a>2023.10.24</h2><p>大改</p>
<p>加入了categories，并精简了tag</p>
<p>优化了left bar的导引</p>
<p>更换博客title等</p>
<p>添加了一个acm队友的友链，想做成双排的效果，但未成功</p>
<p>前面很长一段时间没有记录log，算丢失了</p>
<h2 id="2022-7-17"><a href="#2022-7-17" class="headerlink" title="2022.7.17"></a>2022.7.17</h2><p>hexo博客成功部署到github上</p>
<p>安照之前部署的操作就成功了，控制了所有变量发现只有宽带供应商换了，猜测之前没法部署的原因是湖北移动把github给墙了</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>hexo blog</category>
      </categories>
  </entry>
  <entry>
    <title>最小树形图</title>
    <url>/%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE/</url>
    <content><![CDATA[<p>最小树形图</p>
<span id="more"></span>
<h1 id="最小树形图"><a href="#最小树形图" class="headerlink" title="最小树形图"></a>最小树形图</h1><p>概念:在一个给定边的有向图中，求以一个点为根的生成树，换句话说这个图中只有一个点入度为0，其余点入度均为1,且在此基础上进行约束，如要求边权和最小等</p>
<p>首先，在最小树形图中一般要以弧的形式存图，并保存一个点的前驱</p>
<p>主体就是朱刘算法，分4个步骤</p>
<p>1.求最短弧集合</p>
<p>2.判断集合中是否有环，具体就是自己成为自己的祖先，从当前结点一直染色，直到染到根或自己 </p>
<p>3.若有环，缩点，重新求最短弧集合</p>
<p>4.统计结果输出</p>
<p>比较重要的就是缩点时的操作，据说可以用tarjan优化，日后学会了再补上</p>
<p>类似于并查集的思想，记录每个集合中的代表结点，并对所有弧进行一次修改</p>
<p>关键在于处理好改权值的问题，将每个点在环外入边的权值减去环内入边的权值，同时保留每次的统计和，只计算增量 </p>
<p>​                                                                                        ——2020.5.11</p>
<p><br></p>
<p>最重要的步骤也是最容易写错的步骤还是最后一步的减边权了，用更好理解的话说，如果一个点位于环内，一个点位于环外，那么就要将环外的点到环内的点的费用减掉环内最小的费用，也就相当于删除指向环内的点的边 而从环外点指向环内</p>
<p>顺便，由于最小树形图的求解最多进行n次，每一次至少会有m条1边待处理，复杂度$O(nm)$</p>
<h3 id="不定根最小树形图"><a href="#不定根最小树形图" class="headerlink" title="不定根最小树形图"></a>不定根最小树形图</h3><p>类似于大部分图论算法，利用虚拟源点来处理不定根问题</p>
<p>统计所有边权和，建立虚拟源点，并向原图中每个点连一条大于sum的边，避免对结果产生影响</p>
<p>原图中的根就是直接与虚拟源点相邻的点，可以在松弛时统计出来</p>
<p>例题:<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2121">http://acm.hdu.edu.cn/showproblem.php?pid=2121</a></p>
]]></content>
      <categories>
        <category>OI</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>OI线段树</title>
    <url>/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p>做了几题思维难度并不算太高的线段树题目,难点就是有巨巨巨多细节要注意.</p>
<span id="more"></span>
<h5 id="luoguP6327-https-www-luogu-com-cn-problem-P6327"><a href="#luoguP6327-https-www-luogu-com-cn-problem-P6327" class="headerlink" title="luoguP6327:https://www.luogu.com.cn/problem/P6327"></a>luoguP6327:<a href="https://www.luogu.com.cn/problem/P6327">https://www.luogu.com.cn/problem/P6327</a></h5><p>题意:每次修改一个点,求区间sin值的和<br>区间sin和的信息不可加,但可以考虑和差化积公式,</p>
<script type="math/tex; mode=display">
sin(x+v)=sin(x)cos(v)+sin(v)cos(x)
cos(x+v)=cos(x)cos(v)-sin(x)sin(v)</script><p>同时记录cos和sin值就可以转化为线段树求和.<br>由于节点的tag不能直接和子节点的和相加,需要注意每次询问时先下放标签.还有浮点运算的常数极大,下放时先判一下0,不然很容易tle.<br><br></p>
<h5 id="luoguP1471-https-www-luogu-com-cn-problem-P1471"><a href="#luoguP1471-https-www-luogu-com-cn-problem-P1471" class="headerlink" title="luoguP1471:https://www.luogu.com.cn/problem/P1471"></a>luoguP1471:<a href="https://www.luogu.com.cn/problem/P1471">https://www.luogu.com.cn/problem/P1471</a></h5><p>题意:每次修改一个点,求区间平均数和方差<br>首先是平均数的合并$a_3=(a_1n_1+a_2n_2)/(n_1+n_2)$<br>再考虑方差的更改,每次修改时可以$O(1)$的更新</p>
<script type="math/tex; mode=display">
D_1=\frac 1n\Sigma(x_i-a_1)^2\\
D_2=\frac 1n\Sigma(x_i+v-a_2)^2\\
D_2-D_1=\frac 1n\Sigma((x_i+v-a_2)^2-(x_i-a_1)^2)\\
       =\frac 1n\Sigma(v^2+a_2^2+2x_iv-2a_2v-2a_2x_i-a_1^2+2x_ia_1)\\
       =v^2+a_2^2-a_1^2-2a_2v+(2v-2a_2+2a_1)\frac 1n \Sigma x_i\\
       =v^2+a_2^2-a_1^2-2a_2v+2a_1v-2a_1a_2+2a_1^2\\
       =a_1^2+a_2^2+v^2+2a_1v-2a_2v-2a_1a_2</script><p>最后是方差的合并</p>
<script type="math/tex; mode=display">
D_1=\frac 1{n_1}\Sigma(x_1i-a_1)^2\\
D_2=\frac 1{n_2}\Sigma(x_2i-a_2)^2\\
D_3=\frac 1{n_1+n_2}\Sigma(x_i-a_3)^2\\
(n_1+n_2)D_3-D_1n_1-D_2n_2=\Sigma((x_i-a_3)^2-(x_i-a_j)^2)(j=1,2)\\
                          =\Sigma(a_3^2-a_j^2+2x_i(a_j-a_3))\\
                          =n_1(a_3^2-a_1^2)+2n_1a_1(a_1-a_3)\\
                          +n_2(a_3^2-a_2^2)+2n_2a_2(a_2-a_3)</script><p>最后特别要注意在合并方差时跨中点情况的判断,左右两段的长度应该取min(当前区间长度,询问区间长度)</p>
]]></content>
      <categories>
        <category>OI</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>群基础知识</title>
    <url>/%E7%BE%A4%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>群基础知识</p>
<span id="more"></span>
<h1 id="群"><a href="#群" class="headerlink" title="群"></a>群</h1><p>群是一个在定义运算中<strong>封闭</strong>的集合，群$G=(S,<em>)$,$S$表示群中的元素，$</em>$是一个定义于$S$中元素的二元运算,且具有以下性质</p>
<p>1.封闭性:$\forall p1,p2\in G,p1*p2\in G$</p>
<p>2.结合律:$p1<em>(p2</em>p3)=(p1<em>p2)</em>p3​$</p>
<p>3.存在单位元:$p<em>e=e</em>p=p​$</p>
<p>4.存在逆元:$p1<em>p2=p2</em>p1=e$,$p1,p2$互为逆元,且逆元唯一</p>
<p>特别的，如果G中元素满足交换律，则称其为一个阿贝尔群</p>
<p>群阶:$\mid G\mid=\mid S\mid$,集合中元素个数</p>
<p>对于运算$p1*p2​$,可简写为$p1p2​$，$p^k​$等价于$\Pi_{i=1}^kp​$</p>
<p>对于运算$p1<em>p2=p1</em>p3$,存在$p2=p3$</p>
<p>运算$(p1<em>p2)^{-1}$等于$p1^{-1}</em>p2^{-1}$</p>
<h3 id="子群"><a href="#子群" class="headerlink" title="子群"></a>子群</h3><p>集合H是G的子集，若H关于$*$封闭，则H称为G的子群</p>
<p>子群存在与全集相同的逆元和单位元</p>
<h3 id="陪集"><a href="#陪集" class="headerlink" title="陪集"></a>陪集</h3><p>对于G,它的子群H的左陪集aH定义为$\</p>
]]></content>
      <categories>
        <category>OI</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>组合数学</tag>
        <tag>群论</tag>
      </tags>
  </entry>
  <entry>
    <title>置换群的性质与burnside引理</title>
    <url>/%E7%BD%AE%E6%8D%A2%E7%BE%A4%E7%9A%84%E6%80%A7%E8%B4%A8%E4%B8%8Eburnside%E5%BC%95%E7%90%86/</url>
    <content><![CDATA[<p>置换群的性质与burnside引理</p>
<span id="more"></span>
<h1 id="置换群"><a href="#置换群" class="headerlink" title="置换群"></a>置换群</h1><p>顾名思义，由置换作为元素的群，$n=\mid S\mid$,n称为置换群G的阶,G中有$n!$个置换</p>
<p>一个置换群中的性质:</p>
<p>1.封闭性:两个置换，即映射，他们的运算结果也是一个等阶映射。</p>
<p>注意，(1 2)之类的不完整循环仅仅是缩写，只表示其他元素直射，不要误认为他们不等阶</p>
<p>2.结合律:$p1<em>(p2</em>p3)=(p1<em>p2)</em>p3$一样成立</p>
<p>3.单位元:e表示所有元素直射</p>
<p>4.逆元:就是p的反射，对于一个由对换的积表示的p</p>
<p>$p=(a1\space a2)……(ak\space an)$</p>
<p>则$p^{-1}=(ak\space an)……(a1\space a2)​$</p>
<p>置换群的重要之处在于任意有限群都与置换群同构，置换群通过元素之间的映射表示变换，即可以表示一切有限群</p>
<p>一个置换分解为对换积的奇偶性成为该置换的奇偶性，一个群中奇偶置换的个数相等，等于$1/2*n!$</p>
<h3 id="轨道-稳定化子定理"><a href="#轨道-稳定化子定理" class="headerlink" title="轨道-稳定化子定理"></a>轨道-稳定化子定理</h3><p>轨道:在G中，所有k可以映射到的点集被称为轨道，$E_k$，又称等价类</p>
<p>稳定化子:在G中，所有k为直射的置换的集合被称为稳定化子，$Z_k$,并且其为G的子群</p>
<p>$\mid Z_k\mid*\mid E_k\mid=\mid G\mid​$</p>
<p><br><br></p>
<h1 id="Burnside引理"><a href="#Burnside引理" class="headerlink" title="Burnside引理"></a>Burnside引理</h1><p>G是$N={1,2……n}$上的置换群，G在N上可引出不同的等价类，并且其个数为</p>
<p>$l=\mid G\mid^{-1} *\Sigma^{g}_{i=1}c_1(a_i)​$</p>
<p>burnside引理的严格证明较复杂，在此略去，只谈一下我的理解</p>
<p>对于同一个等价类，其中所有元素会保持在一个置换中保持相同的性质，即都作为不动点或都不作为不动点</p>
<p>关于这个公式，直接看肯定有不理解之处，只能在实践中体会</p>
<p><br><br></p>
<p>举一个例子,求n个不同的人围成一桌的方案数</p>
<p>首先，我们知道这是个圆周排列，方案数为$(n-1)!$</p>
<p>用burnside引理的角度，一共存在$n!$种方案，对于每一个方案，存在$(n-1)$个与其循环同构的置换</p>
<p>并且这$n$个循环同构的置换贡献总共为1</p>
<p>考虑这组置换中的每一个点，由于每一个点权重相等，且这组没有本质区别的置换每一次循环的格式相同</p>
<p>可以把贡献分摊在每一个点上，看成每一个点贡献为1，由于权重相等，这组置换的贡献为n，去重后为1</p>
<p><br></p>
<p>这个题非常简单，但是它揭露了几个性质:</p>
<p>1.每个点权重相等，即在统计时不会因为置换的原因而改变贡献</p>
<p>2.burnside引理要列举每一个状态，时间复杂度实际上是阶乘级的</p>
<p>3.最关键的步骤在找同构。这个题中由于是圆周，体现为循环</p>
<p>先写到这里，后面会陆续找一些例题来分析(咕咕咕</p>
]]></content>
      <categories>
        <category>OI</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>组合数学</tag>
        <tag>群论</tag>
      </tags>
  </entry>
  <entry>
    <title>OI狄利克雷卷积</title>
    <url>/%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/</url>
    <content><![CDATA[<p>一些狄利克雷卷积性质的证明</p>
<span id="more"></span>
<p>1.$\phi * I=id​$</p>
<p>可以表示成$n=\Sigma_{d\mid n}\phi(d)$</p>
<p>对于证明这类的式子，一般有以下个步骤</p>
<p>1.证明$f(1)$</p>
<p>2.证明$f(p)$</p>
<p>3.证明$f(p^k)$</p>
<p>4.证明$f(p_1^{k1}*p_2^{k2})​$</p>
<p>5.证明普遍性</p>
<p>以欧拉函数的这一性质为例</p>
<p>1.$\phi(1)=1​$,直接由定义得出</p>
<p>2.$\phi(1)=1,\phi(p)=p-1,\phi(1)+phi(p)=p​$</p>
<p>3.$\Sigma^k_{i=0}\phi(p^i)=1+\Sigma^k_{i=1}\phi(p^i)=1+\Sigma^k_{i=1}p^{i-1}<em>(p-1)=1+(p-1)</em>(p^k-1)/(p-1)=p^k​$</p>
<p>4.$p_1^{k1}<em>p_2^{k2}=\Sigma_{d1\mid p1^{k1}}\phi(d1)</em>\Sigma_{d2\mid p2^{k2}}\phi(d2)=\Sigma_{d\mid p_1^{k1}*p_2^{k2}}\phi(d)$</p>
<p>5.对于普遍的情况，依次拆成2个数利用性质4即可得出</p>
<p>即$\phi * I=id$</p>
<p>2.$\mu *I=\epsilon​$</p>
<p>这个性质并没有上面的复杂，只需要3个步骤即可证出</p>
<p>1.$\mu(1)=1,\epsilon(1)=1$,由定义得</p>
<p>2.对于一个拥有重复质因子数的数，$\mu(n)=0,\epsilon(n)=0$</p>
<p>3.对于$n=\Pi_{i=1}^kp_i$,含有i项质数的项数为n-i+1,由组合数的性质(二项式定理)可得，奇项数等于偶项数，$\mu(n)=0$</p>
<p>即$\mu *I=\epsilon$</p>
<p>3.$\mu *id=\phi$</p>
<p>由性质1，2可推出</p>
<p>4.在莫比乌斯反演中，有两条核心卷积式</p>
<p>1.$F=I*f$</p>
<p>2.$f=\mu *F$</p>
<p>2式可由1式与性质2推得，用卷积来推要比直接拆开方便理解很多</p>
]]></content>
      <categories>
        <category>OI</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>2019.11.7集训小记</title>
    <url>/2019.11.7%E9%9B%86%E8%AE%AD%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<p>上古时期的机房cs回忆录</p>
<span id="more"></span>
<h1 id="2019-11信息学竞赛娄底集训小记"><a href="#2019-11信息学竞赛娄底集训小记" class="headerlink" title="2019.11信息学竞赛娄底集训小记"></a>2019.11信息学竞赛娄底集训小记</h1><h2 id="1-开头"><a href="#1-开头" class="headerlink" title="1.开头"></a>1.开头</h2><p>​    很幸运地，我来娄底参加了此次封闭式OI集训，在此过程中我经历了许多前所未闻的事情，吃了不少苦，也收获颇丰。</p>
<h2 id="2-关于OI的理解"><a href="#2-关于OI的理解" class="headerlink" title="2.关于OI的理解"></a>2.关于OI的理解</h2><p>​    虽然以前有过一些OI经历，但在集训中我才逐渐彻底认识OI。作为竞赛，OI当然有思维难度，但与其他竞赛或普通学科不同，OI里的算法需要自己钻研和领悟。由于没有标答，只要你有分，你就是正确，与其说是考试，OI更像一种艺术创作，关于算法的抽象艺术。真正的艺术是需要一个人思考与创造的。</p>
<h2 id="3-我与OI的磨合"><a href="#3-我与OI的磨合" class="headerlink" title="3.我与OI的磨合"></a>3.我与OI的磨合</h2><p>​    在一开始，我并不习惯这种独自学习的方式，固执的按从前的方式来学习，过于依赖同伴的讨论与老师的引领，对于问题不加思索就提问，缺少自我探寻的过程，只是被动的等着老师来喂，讲多少会多少，水平提升一直有限，思路也一直局限在做过的题内。</p>
<p>​    当然，这样做一定会栽跟头。在经历的一段不适应后，我开始思考去改变。经过向教练的启迪和自我的思索，我逐渐调整了自己的学习方式。</p>
<p>​    首先，就是关于动手。OI是一门需要实践的学科，听一万遍不如自己动手写一遍代码，从前我一直认为听会了就会了，但是动起手来才发现有如此多的细节需要去注意，也因此收获了不少，代码能力相应提高，对算法也有了更深的认识。</p>
<p>​    其次，反思与总结。之前我一直没有重做写过的题的习惯，但是再看一遍代码或许可以帮助你理解调试过程中的错误，并汲取教训，更能对不太理解的算法有更深一步的认识，还能由此对算法进行拓展和更进一步的应用。</p>
<p>​    再者，得分技巧的应用。在OI中，能写正解固然好，但是往往是写不出正解的。一开始，我甚至不屑于写部分分，一心只想拿满分，但是能力不够，想写又写不出正解使人焦虑，当然就考不好。不比其他学科，就算不是完全正确的算法，在OI中也有意义。从不屑于写暴力算法到逐渐掌握常规偏分方法，其实反而提高了我的整体能力，也能拿到更高的分。</p>
<p>​    最后，也是最重要的，先想清楚再动手。以前一直是看到题不管三七二十一就直接开始编码，但这样从没有读懂题甚至没有读题就下手，写到一半又返工重做，其实是最浪费时间的，而且还会自己弄乱心态，陷入改了错，错了改的死循环。其实读懂了题，想清楚了做法，写代码的时间非常短，而且思路通畅，bug也少，便于调试，更为自己增添一份信心。</p>
<h2 id="4-关于OI的心态变化"><a href="#4-关于OI的心态变化" class="headerlink" title="4.关于OI的心态变化"></a>4.关于OI的心态变化</h2><p>​    其实从不熟悉到熟悉一件事，想法肯定会变，但是我对OI的看法确实发生了好几次大转弯。</p>
<p>最开始，我刚接触OI时，还不知道这是个竞赛，只是单纯的觉得电脑好玩，代码好帅，于是就抱着试试看的心态，上了这条“贼船”。由于以前成绩一直不错，我并没有太重视OI的思维难度，自以为很强，却连基本功都不扎实。</p>
<p>​    当然，我立马就受到打击，完全无法看懂的题目与如听天书般的算法严重的摧残了我的自信心，我几乎时快要被劝退了。但在妈妈的鼓励下，我坚持去啃，对于一个不懂的点就一直啃，直到啃懂为止。终于，我有了一些进步，也能解决一些简单的问题，又开始过分自信起来。</p>
<p>​    但是随着学习的深入，内容不断变难，再也不是一直学就能学懂的了。加上考试内容的急剧增难，有时我连一道题都写不出。一次又一次这样的挫折几乎使我放弃，但凭着对OI的热爱日益加深，我没有退缩，反而找多种方法来解决问题，不断拓展思路，渐渐开始真正地适应了OI生活。在此过程中，我的抗打击能力在不断地困难与向教练“无止境的劝退”中获得了极大的提升，思考能力和学习习惯也得到了飞升。学习OI，确实使我成为了一个更好的人。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>​    虽然前方肯定还有困难，也许比以前经历过的更为艰辛，但我相信我能撑过去，并不断提升个人能力，学习更多，更有趣，也或许更难以理解的算法，并进行自己的创造，也为自己的未来铺路。但更重要的，从开始到此刻，也到未来，学习OI都是基于我的兴趣，我为自己能坚持我喜欢的事情，并逐渐变强，在OI之路上提升自我而感到振奋。</p>
<p>​            </p>
]]></content>
      <categories>
        <category>OI</category>
        <category>游记</category>
      </categories>
      <tags>
        <tag>水文</tag>
      </tags>
  </entry>
  <entry>
    <title>2021.2.27退役感伤</title>
    <url>/2021.2.27%E9%80%80%E5%BD%B9%E6%84%9F%E4%BC%A4/</url>
    <content><![CDATA[<p>半退役时期的可怜小作文</p>
<span id="more"></span>
<h1 id="寒假小结及近期规划"><a href="#寒假小结及近期规划" class="headerlink" title="寒假小结及近期规划"></a>寒假小结及近期规划</h1><p>&emsp;这个寒假对我来说是一段非常宝贵的时间，无论是从心态调整到学习文化课的具体知识。</p>
<p><br></p>
<h2 id="竞赛的反思"><a href="#竞赛的反思" class="headerlink" title="竞赛的反思"></a>竞赛的反思</h2><p>&emsp;从初中开始，前前后后将近3年的竞赛生涯结束了，这对于我来说是一个很重要的转折点。竞赛对我整体的影响一言难尽，但在当下最重要的是完全摆脱退竞带来的不良影响。</p>
<p>&emsp;自从元旦决定退出竞赛时，我一直没有完全适应。在文化课的学习中，常常因为没有调整好心理，而导致效率底下。一开始的几天，我在晚上完全睡不着觉，更加耽误时间。经常感到颓废和迷茫，无法提起精力。过去一段时间付出了大量的心血，现在所得远少于预期，并且就这样退出，确实心有不甘。</p>
<p>&emsp;这段时间我一直在自我反思到底是哪里出了问题，但是我认为在之前的一次次比赛中我确实积累了足够的经验，也掌握了适合于自己的方法，并且全身心地投入其中，得承认客观因素确实有影响。</p>
<p>&emsp;在寒假中我不断地安慰自己，并非没有实力，也并非没有资格，有时候确实运气不佳，退出也并非一个坏选择。我也经常去外面走走散散心，但是并没有起到我预想的调整的作用。有时候我看到以前竞赛时的书籍或资料，心中还是十分感慨，以后不可能再有这样的机会去投入大把的时间做我喜欢的事情了。</p>
<p>&emsp;不过我还是慢慢接受了退役这个事实，我意识到真正影响我的不是退役这件事本身，而是自身定位的问题。很久以来我都把自己看作于一个竞赛生，放弃了很多自由与时间去追求竞赛成绩，却忘记了我一开始学习竞赛是出于爱好。退役并不意味着放弃长期的爱好，只是去除了追求奖项的功利。我思考了很多关于人生的追求和意义的问题，认识到退役并没有造成什么本质上的改变，只不过是一个小小的转折罢了，对它感叹世事是没有意义的。</p>
<p>&emsp;一开始认为退役是一个打击，现在看来其实是一个重新认识自我的机会。辛亏有这个寒假作为缓冲，我在心理上做出了很大的调整。即便如此，我知道我并没有完全放下这个心里包袱，我还是很担心开学后我的心理状态。</p>
<h2 id="文化课学习"><a href="#文化课学习" class="headerlink" title="文化课学习"></a>文化课学习</h2><p>&emsp;尽管已经做好了刚刚退役是没有办法考好的准备，期末考试的结果还是差强人意。</p>
<p>&emsp;在刚退役的一个月里，班上确实有文化课的安排，但是并不详细，也并不深入，大部分时间主要是自习。</p>
<p>&emsp;我规划了各科目的学习目标，找出以前没有做的练习册，又买了一些资料，自己刷题。效果显著，从基本不会到可以做一些题。但是对比投入全部的时间精力的文化课学生肯定有差距，考试成绩差也是预料之中。</p>
<p>&emsp;幸好有一个寒假来弥补。我把从入学时的练习册全部找出来，一本一本的刷，刷完再买缺的题，一个寒假补了很多基础知识。尽管自己确实进步飞快，但是相比大部分人肯定处于落后，并且预期长期处于落后。</p>
<p>&emsp;但是我对自己的学习能力非常有信心。竞赛教给我了很强的自学能力与自觉性，远超常规学生。并且我不怕吃苦，已经锻炼出了很强的毅力。短期看来应该败多胜少，不过在一段时间的学习后，等时间的差距稍拉平，成绩就应该比较可观了。</p>
<p>&emsp;至于来到了一个新环境，我并不觉得这有什么问题。无论是哪一批教师或学生，都不影响我做自己的事情。我不在意环境的影响。</p>
<p><br></p>
<p>&emsp;写的很杂，主要是自己的一些感想。马上就要开学了，确实有些忐忑，主要是因为对未知的恐惧。正式开学后，我相信自己能调整好。</p>
]]></content>
      <categories>
        <category>OI</category>
        <category>游记</category>
      </categories>
      <tags>
        <tag>水文</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.11.14CSP游记</title>
    <url>/2020.11.14CSP%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>上古时期的CSP游记</p>
<span id="more"></span>
<h1 id="CSP游记与总结"><a href="#CSP游记与总结" class="headerlink" title="CSP游记与总结"></a>CSP游记与总结</h1><p>&emsp;对于这次CSP我最大的感觉就是庆幸，庆幸这只是CSP，不会在更大程度上影响我后续的发展，导致直接退役。</p>
<p>&emsp;考试形式的变化直接导致原来的策略行不通，进而导致整场考试全部乱了阵脚。</p>
<p>&emsp;刚开题面，简单看了一下全卷，T1是一个大模拟，T2应该是一个数位DP，T3是一个DS，T4是一个博弈题。</p>
<p>&emsp;顺着开题，先做T1。又是日期计算的题目，从学OI开始以来最令人恐惧的东西。最直接的想法就是直接模拟，按照特殊日期分界分别处理。一开始直接累加day，发现在多组数据下直接炸飞。后来按400year，4year分别取模，中间加上是否经过100特判。刚开始用了1.5h，有一点小问题，最后要交之前有改了一个判断，过了样例。感觉要fst，结果不出所料，洛谷数据只有40分。</p>
<p>&emsp;T2出人意料的简单，一上来就按题意码了一发数位DP，发现不需要，直接判断可行性后取2的幂次减n即可，发现用longlong会炸，改成了ull，还是不够大，决定先放下，后面再继续处理。</p>
<p>&emsp;T3一看就是个DS题。看起来很像之前做过的一道离线分治题，就打了一发线段树。后来发现可以用平衡树合并解决，但是时间不够就码了一发vector替代，轻松过了大样例，却被自己的样例卡飞了。看起来复杂度并不是很对，但是并不像继续折磨这题了，只剩2h了，还有T4。说到vector，特地为了保险没开万能头，不想在头文件上出锅，结果Dev的iostream包括了vector，CCF的没有，不能编译，直接裂开。</p>
<p>&emsp;T3正解就是一个拓排，记录每个add的被调用次数。先直接乘，最后直接加完输出。</p>
<p>&emsp;T4是一个确定性问题，一开始就想到直接处理出过程序列，再扫描判断。可惜时间比较紧，代码写的很乱，最后重构了好几发都没有写对，白送的70分都拿不到。</p>
<p>&emsp;最后简单检查了一下，直接交了，自我感觉不错，但是有点慌。出考场和同学交流后发现大部分人没有做出T3T4，T1很多人也做了很久，稍微心安了一点。后面在洛谷上测了一下，40+95+0+15=150，和预期的300+差了一半。</p>
<p>&emsp;作为一名已经经过一年多训练的选手，考出这个分数是不应该的事情，甚至比去年还低。其实从能力上来看，我完全可以很轻松地拿到370分。这些题目都是在我能力范围内的，做不出来除了策略问题，还有心态问题。</p>
<p>&emsp;太久都没有做正规的模拟赛了，前一阶段时间的重点都在学一些新东西和总结更为高级的数据结构上，独立思考的时间并不多。后面还有近20天的时间，估计会有大量的模拟考和网赛，可以调整一下状态了。做题的重心也要做出改变，看看去年不会的题和noip中的高档题，保证联赛在300分以上就比较安全了。</p>
]]></content>
      <categories>
        <category>OI</category>
        <category>游记</category>
      </categories>
      <tags>
        <tag>水文</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的数学题</title>
    <url>/3768%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>luogu3768</p>
<span id="more"></span>
<h1 id="luogu3768-简单的数学题题解"><a href="#luogu3768-简单的数学题题解" class="headerlink" title="luogu3768 简单的数学题题解"></a>luogu3768 简单的数学题题解</h1><p>​    原题地址:<a href="https://www.luogu.com.cn/problem/P3768">https://www.luogu.com.cn/problem/P3768</a></p>
<p>​    题意:求</p>
<script type="math/tex; mode=display">
\Sigma_{i=1}^n\Sigma_{j=1}^n ijgcd(i,j)</script><p>​    这个式子看起来很基础，但是可以看到数据范围大于$1e8$，求和上指标又同为$n$,此题肯定有一些特殊的做法</p>
<p>​    先按照常规的套路，设</p>
<script type="math/tex; mode=display">
d=(i,j)</script><p>​    并将$d$直接提出来</p>
<script type="math/tex; mode=display">
\Sigma_{d=1}^nd^3  \Sigma_{i=1}^{n/d}\Sigma_{j=1}^{n/d}ij[(i,j)=1]</script><p>​    右边的式子用莫比乌斯函数的和式替代</p>
<script type="math/tex; mode=display">
\Sigma_{d=1}^nd^3  \Sigma_{i=1}^{n/d}\Sigma_{j=1}^{n/d}ij\Sigma_{k|(i,j)}\mu(k)</script><p>​    将$k$往左边提</p>
<script type="math/tex; mode=display">
\Sigma_{d=1}^nd^3  \Sigma_{k=1}^{n/d}k^2\mu(k)(\Sigma_{i=1}^{n/kd}i)^2</script><p>​    设右边的和式为$c$,并用$T=kd$换元</p>
<script type="math/tex; mode=display">
\Sigma_{d=1}^nd^3  \Sigma_{T=1}^n c(T)^2(T/d)^2\mu(T/d)</script><p>​    整理式子</p>
<script type="math/tex; mode=display">
\Sigma_{T=1}^nc(T)^2T^2\Sigma_{d|T}d\mu(T/d)</script><p>​    根据狄利克雷卷积的性质</p>
<script type="math/tex; mode=display">
\varphi=\mu*id</script><p>​    可以将右边的式子用$\varphi$代替</p>
<script type="math/tex; mode=display">
\Sigma_{T=1}^n c(T)^2T^2\varphi(T)</script><p>​    观察右侧的式子，可以发现$T^2\varphi(T)$是一个积性函数(两个数论函数的积仍为积性函数)，考虑处理这一部分，试图用杜教筛的式子向上套</p>
<script type="math/tex; mode=display">
g(1)S(n)=\Sigma_{i=1}^nH_i-\Sigma_{i=2}^ng(i)S(n/i)</script><p>​    其中</p>
<script type="math/tex; mode=display">
S(n)=\Sigma_{i=1}^nf(i),H=f*g,f(n)=n^2\varphi(n)</script><p>​    观察$f(n)$，$\varphi$难以直接处理，肯定要被转化掉，那就利用狄利克雷卷积中的$id=I*\varphi$,设$g(n)=1$则</p>
<script type="math/tex; mode=display">
H(n)=n^2\Sigma_{d|n}\varphi(d)=n^3</script><p>​    通过解递推方程可以发现，$\Sigma_{i=1}^nH_i$就是原式中的$c^2$,于是式子的形式就很简洁了</p>
<script type="math/tex; mode=display">
S(n)=c(n)^2-\Sigma_{i=2}^ni^2S(n/i)</script><p>​    直接代入原式求解就可以辣</p>
<p>​    小结:此题在莫反的基础上有扩展，上指标相同看似简化条件，实际上对性能要求更高。推式子时利用了狄利克雷卷积来处理$\mu$,并在最后杜教筛处理前缀和时再次利用了$\varphi$的性质，算是对数论函数关系的灵活拓展</p>
]]></content>
      <categories>
        <category>OI</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>GSS1线段树题解</title>
    <url>/GSS1%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>GSS1线段树</p>
<span id="more"></span>
<p>题目链接:<a href="https://www.luogu.com.cn/problem/SP1043">https://www.luogu.com.cn/problem/SP1043</a></p>
<p>考虑采用分治的思想来维护最大子段和，那么一个大的序列的最大子段和是怎么表示的呢？</p>
<p>想到用区间的左右端点表示这个最大子段和所在的区间，于是我们对这个区间的端点位置进行讨论。</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/40495.png" alt="img"></p>
<p>这个图表示所有端点都在左边的区间上的情况，于是把左子区间的最大子段和计入候选值。</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/40531.png" alt="img"></p>
<p>这个图表示所有端点都在右边的区间上的情况，于是把右子区间的最大子段和计入候选值。</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/40532.png" alt="img"></p>
<p>这个图表示区间左端点在左边，右端点在右边的情况，这个可以拆分成左子区间的最大后缀和加上右子区间的最大前缀和，将这个值计入候选值。</p>
<p>将这三个最大子段和的候选值去\maxmax即得该区间的最大子段和。</p>
<p>为了维护最大子段和，引进了最大前缀和和最大后缀和，所以接下来解决区间的最大前缀和和最大后缀和。</p>
<p>还是使用分治的思想，把要求的区间分成两个子区间，对前缀和的右端点进行讨论。</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/40535.png" alt="img"></p>
<p>这个图表示右端点在左边的情况，此时将左区间的最大前缀和计入候选值。</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/40536.png" alt="img"></p>
<p>这个图表示右端点在右边的情况，此时可拆分成左子区间和和右子区间的最大前缀和，将这个值计入候选值。</p>
<p>以上两个候选值取\maxmax即得到该区间的最大前缀和，最大后缀和同理。</p>
<p>维护最大前缀和与后缀和是，引入了区间和，而这个是很好完成的。</p>
<p>在查询的时候分类讨论一下，如果这个区间要拆分，那么将两个部分算出来后在合并一下就好了，所以建议大家在这一天写<strong>结构体式线段树</strong>，返回结构体就好归并啦。</p>
<p>看起来不可做，实际上还好，此题是做过的这种类型的第一题，继续</p>
]]></content>
      <categories>
        <category>OI</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>斯特林数笔记小结</title>
    <url>/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0%E7%AC%94%E8%AE%B0%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>斯特林数笔记整理</p>
<span id="more"></span>
<h1 id="斯特林数笔记整理"><a href="#斯特林数笔记整理" class="headerlink" title="斯特林数笔记整理"></a>斯特林数笔记整理</h1><p>&emsp;最近快被数学折磨疯了，具体数学上得快内容也难，在此整理一下所学的内容</p>
<h2 id="第一类斯特林数"><a href="#第一类斯特林数" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h2><p>&emsp;第一类斯特林数$\begin{bmatrix}<br>n\\<br>k<br>\end{bmatrix}$表示从$n$个元素中组成$k$个循环的方案数，此处的循环合起来构成一个与原排列对应的置换(参考置换群)。注意:循环的内部是圆周有序的，即$(a_1a_2a_3)$与$(a_2a_3a_1)$等价。</p>
<p>&emsp;从组合的意义可以得到$\begin{bmatrix}n\\k\end{bmatrix}$的递推式</p>
<script type="math/tex; mode=display">
\begin{bmatrix}n\\k\end{bmatrix}=(n-1)\begin{bmatrix}n-1\\k\end{bmatrix}+\begin{bmatrix}n-1\\k-1\end{bmatrix}</script><p>&emsp;即当前的状态可以由直接添加一个新集合与放在任意一个元素后面转移而来</p>
<p>&emsp;根据置换的性质，可以得到$\begin{bmatrix}n\\k\end{bmatrix}$与$n!$的关系</p>
<script type="math/tex; mode=display">
\Sigma_k\begin{bmatrix}n\\k\end{bmatrix}=n!</script><p>&emsp;由于任何一个置换都与一个排列一一对应，所以置换的总数与排列的总数相等</p>
<p>&emsp;第一类斯特林数还可以用与上升幂与下降幂的展开</p>
<script type="math/tex; mode=display">
X^{\overline{n}}=\Sigma\begin{bmatrix}n\\k\end{bmatrix}x^k\\
X^{\underline{n}}=\Sigma\begin{bmatrix}n\\k\end{bmatrix}(-1)^{n-k}x^k\\</script><p>&emsp;首先可以直观感性的理解一下,$X^{\underline{n}}&lt;X^n&lt;X^{\overline{n}}$,所以$X^n$转化成下降幂需要容斥，而上升幂则不用。这两个公式非常有用，直接将上升幂下降幂与自然幂联系在一起。形式上也较为简洁，类似于二项式反演。</p>
<p>&emsp;至于证明，<del>懒得写了</del>，这篇文章的大部分公式证明都可以利用数学归纳法，大概思路就是先对和式进行扰动，利用吸收公式化简式子，并提取出公因式，最后利用递推式直接导出结果。</p>
<h2 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h2><p>&emsp;相似的，第二类斯特林数$\begin{Bmatrix}n\\k\end{Bmatrix}$表示将$n$个元素划分为$k$个非空集合的方案数，可以读作”n子集k”。比起$\begin{bmatrix}n\\k\end{bmatrix}$,$\begin{Bmatrix}n\\k\end{Bmatrix}$由于其内部无序性，显然不会更大。由于组合意义更加简洁，它的出现也更为频繁。</p>
<p>&emsp;从组合的意义可以得到$\begin{Bmatrix}n\\k\end{Bmatrix}$的递推式</p>
<script type="math/tex; mode=display">
\begin{Bmatrix}n\\k\end{Bmatrix}=k\begin{Bmatrix}n-1\\k\end{Bmatrix}+\begin{Bmatrix}n-1\\k-1\end{Bmatrix}</script><p>&emsp;即当前的状态可以由直接添加一个新集合与插入任意一个已有集合转移而来</p>
<p>&emsp;第二类斯特林数由于其无序性，没有与阶乘有关的和式。但是它同样有关于上升幂下降幂与自然幂的展开式</p>
<script type="math/tex; mode=display">
X^n=\Sigma_k\begin{Bmatrix}n\\k\end{Bmatrix}x^{\underline{k}}\\
X^n=\Sigma_k\begin{Bmatrix}n\\k\end{Bmatrix}(-1)^{n-k}x^{\overline{k}}\\</script><p>&emsp;类比于上面的反演式，$-1$可以从容斥的角度来理解</p>
<p>&emsp;类似于组合数，斯特林数并不要求$n,k$均为正整数，关于有符号斯特林数也有一个优美的公式</p>
<script type="math/tex; mode=display">
\begin{bmatrix}n\\k\end{bmatrix}=\begin{Bmatrix}-k\\-n\end{Bmatrix}</script><p>&emsp;关于两类斯特林数还有许多关于组合数的求和公式，从组合意义的角度去理解比较好，证明的话除了数学归纳法其他的方式过于繁琐<del>我太菜了不会</del>，在此不赘述</p>
<h2 id="斯特林反演"><a href="#斯特林反演" class="headerlink" title="斯特林反演"></a>斯特林反演</h2><p>&emsp;就是将上面几个关于上升幂下降幂与自然幂的式子结合起来看</p>
<script type="math/tex; mode=display">
X^n=\Sigma_k\begin{Bmatrix}n\\k\end{Bmatrix}x^{\underline{k}}\\
X^n=\Sigma_k\begin{Bmatrix}n\\k\end{Bmatrix}(-1)^{n-k}x^{\overline{k}}\\
X^{\overline{n}}=\Sigma\begin{bmatrix}n\\k\end{bmatrix}x^k\\
X^{\underline{n}}=\Sigma\begin{bmatrix}n\\k\end{bmatrix}(-1)^{n-k}x^k\\</script><p>&emsp;得到</p>
<script type="math/tex; mode=display">
g(n)=\Sigma_k(-1)^{n-k}\begin{bmatrix}n\\k\end{bmatrix}f(k)\\
f(n)=\Sigma_k\begin{Bmatrix}n\\k\end{Bmatrix}g(k)\\</script><p>&emsp;证明的话把式子一层层剥开，直接交换顺序组合在一起就是了。</p>
<p><br></p>
<p><br></p>
<p>&emsp;目前并没有做过很多利用斯特林数性质的题，<del>一题都不会做</del>，基本也是和组合数中的求和式扯在一起。以后会慢慢收集一些题再归纳整理。</p>
]]></content>
      <categories>
        <category>OI</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>OI莫反总结</title>
    <url>/OI%E8%8E%AB%E5%8F%8D%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>莫比乌斯反演小结</p>
<span id="more"></span>
<h1 id="莫比乌斯反演小结"><a href="#莫比乌斯反演小结" class="headerlink" title="莫比乌斯反演小结"></a>莫比乌斯反演小结</h1><p>​    最近做了一点莫反的简单题目，虽然式子的推导并不算很复杂，但是没有见过肯定想不出来。感觉莫反非常需要技巧，在此总结一下翻过的车和学到的思路。写的非常简单，后面做了更多的题目可能会新增。</p>
<h2 id="1-求和顺序的改变"><a href="#1-求和顺序的改变" class="headerlink" title="1.求和顺序的改变"></a>1.求和顺序的改变</h2><p>​    虽然这一步看起来没有什么技术含量，对元素的顺序改变也不影响结果，但是对于人来说推式子时思路更清晰。如果内层函数较为复杂新设函数单独求解。</p>
<h2 id="2-换元法"><a href="#2-换元法" class="headerlink" title="2.换元法"></a>2.换元法</h2><p>​    换元是最为常用的一种基本方法，主要体现在用积或商替换原来的式子，实现求和式中下标与限制条件之间的运算与求和式与狄利克雷卷积式之间的转换</p>
<p>​    下标转换最为典型的应用就是在$\Sigma_{i=1}^n \Sigma_{j=1}^m[(i,j)=k]$中将$i,j$换为$it<em>k,jt</em>k$,从而消去k，转化为更简洁的形式$\Sigma_{i=1}^{n/k} \Sigma_{j=1}^{m/k}[(i,j)=1]$</p>
<p>​    此外，在某些情况下，换元法可以进行加速，如:YY的GCD<a href="https://www.luogu.com.cn/problem/P2257.此处的换元法将嵌套的函数拆开，虽然看起来更复杂了，却可以利用其加速">https://www.luogu.com.cn/problem/P2257.此处的换元法将嵌套的函数拆开，虽然看起来更复杂了，却可以利用其加速</a></p>
<h2 id="3-约数和转前缀和"><a href="#3-约数和转前缀和" class="headerlink" title="3.约数和转前缀和"></a>3.约数和转前缀和</h2><p>​    这也是一个非常常规的操作，主要用于处理由元函数得出的式子,比如$[(i,j)=1]=&gt; \Sigma_{d|(i,j)}\mu(d)$,此时枚举d，将式子变换为$\Sigma_{d=1}^n\mu(d)$,并改变$i,j$的枚举策略</p>
<h2 id="4-对于-varphi-的应用"><a href="#4-对于-varphi-的应用" class="headerlink" title="4.对于$\varphi$的应用"></a>4.对于$\varphi$的应用</h2><p>​    虽然叫莫比乌斯反演，但是$\varphi$的某些性质使得它可以大幅度的优化求解，比如<a href="https://www.luogu.com.cn/problem/P2568。">https://www.luogu.com.cn/problem/P2568。</a></p>
<p>​    $\varphi$的处理可以直接起飞，但是限制较多，目前看来只有下标限制相同的求和才可以转为求$\varphi$,本质也是利用狄利克雷卷积的性质</p>
]]></content>
      <categories>
        <category>OI</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>快速沃尔什变换</title>
    <url>/%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<p>还是逃不掉多项式啊</p>
<p><br></p>
<span id="more"></span>
<h1 id="快速沃尔什变换"><a href="#快速沃尔什变换" class="headerlink" title="快速沃尔什变换"></a>快速沃尔什变换</h1><p>对于一个位运算的卷积，即形式为$c_i=\Sigma a_j b_k [i==g(j,k)]$的求和，一般最简单最暴力的做法是遍历求和。</p>
<p>对于一个映射$f$，有</p>
<script type="math/tex; mode=display">
A\rightarrow f(A)\\
B\rightarrow f(B)\\
f(C)=f(A)*f(B) \Leftrightarrow f(c_i)=f(a_i)*f(b_i)\\
f(C)\rightarrow C</script><p>即找到一种变换，使得能将卷积等效为点乘，并且确定这个变换的逆变换，就可以用这个方法实现卷积。</p>
<p>数组点乘的复杂度是线性的，而遍历一个数组也至少是线性的，这个过程的主要复杂度就在变换和逆变换中。如果能找到一个优化的方法求出映射$f$与逆映射$f^{-1}$，就可以对卷积进行优化。</p>
<p><br></p>
<h2 id="or卷积"><a href="#or卷积" class="headerlink" title="or卷积"></a>or卷积</h2><p>卷积$c_i=\Sigma a_j b_k [i==(j|k)]$，可以发现对$c_i$有共献的下标$j,k$一定是$c_i$在二进制下的子集。</p>
<p>记$f(a_i)$是$A$中下标$i$的子集之和，求$f(A)$就变成了子集枚举问题。同样，如果要求逆，对$f(a_i)$做子集容斥就能得到$a_i$。</p>
<p>如果暴力去枚举子集，那和$n^2$暴力没什么区别。考虑用位运算子集的性质进行加速。最典型想法的就是fft中的奇偶分治，这里也可以套用。</p>
<p>$A\rightarrow f(A)$的过程是一个典型的折半分治，用沃尔什变换处理or卷积的时间复杂度是$O(nlogn)$的。</p>
<p>代码实现:</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逆运算:op=-1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FWT_or</span><span class="params">(ll *a,ll *f,<span class="type">int</span> op=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">ffor</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)f[i]=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;n;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>;p&lt;n;p+=(mid&lt;&lt;<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k)</span><br><span class="line">    f[mid+p+k]=(f[mid+p+k]+op*f[p+k]+P)%P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<p><br></p>
<h2 id="and卷积"><a href="#and卷积" class="headerlink" title="and卷积"></a>and卷积</h2><p>卷积$c_i=\Sigma a_j b_k [i==(j\&amp;k)]$，可以发现对$c_i$有共献的下标$j,k$一定是$c_i$在二进制下的超集。</p>
<p>同样的思路，记$f(a_i)$是$A$中下标$i$的超集之和，求$f(A)$就变成了补集枚举问题，本质上也是一个子集枚举。用沃尔什变换处理and卷积的时间复杂度也是$O(nlogn)$的。这个和or卷积写法都差不多</p>
<p>代码实现:</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FWT_and</span><span class="params">(ll *a,ll *f,<span class="type">int</span> op=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">ffor</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)f[i]=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;n;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>;p&lt;n;p+=(mid&lt;&lt;<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k)</span><br><span class="line">    f[p+k]=(f[p+k]+op*f[mid+p+k]+P)%P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<p><br></p>
<h2 id="xor卷积"><a href="#xor卷积" class="headerlink" title="xor卷积"></a>xor卷积</h2><p>卷积$c_i=\Sigma a_j b_k [i==(j\oplus k)]$。异或不能像与和或那样简单地用子集关系表示，需要挖掘其他的性质。</p>
<p>考虑异或整体后的结果，似乎看不出来什么规律。拆位来看，若$i,j,k$表示当前bit的状态，则有$(i\&amp;j)\oplus(i\&amp;k)=i\&amp;(j\oplus k)$，即位运算的分配律。</p>
<p>将这个关系推广到一个整数，同样是成立的。记$i \circ j=popcount(i\&amp;j)\equiv 1 (mod 2)$，即两者与后bit数的奇偶性。存在</p>
<script type="math/tex; mode=display">
(i\circ j)\oplus(i\circ k)=i\circ(j\oplus k)</script><p>记$f(a_i)$是$A$中与下标$i$异或和bit数为偶数减去异或和bit数为奇数的和，即</p>
<script type="math/tex; mode=display">
f(a_i)=\Sigma a_j[i\oplus j \equiv 0(mod 2)]-\Sigma a_j[i\oplus j \equiv 1(mod 2) ]</script><p>在这个映射中，$f(a_i)f(b_i)$相乘后，套用上述性质，发现$f(c_i)$符合性质。</p>
<p>这个东西更像fft了，也可以用蝴蝶操作来优化。逆运算也同fft。异或卷积的时间复杂度是$O(nlogn)$级别的。</p>
<p>代码实现:</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FWT_xor</span><span class="params">(ll *a,ll *f,<span class="type">int</span> op=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">ffor</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)f[i]=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;n;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>;p&lt;n;p+=(mid&lt;&lt;<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k)&#123;</span><br><span class="line">        ll a0=f[p+k],a1=f[mid+p+k];</span><br><span class="line">        f[p+k]=(((a0+a1)*op)%P+P)%P;</span><br><span class="line">        f[mid+p+k]=(((a0-a1)*op)%P+P)%P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<p><br></p>
<h2 id="xnor卷积"><a href="#xnor卷积" class="headerlink" title="xnor卷积"></a>xnor卷积</h2><p>卷积$c_i=\Sigma a_j b_k [i==(j xnor k)]$。同或是异或的对偶运算，当两者相同时取1。</p>
<p>同或也具有类似上述的性质，可以使用相同的思路来做，代码也是差不多的。</p>
<p>代码实现:</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FWT_xnor</span><span class="params">(ll *a,ll *f,<span class="type">int</span> op=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">ffor</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)f[i]=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;n;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>;p&lt;n;p+=(mid&lt;&lt;<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k)&#123;</span><br><span class="line">        ll a0=f[p+k],a1=f[mid+p+k];</span><br><span class="line">        f[p+k]=(((a0-a1)*op)%P+P)%P;</span><br><span class="line">        f[mid+p+k]=(((a0+a1)*op)%P+P)%P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<p><br></p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>暂时鸽了（</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>ACM</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>多项式全家桶</title>
    <url>/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%85%A8%E5%AE%B6%E6%A1%B6/</url>
    <content><![CDATA[<p>多项式全家桶</p>
<p><br></p>
<span id="more"></span>
<h1 id="多项式乘法"><a href="#多项式乘法" class="headerlink" title="多项式乘法"></a>多项式乘法</h1><p>多项式乘法$CX=AX\times BX$中的系数满足加法卷积$c_i=\Sigma a_j b_k [i==j+k]$，可以将一个乘法看作卷积，反之也是。</p>
<p>一般来说，多项式直接相乘的时间复杂度都是$O(n^2)$级别的，使用压位等技巧也只能做到常数上的优化，面对更大的数据规模就捉襟见肘了。</p>
<p>既然是卷积，就可以考虑卷积通用的方法进行优化。如果能找到映射$f$,使得在$f$下点乘的性质成立，并且可求逆运算，即</p>
<script type="math/tex; mode=display">
A\rightarrow f(A)\\
B\rightarrow f(B)\\
f(C)=f(A)*f(B) \Leftrightarrow f(c_i)=f(a_i)*f(b_i)\\
f(C)\rightarrow C</script><p>就有可能找到更好的做法。</p>
<p><br></p>
<h2 id="快速傅里叶变换"><a href="#快速傅里叶变换" class="headerlink" title="快速傅里叶变换"></a>快速傅里叶变换</h2><p>傅里叶变换是一个物理上的方法，虽然他们名字相同，但是不明白他和这个过程有什么使用上的联系。得知复数单位根有着优良的性质，<del>自然想到要用他来优化多项式乘法</del></p>
<script type="math/tex; mode=display">
\omega_n^k=-\omega_n^{k+n/2}\\
\omega_n^{2k}=\omega_{n/2}^{k}</script><p>对于多项式</p>
<script type="math/tex; mode=display">
f(x)=\Sigma_0^n c_i x_i \\
(n=2^k)</script><p>可以把他进行奇偶分解，记奇偶子式分别为$h(x),g(x)$</p>
<script type="math/tex; mode=display">
f(x)=\Sigma_0^n c_i x_i\\
=\Sigma c_j x_j + x \Sigma c_k x_k\\
(j\&2 = 0 ,k\&2 = 1)\\
=g(x)+xh(x)</script><p>代入$x_i=\omega_n^i$，</p>
<script type="math/tex; mode=display">
f(\omega)=g(\omega^2)+\omega h(\omega^2)</script><p>这个求$f$的过程是典型的折半递归，得到了一个时间复杂度为$O(nlogn)$的求解法。求出了映射$A\rightarrow f(A)$，可以在线性的时间内实现点乘，接下来考虑逆变换$f(C)\rightarrow C$。</p>
<p>如果把dft过程看作一个矩阵乘法，那么idft就是矩阵的逆。其实用一个更好理解的想法，再次代入$\omega^{-1}$就逆映射。需要注意，直接代入求得的并不是原序列，由线代的知识可知，$A^{-1}=\frac{A^*}{|A|}$，需要再除以序列的长度n。</p>
<p>代码:</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//op=1 or -1 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fft</span><span class="params">(<span class="type">int</span> n,cpl *a,<span class="type">int</span> op)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//奇偶分类</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i+=<span class="number">2</span>)temp[i/<span class="number">2</span>]=a[i],</span><br><span class="line">    temp[i/<span class="number">2</span>+n/<span class="number">2</span>]=a[i+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">ffor</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)a[i]=temp[i];</span><br><span class="line">    <span class="comment">//分治 </span></span><br><span class="line">    <span class="built_in">fft</span>(n/<span class="number">2</span>,a,op),<span class="built_in">fft</span>(n/<span class="number">2</span>,a+n/<span class="number">2</span>,op);</span><br><span class="line">    <span class="comment">//合并 </span></span><br><span class="line">    cpl Wn=&#123;<span class="built_in">cos</span>(<span class="number">2.0</span>*PI/n),<span class="built_in">sin</span>(<span class="number">2.0</span>*PI/n)*op&#125;,w=<span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,nl=n/<span class="number">2</span>;i&lt;nl;++i,w=w*Wn)&#123;</span><br><span class="line">        cpl t1=a[i],t2=w*a[i+nl];</span><br><span class="line">        a[i]=t1+t2;</span><br><span class="line">        a[i+nl]=t1-t2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mult</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">fft</span>(n,a1,<span class="number">1</span>),<span class="built_in">fft</span>(n,a2,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">ffor</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)a3[i]=a1[i]*a2[i];</span><br><span class="line">    <span class="comment">//求逆，补精度</span></span><br><span class="line">    <span class="built_in">fft</span>(n,a3,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">ffor</span>(i,<span class="number">0</span>,nout)a3[i]=<span class="built_in">int</span>(a3[i].<span class="built_in">real</span>()/n+<span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<p><br></p>
<h2 id="迭代fft"><a href="#迭代fft" class="headerlink" title="迭代fft"></a>迭代fft</h2><p>考虑在$f(a_i)$中所有有贡献的元素，可以发现他们的下标都等于$i&gt;&gt;k$。在$f(\omega)=g(\omega^2)+\omega h(\omega^2)$划分递归的过程，x也在作二进制下的右移。</p>
<p>如果能提前得到在$f(a_i)$所涉及的位置，就不需要递归，可以剩下栈开销与优化常数。</p>
<p>自底而顶地合并元素，可以发现当$i=rev[i]$时，满足fft的性质，其中</p>
<script type="math/tex; mode=display">
rev[i]=rev[i/2]/2+(i\&1)*n/2;</script><p>代码:</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//op=1 or -1 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fft</span><span class="params">(cpl *a,<span class="type">int</span> op)</span></span>&#123;</span><br><span class="line">    <span class="comment">//奇偶分类</span></span><br><span class="line">    <span class="built_in">ffor</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)<span class="keyword">if</span>(i&lt;rev[i])<span class="built_in">swap</span>(a[i],a[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;n;mid&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        cpl Wn=&#123;<span class="built_in">cos</span>(PI/mid),<span class="built_in">sin</span>(PI/mid)*op&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>;p&lt;n;p+=(mid&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">            cpl w=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k,w=w*Wn)&#123;</span><br><span class="line">                cpl t1=a[p+k],t2=w*a[mid+p+k];</span><br><span class="line">                a[p+k]=t1+t2;</span><br><span class="line">                a[mid+p+k]=t1-t2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<p><br></p>
<h2 id="快速数论变换"><a href="#快速数论变换" class="headerlink" title="快速数论变换"></a>快速数论变换</h2><p>fft使用了复数，有运行常数和精度的劣势，<del>而且许多题目要对998244353取模</del>，一个基于整数的变换算法会更合适。</p>
<p>由数论知识可知，对某些质数$P$，存在原根$g$，使得</p>
<script type="math/tex; mode=display">
g_n^k=-g_n^{k+n/2}(mod P)\\
g_n^{2k}=g_{n/2}^{k}(mod P)</script><p>那么就可以利用类似于上述的过程来得到变换</p>
<p>代码:</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ntt</span><span class="params">(ll *a,<span class="type">int</span> op)</span></span>&#123;</span><br><span class="line">    <span class="comment">//奇偶分类</span></span><br><span class="line">    <span class="built_in">ffor</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)<span class="keyword">if</span>(i&lt;rev[i])<span class="built_in">swap</span>(a[i],a[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;n;mid&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        ll Wn=<span class="built_in">fsp</span>((op==<span class="number">1</span>?G:Gi),(P<span class="number">-1</span>)/(mid&lt;&lt;<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>;p&lt;n;p+=(mid&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">            ll w=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;++k,w=w*Wn%P)&#123;</span><br><span class="line">                ll t1=a[p+k],t2=w*a[mid+p+k]%P;</span><br><span class="line">                a[p+k]=(t1+t2)%P;</span><br><span class="line">                a[mid+p+k]=(t1-t2+P)%P;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mult</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">ntt</span>(a1,<span class="number">1</span>),<span class="built_in">ntt</span>(a2,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">ffor</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)a3[i]=a1[i]*a2[i]%P;</span><br><span class="line">    <span class="built_in">ntt</span>(a3,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">ffor</span>(i,<span class="number">0</span>,nout)a3[i]=a3[i]*<span class="built_in">fsp</span>(n)%P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<p><br><br></p>
<h1 id="多项式运算"><a href="#多项式运算" class="headerlink" title="多项式运算"></a>多项式运算</h1><h2 id="求导，积分"><a href="#求导，积分" class="headerlink" title="求导，积分"></a>求导，积分</h2><p>对于一个多项式函数，求导和积分的原理都非常简单。在计算机中的实现就是移动项并变换相应系数。<br>在ntt的做法中，可以预处理阶乘和逆阶乘。</p>
<p>代码:</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll fac[N],ifac[N];</span><br><span class="line"><span class="comment">//取k阶导或求k次积分</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">deviate</span><span class="params">(ll *a,<span class="type">int</span> n,<span class="type">int</span> k=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">ffor</span>(i,<span class="number">0</span>,n-k<span class="number">-1</span>)a[i]=a[i+k]*fac[i+k]%P*ifac[i]%P;</span><br><span class="line">    <span class="keyword">return</span> n-k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">integrate</span><span class="params">(ll *a,<span class="type">int</span> n,<span class="type">int</span> k=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">rfor</span>(i,n<span class="number">-1</span>,<span class="number">0</span>)a[i+k]=a[i]*ifac[i+k]%P*fac[i]%P;</span><br><span class="line">    <span class="built_in">ffor</span>(i,<span class="number">0</span>,k<span class="number">-1</span>)a[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> n+k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=ifac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">ffor</span>(i,<span class="number">1</span>,N<span class="number">-1</span>)fac[i]=fac[i<span class="number">-1</span>]*i%P;</span><br><span class="line">    ifac[N<span class="number">-1</span>]=<span class="built_in">fsp</span>(fac[N<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">rfor</span>(i,N<span class="number">-1</span>,<span class="number">1</span>)ifac[i<span class="number">-1</span>]=ifac[i]*i%P;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

    </div>
</div>
<p><br></p>
<h2 id="求逆"><a href="#求逆" class="headerlink" title="求逆"></a>求逆</h2><p>$F(x)$的多项式逆元定义为$F(x)G(x)\equiv 1 (mod x^n)$。这个逆元只针对原多项式长度范围内的部分，对于乘积超出的部分直接忽略。</p>
<p>考虑递归求解。在递归边界$n=1$，$G_0=f_0^{-1}$。</p>
<p>在模$x^{\frac{n}{2}}$的意义下，定义$F(X)$的逆多项式$H(x)$。$H(x)$通过递归逐次求解。</p>
<script type="math/tex; mode=display">
F(x)H(x)\equiv 1(mod x^{\frac{n}{2}})\\
F(x)G(x)\equiv 1(mod x^n)\\
\downarrow \\
F(x)(H(x)-G(x))\equiv 0(mod x^{\frac{n}{2}})\\
H(x)-G(x)\equiv 0(mod x^{\frac{n}{2}})</script><p>可以看出，在低位$x^{\frac{n}{2}}$以下，$H(X)=G(X)$，即$H(X)$就是$G(X)$的低位部分。至于高位部分，考虑平方</p>
<script type="math/tex; mode=display">
G^2(x)\equiv 2H(X)G(x)-H^2(x)(mod x^n)\\
F(x)*G^2(x)\equiv F(x)*2H(x)G(x)-F(x)*H^2(x)(mod x^n)\\
\downarrow \\
G(x)\equiv 2H(x)-F(x)*H^2(x)(mod x^n)</script><p>这样，通过$\frac{n}{2}$项式$H(X)$，就可以得到$n$项式$G(X)$。</p>
<p>根据fft的经验，二进制分治的递归可以改写成迭代，求逆也可以改用迭代，这样时空开销更小。</p>
<p>代码:</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// n:多项式f原长度</span></span><br><span class="line">ll inv_f[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">poly_inv</span><span class="params">(ll *f,ll *g,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">ffor</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)g[i]=<span class="number">0</span>;g[<span class="number">0</span>]=<span class="built_in">fsp</span>(f[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(ll len=<span class="number">1</span>;len&lt;(n&lt;&lt;<span class="number">1</span>);len&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        ll lim=len&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">ffor</span>(i,<span class="number">0</span>,lim<span class="number">-1</span>)inv_f[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">ffor</span>(i,<span class="number">0</span>,len<span class="number">-1</span>)inv_f[i]=f[i];</span><br><span class="line">        <span class="built_in">ntt</span>(inv_f,lim),<span class="built_in">ntt</span>(g,lim);</span><br><span class="line">        <span class="built_in">ffor</span>(i,<span class="number">0</span>,lim<span class="number">-1</span>)g[i]=(P+<span class="number">2ll</span>-inv_f[i]*g[i]%P)%P*g[i]%P;</span><br><span class="line">        <span class="built_in">ntt</span>(g,lim,<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">ffor</span>(i,len,lim<span class="number">-1</span>)g[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<p><br></p>
<h2 id="开根"><a href="#开根" class="headerlink" title="开根"></a>开根</h2><p>$F(x)$的根式定义为$G^2(x)\equiv F(x) (mod x^n)$。按照求逆的套路，考虑分治合并。</p>
<p>当$H(x)$是$F(x)$在一半长度下的根式</p>
<script type="math/tex; mode=display">
H(x)\equiv G(x)(mod x^{\frac{n}{2}})\\
H(x)-G(x)\equiv 0(mod x^{\frac{n}{2}})\\
(H(x)-G(x))^2\equiv 0(mod x^n)\\
\downarrow \\
G^2(x)+H^2(x)-2G(x)H(x)\equiv 0(mod x^n)\\
F(x)+H^2(x)-2G(x)H(x)\equiv 0(mod x^n)\\
\frac{F(x)+H^2(x)}{2H(x)}\equiv G(x)(mod x^n)\\</script><p>递归，求$H(x)$的逆元，就可由半长根式得全长根式</p>
<p>代码:</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll sqrt_f[N],sqrt_inv[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">poly_sqrt</span><span class="params">(ll *f,ll *g,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">ffor</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)g[i]=<span class="number">0</span>;g[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll len=<span class="number">1</span>;len&lt;(n&lt;&lt;<span class="number">1</span>);len&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        ll lim=len&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">ffor</span>(i,<span class="number">0</span>,lim<span class="number">-1</span>)sqrt_f[i]=sqrt_inv[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">ffor</span>(i,<span class="number">0</span>,len<span class="number">-1</span>)sqrt_f[i]=f[i];</span><br><span class="line">        <span class="built_in">poly_inv</span>(g,sqrt_inv,len);</span><br><span class="line">        <span class="built_in">ntt</span>(sqrt_f,lim),<span class="built_in">ntt</span>(sqrt_inv,lim);</span><br><span class="line">        <span class="built_in">ffor</span>(i,<span class="number">0</span>,lim<span class="number">-1</span>)sqrt_f[i]=sqrt_inv[i]*sqrt_f[i]%P;</span><br><span class="line">        <span class="built_in">ntt</span>(sqrt_f,lim,<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">ffor</span>(i,<span class="number">0</span>,len<span class="number">-1</span>)g[i]=(sqrt_f[i]+g[i])%P*inv2%P;</span><br><span class="line">        <span class="built_in">ffor</span>(i,len,lim<span class="number">-1</span>)g[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
</div>
<p><br></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>ACM</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>ccpc2023深圳游记</title>
    <url>/ccpc2023%E6%B7%B1%E5%9C%B3%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>第一次xcpc线下赛。箱子酱全程鞭打，忠实奴仆被迫营业。</p>
<span id="more"></span>
<h2 id="2023-11-10"><a href="#2023-11-10" class="headerlink" title="2023.11.10"></a>2023.11.10</h2><p>之前看到机房里有人把oiwiki和oeis打出来了，感觉很能增强信心，于是也搞了一份。不想背太重的包，天真的认为拖着会比背着容易，就临时买了一个小箱子。</p>
<p>火车订的绿皮，晚上上车早上到。很久没有坐过卧铺了，床铺有些压抑，很难直起腰，摇晃的车厢，如摇篮般催眠。</p>
<p>香烟和槟榔的气味交织于空气，陌生的老人与青年坐在床边闲侃国事。半掩着的窗帘外漆黑一片，偶尔闪过文明的亮光，阴影与霓虹交相起舞。</p>
<p>很久没有走出校园了。许多异质的生活在这里相遇，带来一种强烈的不真实感。</p>
<p>一种期待与焦虑刺痛着神经，不过最后终于是睡着了。</p>
<p><br></p>
<h2 id="2023-11-11"><a href="#2023-11-11" class="headerlink" title="2023.11.11"></a>2023.11.11</h2><p>深圳温暖而湿润的空气使我有些忘却了比赛的烦恼，找到了旅游的心情。</p>
<p>东道主的财力一眼可见，偌大的体育场，宽广的校区。只不过如果拖着一个箱子，这些都会变成一种肉体与精神上的巨大折磨，不禁对社畜这个词中的畜有深痛的理解。</p>
<p>纪念品很有心，一人一个咖啡杯，若干速溶咖啡，应该是爆了大金币的。</p>
<p>下午的热身赛是最大的噩梦。签到题被卡思路，并且写了也没对。赛机只提供Ubuntu，并不习惯vscode写cpp，并且鼠标的滚轮还是反的。两个小时几乎纯罚坐，下来发现手心里都是汗。热身基本都是我在写题，心态几乎崩坏，好在队友看来不太在意。</p>
<p>高中同学也来了，但是他只有自费的选项。以为面基了会聊很久，见了面发现除了像以前一样插科打诨，并没有太多要说的。</p>
<p><br></p>
<h2 id="2023-11-12"><a href="#2023-11-12" class="headerlink" title="2023.11.12"></a>2023.11.12</h2><p>过早在酒店下吃的肠粉，小店的价格放在武汉长沙都不算贵，看来深圳郊区还是属于普通广东人。</p>
<p>以下为流水记账<del>全篇不都是么</del>，更清晰的赛况，正解及补题请移步<a href="https://www.cnblogs.com/luckyblock/p/17833972.html">https://www.cnblogs.com/luckyblock/p/17833972.html</a></p>
<p>开场比较顺利，A，F，G口一下写一下调一下就过了，没有dirty，跟榜稳定。</p>
<p>L一看是数学题，就自己啃了。一开始的思路是记录第$n$次第$k$层的期望结点数，每次整行转移，时间复杂度$O(n^2)$。</p>
<p>观察期望的系数，发现满足第一类斯特林数的规律。考虑利用这个得到递推关系，展开化简后得到一个漂亮的式子。写了一发，发现样例没过。又重新推一遍，发现一个小问题，斯特林数中$\begin{bmatrix}0\\k\end{bmatrix}$并不等于0，而是等于1，递推式中有一个求和式被错误的消去了。</p>
<p>陷入了沉思，开始反复检查。刚好队友口了I题的思路，就被赶下机了。调整了一会，学弟有个新的思路，不在一个变量上反复折磨，记录两个状态互相转移。推了一下发现正确性很可靠，码了一发超时了，卡了一下常就过了。</p>
<p>在我的处刑结束后，箱子里的oiwiki终于不服众望，让我们用泼辣肉高效的过了因式分解。过掉I的那一刻，我觉得这几天的折磨没有付诸东流，比过L题更狂喜。</p>
<p>最后5题，rank54，拿了比较稳定的银。</p>
<p>再次表扬主办方，一人一个银牌确实非常明智，挂气球的小摆饰也很可爱。汉堡吃撑了，冰咖啡很贴心。对这个学校留下的都是好印象。</p>
<p>感谢队友的信任和支持。热身赛彻底糜烂，导致正赛不太敢写。主要都是luckyblock完成的程序，刚刚做完手术就承压，他能保持乐观和稳定真是令我心服。学弟dztlb口题能力一流，也肯写码农题，我拉他打xcpc绝对是一个正确的选择。</p>
<p>赛事结束后彻底精疲力尽，没带角膜镜加过度用眼导致视力基本归零。也许深圳的街区车水马龙，我却只能看见一些色斑。箱子交给学弟拿了一会儿，觉得舒服多了。</p>
<p><br></p>
<p>半个月后就是合肥场了，前路难料，但手上有银，还有可靠的队友，总觉得是踏实的。希望下次的箱子里的oiwiki也能像这样有用，为箱奴找到一点赢的借口。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>ACM</category>
        <category>游记</category>
      </categories>
      <tags>
        <tag>水文</tag>
      </tags>
  </entry>
  <entry>
    <title>icpc2023合肥游记</title>
    <url>/icpc2023%E5%90%88%E8%82%A5%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>发烧友你们好（</p>
<span id="more"></span>
<h2 id="2023-11-24"><a href="#2023-11-24" class="headerlink" title="2023.11.24"></a>2023.11.24</h2><p>上一次去深圳坐绿皮体验极差，于是这次选择了高铁。箱子有三个人轮换分担，体验好了很多。</p>
<p>火车北上经过武汉，过家门而不归。黄昏时分，夕阳缓缓沉没于江面，辉光反射在熟悉的街道和建筑上。离放假还有差不多两个月，不知道何时才能睡在家里的床上。</p>
<p>下了车顿觉寒气逼人难以忍受，好在火车站离学校不远，地铁也方便。</p>
<p>酒店附近小吃不少，主要是淮南牛羊肉汤为主，应该是当地的特色了。第一次尝试了毛蛋，发现味道不错。当地的水果店里也不贵，科带同学的生活水平还是很值得羡慕的。</p>
<p><br></p>
<h2 id="2023-11-25"><a href="#2023-11-25" class="headerlink" title="2023.11.25"></a>2023.11.25</h2><p>主办方发放的冲锋衣质量不错，不过保暖效果一般。华为举办的小活动都还有意思，也拿到了奖品。</p>
<p>和高中的好朋友面基了，一起参观了科带的校史馆。这次是他xcpc生涯的终点了，希望他能有满意的结局。见面过的高中同学变化都不怎么明显，除了统一留了长发。</p>
<p>下午的热身赛签了到就跑了，拿着没用完的校园卡买了上百元的文创，狠狠的爆了科大的金币。</p>
<p>晚上去蹭了华为的讲座，顺了一盒炸鸡走了。路上闻到一家超级香的羊肉汤，于是羊汤配炸鸡，差不多把一整盒吃完了。优秀的新吃法get。</p>
<p><br></p>
<h2 id="2023-11-26"><a href="#2023-11-26" class="headerlink" title="2023.11.26"></a>2023.11.26</h2><p>赛时头脑发昏，以下记录毫无逻辑，时序可能混乱。更清晰的经历请移步<a href="https://www.cnblogs.com/luckyblock/p/17859464.html">https://www.cnblogs.com/luckyblock/p/17859464.html</a></p>
<p>比赛开场，队友一眼f签到题，我就直接开写了。一开始用的map，交了一发tle了。可能是专门卡了map，对常数有一定要求，合理。换了unordered_map，也被卡了。又改成sort，还是tle了。心态开始崩了。队友dztlb说改成哈希，但是哈希的实现也tle了。</p>
<p>根据之前的经验，立马换题换人上机，我再去重读题面。线性做法确实是有，很经典的贪心，但只有在解一定存在的情况下才成立。可不可能是有什么字符串的性质没有考虑到？还是单纯的题没读懂？</p>
<p>差不多抓破脑袋的时候，几条clarification连发过来。服务器处理高并发有困难，很多ac的判成tle了，官方会全部重测。</p>
<p>等了很久还在pending，于是我就去开别的题了。j题有不少人过了，又是个图论题，感觉很有把握。口了一个划分后求桥的做法，就上机开始写了。</p>
<p>写了一会f重测过了。但是队友手上的e题re了，我这边也陷入了困难。一开始选择的写法很差，把两个点集并在一起处理，代码复杂度太高，写完了发现处于根本调不了的状态。队友也分析出e是空间上出了问题，就上机开始改了。</p>
<p>只能推倒重来。采用两个优先队列分别维护，明显好写很多。第一次交wa掉了，下来和luckyblock口了一会儿，发现情况考虑的不够完备，找到结果不能直接return，需要找完所有结果。第二次提交也wa了，检查一下发现是代码复制的时候变量没改，改了下就过了。</p>
<p>a掉j题后，觉得浑身发软，就开始吃饭颓废。刚好队友g题也有做法了，就差不多发了半个小时的呆。剩下的题目就bc做出来的人多，然后开始口b。</p>
<p>口了一会儿，有了一个时间$O(n^4)$，空间$O(n^2)$的dp，但并不会进一步优化。luckyblock看了一眼c，pam模板题，拿出oiwiki直接薄纱。</p>
<p>5题了，封榜前rk68，感觉银应该是很稳了。但是有去年南京滚榜滚成铜首的经历，现在我也不敢妄作定论。于是继续推b的式子。</p>
<p>重看设的参数，发现参数之间是有关的，枚举其中两个可以直接算出第三个，就得到了时间复杂度$O(n^3)$的做法。写到一半发现，这种优化本质是以空间换时间，而现在的空间复杂度$O(n^3)$也无法接受，无法进一步优化，差不多就结束了。</p>
<p>最后滚榜还是没有重现上次的惨剧，最终拿到了银。高中的好友也拿到了他的最后一金，祝他在ec玩的开心。</p>
<p><br></p>
<p>回去后三个人都感冒了。发烧发了几天都没好，同时还要被大物实验折磨，切身感受到羁旅之苦。</p>
<p>我的xcpc生涯也快到尽头了，下一场杭州就是夕阳。无论如何，梦差不多该醒了。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>ACM</category>
        <category>游记</category>
      </categories>
      <tags>
        <tag>水文</tag>
      </tags>
  </entry>
  <entry>
    <title>sg函数</title>
    <url>/sg%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>基本博弈</p>
<span id="more"></span>
<p><a href="https://www.luogu.com.cn/problem/P2148">https://www.luogu.com.cn/problem/P2148</a></p>
<p><a href="https://www.luogu.com.cn/problem/P2252">https://www.luogu.com.cn/problem/P2252</a></p>
<p><a href="https://www.luogu.com.cn/problem/P4279">https://www.luogu.com.cn/problem/P4279</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>ACM</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
</search>
