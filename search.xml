<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2022.9.18icpc网赛摸鱼记</title>
    <url>/2022/09/21/2022.9.18icpc/</url>
    <content><![CDATA[<h4 id="2022-9-18icpc网赛"><a href="#2022-9-18icpc网赛" class="headerlink" title="2022.9.18icpc网赛"></a>2022.9.18icpc网赛</h4><p><a href="https://pintia.cn/problem-sets/1571150153619189760">https://pintia.cn/problem-sets/1571150153619189760</a></p>
<span id="more"></span>
<p>第一次参加正式的icpc比赛,尽管最近一直在打abc练手,但感觉还是力不从心.一是对icpc没有部分分的模式还不太熟悉,二是和队友的配合不够默契,三是码力下降不少,有两个本来可过的题寄了.幸亏队友还给力,一起口胡最后A掉4题.</p>
<p><br></p>
<h5 id="L"><a href="#L" class="headerlink" title="L"></a>L</h5><p>开的第一个题,第一眼就是sam之类的字符串转移,直接跑了.后来和老哥一起分析时又口胡建图,猜了一手结论:每个点只用向最近的同一字母转移.<br>建图的思路没错,但是连边的可行条件分析没分析到位,直接判是否在t串中相邻,实际上应该把t串中前后全部字母组合ban掉.于是痛挂一题.<br><br></p>
<h5 id="H"><a href="#H" class="headerlink" title="H"></a>H</h5><p>倒序开题没有思路,跟榜去做签到题.直接用栈模拟操作,1发A.<br><br></p>
<h5 id="A"><a href="#A" class="headerlink" title="A"></a>A</h5><p>乍一看毫无头绪,不过数学大佬点明了关键性质,一块连续的1只有$(len+1)/2$个”有效1”.每一个”有效1”能消掉3个元素,若一个串中”有效1”不足$1/3$,z则需要操作补1.区间染色,前缀和求和,复杂度$O(q)$.第一发T了,加了个快读就直接过了<br><br></p>
<h5 id="C"><a href="#C" class="headerlink" title="C"></a>C</h5><p>考场上队友切掉的.答案就是叶子节点个数.<br>这个做法的正确性:对于所有的叶子节点,只能采用delete.考虑整棵树对每个节点只留下一个叶子,其余的全部删掉,然后shrink所有的单链,不断重复这个过程,可以发现所有的非叶子节点都可以被shrink.可以得到需要delete的只有叶节点<br><br></p>
<h5 id="D"><a href="#D" class="headerlink" title="D"></a>D</h5><p>在考试时看假了题,以为是01个数相等,还差点误导了队友,最后s大佬切了.<br>考完再看这题才发觉是水题,直接dfs预处理,二分答案即可.<br><br></p>
<h5 id="K"><a href="#K" class="headerlink" title="K"></a>K</h5><p>由于太菜只会$n^3$dp,于是想到了记搜剪枝.但是剪枝的条件并没有思考完备,白白的写了半个小时的假题,不仅没想出怎么优化,最后甚至正确性都没有.似乎有神仙乱剪过了,后面再找std看看吧<br><br></p>
<h5 id="G"><a href="#G" class="headerlink" title="G"></a>G</h5><p>同样,由于太菜,只能想到裸暴力dp.一直在纠结$n^5$的复杂度,却忽视了选取多个连续时实际状态并不算多,写完心虚不敢久调,又浪费时间写了假题.<br><br><br>这场满打满算可以切掉7题,尽管第一次正式赛失误无可避免,但只搞掉4题还是有遗憾.根据最近打的3场比赛,目前最主要的目的并不是复习一些高级算法的用法,毕竟几乎用不到,而是多做一些dp,搜索之类的需要处理边界条件的题目,很久没做题带来的生疏大概就体现在细节不会写了吧.</p>
]]></content>
  </entry>
  <entry>
    <title>abc262</title>
    <url>/2022/09/21/abc262/</url>
    <content><![CDATA[<h1 id="abc262"><a href="#abc262" class="headerlink" title="abc262"></a>abc262</h1><p><a href="https://atcoder.jp/contests/abc262">https://atcoder.jp/contests/abc262</a></p>
<span id="more"></span>
<p>D:首先看数据范围,很明显是个$n^3$或$n^4$的题.首先枚举当前要用的数k,考虑到k的同余系下答案相等,先对序列取模,再更新背包.枚举k需要$O(n)$,序列中有n个数,每次更新背包需要$O(n^2)$,总复杂度$O(n^4)$.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">For</span>(id,<span class="number">1</span>,n)&#123;</span><br><span class="line">		ri v=ar[id]%M;</span><br><span class="line">		<span class="comment">//dp[i][j] 选用i个数,拼成剩余系下的j </span></span><br><span class="line">		<span class="built_in">iFor</span>(i,n,<span class="number">1</span>)</span><br><span class="line">		<span class="built_in">For</span>(j,<span class="number">0</span>,M<span class="number">-1</span>)&#123;</span><br><span class="line">			dp[i][j]=(dp[i][j]+dp[i<span class="number">-1</span>][(j-v+M)%M])%MOD;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans=(ans+dp[M][<span class="number">0</span>])%MOD; <span class="comment">//最后答案为用M个数拼成0</span></span><br></pre></td></tr></table></figure>
<p>E:考虑所有标记过点的出度总和S,与标记过点相连的同色的边数R,不同色的边数D,满足$S=D+2R$,即若D为偶数,则S必为偶数.于是原问题可转化为从原图中选出若干点,使其出度总和为偶数,求方案数.此时点的出度可直接分为奇偶,组合数求和即可<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(ri i=<span class="number">0</span>;i*<span class="number">2</span>&lt;=k;++i) ans=(ans+<span class="built_in">C</span>(c[<span class="number">0</span>],k-i*<span class="number">2</span>)*<span class="built_in">C</span>(c[<span class="number">1</span>],i*<span class="number">2</span>)%MOD)%MOD;</span><br></pre></td></tr></table></figure></p>
<p>F:根据字典序,找出k能到达的范围内最小值lead.如果选择转动操作,需要转动的点仅在lead后方.这样仅用分两种情况讨论,直接删和转后再删.对于直接删的情况,维护一个单调栈,每次更新时执行删除操作.<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For(i,1,n)&#123;</span><br><span class="line">		while(p&amp;&amp;ar[i]&lt;ar[sta1[p]]&amp;&amp;r)--r,--p;</span><br><span class="line">		++p,sta1[p]=i;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><br>如果旋转,旋转后的点删除不需要花费<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(p&amp;&amp;ar[i]&lt;ar[sta2[p]]&amp;&amp;(r&gt;=(sta2[p]&lt;ld)))r-=(sta2[p]&lt;ld),--p;</span><br><span class="line">		++p,sta2[p]=i;</span><br></pre></td></tr></table></figure><br>最后比较两个答案的大小即可</p>
]]></content>
  </entry>
  <entry>
    <title>Hello world</title>
    <url>/2022/07/17/hello-world/</url>
    <content><![CDATA[<h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><p>时隔两年，终于成功的搭建了hexo博客，中途踩坑无数，希望这是最后一个helloworld</p>
]]></content>
  </entry>
  <entry>
    <title>单调数据结构小结</title>
    <url>/2022/09/16/%E5%8D%95%E8%B0%83/</url>
    <content><![CDATA[<p>复建的第一步!虽然仅仅水了一些单调栈和单调队列的题</p>
<span id="more"></span>
<h5 id="abc262-F"><a href="#abc262-F" class="headerlink" title="abc262 F"></a>abc262 F</h5><p><a href="https://atcoder.jp/contests/abc262/tasks/abc262_f">https://atcoder.jp/contests/abc262/tasks/abc262_f</a><br>根据字典序,找出k能到达的范围内最小值lead.如果选择转动操作,需要转动的点仅在lead后方.这样仅用分两种情况讨论,直接删和转后再删.对于直接删的情况,维护一个单调栈,每次更新时执行删除操作.<br><!-- more --></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">		<span class="keyword">while</span>(p&amp;&amp;ar[i]&lt;ar[sta1[p]]&amp;&amp;r)--r,--p;</span><br><span class="line">		++p,sta1[p]=i;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>如果旋转,旋转后的点删除不需要花费<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(p&amp;&amp;ar[i]&lt;ar[sta2[p]]&amp;&amp;(r&gt;=(sta2[p]&lt;ld)))</span><br><span class="line">	r-=(sta2[p]&lt;ld),--p;</span><br><span class="line">++p,sta2[p]=i;</span><br></pre></td></tr></table></figure><br>最后比较两个答案的大小即可<br><br><br></p>
<h5 id="某大佬原创题"><a href="#某大佬原创题" class="headerlink" title="某大佬原创题"></a>某大佬原创题</h5><p>长度为n的数组 q个询问 每次询问给出一个长度L，最大化长度为L的连续子序列的最小值,$n,q\leq5e6,a_i\leq1e9$<br><br><br>对于每个点,可以记录成为min值的区间左右端点并更新答案,同时短区间的答案可由长区间继承.<br>关于这个做法的正确性,就是考虑是否每个点都对每个区间的答案进行过更新.对于长度大于$len=r-l+1$的区间,即使更新也不会使答案更优,没有必要考虑.对于长度短于$len$的区间,直接从比较过后的长区间继承,可以保证所有短区间都被更新到.<br>这样答案满足完全覆盖,不存在漏解的情况</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n) ans[r[i]-l[i]+<span class="number">1</span>]=<span class="built_in">max</span>(ans[r[i]-l[i]+<span class="number">1</span>],h[i]);</span><br><span class="line"><span class="built_in">iFor</span>(i,n<span class="number">-1</span>,<span class="number">1</span>) ans[i]=<span class="built_in">max</span>(ans[i],ans[i+<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<p><br><br></p>
<h5 id="luoguP1250"><a href="#luoguP1250" class="headerlink" title="luoguP1250"></a>luoguP1250</h5><p><a href="https://www.luogu.com.cn/problem/P1950">https://www.luogu.com.cn/problem/P1950</a></p>
<p>首先可以发现若将每一行分别作为常规单调栈矩形计数的问题,并不会影响上下层的结果,并且可以直接继承高度信息.于是就转化为做n次单调栈.<br>值得注意的是对于相连的等高项的处理,如果l[i],r[i]均只记录第一个更低位置,那么对于等高的i,i+1,这个区间内的矩形会重复计数.所以需要一个严格单调一个不严格来保证不重<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(tp2&amp;&amp;h[st2[tp2]]&gt;=h[j])&#123;</span><br><span class="line">				l[st2[tp2]]=j+<span class="number">1</span>,--tp2;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="keyword">while</span>(tp1&amp;&amp;h[st1[tp1]]&gt;h[j])&#123;</span><br><span class="line">				r[st1[tp1]]=j<span class="number">-1</span>,--tp1;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br></p>
<h5 id="HNOI2008水平可见直线"><a href="#HNOI2008水平可见直线" class="headerlink" title="HNOI2008水平可见直线"></a>HNOI2008水平可见直线</h5><p><a href="https://vijos.org/d/newbzoj/p/590c9879d3d8a13210993730">https://vijos.org/d/newbzoj/p/590c9879d3d8a13210993730</a><br>这题的本质就是半平面交.先按照斜率对全部直线排序,再依次塞入单调栈.被遮挡可以分为两种情况:1.k相同.那么b更大者一定更优;2.当前直线比栈顶直线位置更优,计算交点位置判断即可.<br><br><br></p>
<h5 id="luoguP2216"><a href="#luoguP2216" class="headerlink" title="luoguP2216"></a>luoguP2216</h5><p><a href="https://www.luogu.com.cn/problem/P2216">https://www.luogu.com.cn/problem/P2216</a></p>
<p>这题很显然是一个二维的滑动窗口.用n个单调队列维护每一行合法值,再将每一行最值塞进一个维护列的单调队列,每次移动后重置.每个点只会被扫描一次,复杂度$O(n^2)$<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">xq.<span class="built_in">reset</span>(),nq.<span class="built_in">reset</span>();</span><br><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,a) mxq[i].<span class="built_in">pb</span>(ar[i][rt],rt),mnq[i].<span class="built_in">pb</span>(ar[i][rt],rt);</span><br><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n<span class="number">-1</span>) xq.<span class="built_in">pb</span>(mxq[i].<span class="built_in">vl</span>(),i),nq.<span class="built_in">pb</span>(mnq[i].<span class="built_in">vl</span>(),i);</span><br><span class="line"><span class="built_in">For</span>(i,n,a)&#123;</span><br><span class="line">	xq.<span class="built_in">pb</span>(mxq[i].<span class="built_in">vl</span>(),i),nq.<span class="built_in">pb</span>(mnq[i].<span class="built_in">vl</span>(),i);</span><br><span class="line">	ans=<span class="built_in">min</span>(ans,xq.<span class="built_in">vl</span>()-nq.<span class="built_in">vl</span>());</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br><br></p>
]]></content>
  </entry>
  <entry>
    <title>数学归纳悖论</title>
    <url>/2022/09/28/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%82%96%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="数学归纳悖论"><a href="#数学归纳悖论" class="headerlink" title="数学归纳悖论"></a>数学归纳悖论</h1><span id="more"></span>
<p><br></p>
<h3 id="蓝眼睛问题"><a href="#蓝眼睛问题" class="headerlink" title="蓝眼睛问题"></a>蓝眼睛问题</h3><p>在一个岛上,有n个蓝眼睛的人,m个黄眼睛的人.一日一名游客前来游玩,聊天的时候说:你们中有人和我一样有蓝眼睛.知道自己有蓝眼睛的人会沮丧地紫砂.那么这个岛上的人多长时间后可以知道自己眼睛的颜色呢?</p>
<p>在有人做出回应前,所有人都只会沉思.随着大家又沉默了一个时刻,唯一可以得到的新信息就是大家又沉默了一个时刻.似乎无从下手,先从最简单的情况看看.</p>
<p>若n=1,则唯一的蓝眼睛拥有者会立刻知道自己拥有蓝眼睛,在$t=1$时刻直接紫砂</p>
<p>若n=2,两名蓝眼睛拥有者看到没人在第一时间紫砂,又能看到除自己外仅有以为蓝眼睛拥有者,于是可以肯定自己为蓝眼睛,在$t=2$时刻紫砂.</p>
<p>若n=3,对任意一名蓝眼睛的人来说,如果假设自己是黄眼睛,那么就能看到$t=2$时刻人群中剩下的两个蓝眼睛的人同时紫砂.而这个事件并没有发生,于是在$t=3$时刻推出自己也为蓝眼睛,三个人同时紫砂.</p>
<p>当n&gt;3,可以按照这个假设的方法,对人们沉默的轮数进行递归计算.假设自己是黄眼睛,那么所看见的n-1个蓝眼睛的人应该在n-1时刻同时紫砂.根据观察的事实相反,可以推出所有的蓝眼睛人在第n个时刻一起知道自己眼睛的颜色.</p>
<p>沉默的是本题唯一的可更新信息,比起传统的信息,不如说是一个面对所有人的广播,公开自己的推理结果.在一开始,当不止一个蓝眼睛人时,虽然每个人都知道有蓝眼睛人,但并不知道其他人知不知道有没有蓝眼睛,也不知道其他人知不知道自己知不知道有没有蓝眼睛,很像三体里的猜疑链.而游客的话打破了这个无限的猜疑链,让所有人的信息都同时对对方公开,此后的沉默都不只是单纯的个人推理结果,而是彼此可以再次利用的条件.</p>
<p>某大佬将这两个称为“强共识”和“弱共识”.在游客发言之前,“岛上有蓝眼人”是一个弱共识,或者说沉默共识,但不是一个强共识,或者说公开共识.在游客发言之后,“岛上有蓝眼人”被提升成了一个强共识,或者说公开共识.强共识包含了比弱共识更多的信息,所以当然可以导致更多的后果.<br><br></p>
<h3 id="三人猜数"><a href="#三人猜数" class="headerlink" title="三人猜数"></a>三人猜数</h3><p><a href="https://www.luogu.com.cn/problem/P5779">https://www.luogu.com.cn/problem/P5779</a><br>题意:三个人头上各有一个正整数,每个人只能看到其他两人头上的数,并且有一人头上的数是另两人头上数的和,三人一言不发猜数,最后第n轮时有一个人知道了自己头上的数m.求所有可能的数字组合.还有一个<del>似乎很好推出的</del>结论:数最大者最先猜到.</p>
<p>乍一看毫无思绪.<del>怎么看都不会做啊.</del>三个人之间傻看着,除了沉默,没有产生任何新的信息.就算有这个结论,也只能把确定有m-1个组合,如何验证每个组合的可行性呢?</p>
<p>从最简单的情况入手,假如第一个人看到其他两个人的数相等,由于自己的数不可能是0,就可以推出自己的数为其余二人数的和.即</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>)-&gt;n=<span class="number">1</span>,m=<span class="number">2</span>;</span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)-&gt;n=<span class="number">2</span>,m=<span class="number">2</span>;</span><br><span class="line">(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>)-&gt;n=<span class="number">3</span>,m=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>对于更复杂的情况,由于每个人的数只可能是$a+b,|a-b|$.可以考虑像蓝眼睛问题一样,先假设自己的数是$|a-b|$,如果被证伪,那么自己的数肯定是$a+b$.然后就可以把问题转移到前一个猜数的人,如果在自己为$|a-b|$的条件下,前面的人无法得出结果,那么这个猜测就不可行.于是可以递归处理.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(p==<span class="number">1</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(v2==v3) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(v2&gt;v3) <span class="keyword">return</span> <span class="built_in">dfs</span>(v2-v3,v2,v3,<span class="number">2</span>)+<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">dfs</span>(v3-v2,v2,v3,<span class="number">3</span>)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="number">2</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(v1==v3) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(v1&gt;v3) <span class="keyword">return</span> <span class="built_in">dfs</span>(v1,v1-v3,v3,<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">dfs</span>(v1,v3-v1,v3,<span class="number">3</span>)+<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="number">3</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(v1==v2) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">if</span>(v2&gt;v1) <span class="keyword">return</span> <span class="built_in">dfs</span>(v1,v2,v2-v1,<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">dfs</span>(v1,v2,v1-v2,<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而唯一可以用于判断的量化标准就是沉默的轮数.对于一组数,仅当有人猜出来的轮数与给定的n轮相同,才能成为可行解.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="number">1</span>)<span class="keyword">if</span>(<span class="built_in">dfs</span>(m,i,m-i,<span class="number">1</span>)==n)++T,ans[T].a=m,ans[T].b=i,ans[T].c=m-i;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="number">2</span>)<span class="keyword">if</span>(<span class="built_in">dfs</span>(i,m,m-i,<span class="number">2</span>)==n)++T,ans[T].a=i,ans[T].b=m,ans[T].c=m-i;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="number">3</span>)<span class="keyword">if</span>(<span class="built_in">dfs</span>(i,m-i,m,<span class="number">3</span>)==n)++T,ans[T].a=i,ans[T].b=m-i,ans[T].c=m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><br><del>信息真神奇啊</del></p>
]]></content>
  </entry>
  <entry>
    <title>线段树练习</title>
    <url>/2022/09/23/%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="线段树练习"><a href="#线段树练习" class="headerlink" title="线段树练习"></a>线段树练习</h1><p>做了几题思维难度并不算太高的线段树题目,难点就是有巨巨巨多细节要注意.</p>
<span id="more"></span>
<h2 id="luoguP6327区间sin和"><a href="#luoguP6327区间sin和" class="headerlink" title="luoguP6327区间sin和"></a>luoguP6327区间sin和</h2><p><a href="https://www.luogu.com.cn/problem/P6327">https://www.luogu.com.cn/problem/P6327</a></p>
<p>题意:每次修改一个点,求区间sin值的和<br>区间sin和的信息不可加,但可以考虑和差化积公式,</p>
<script type="math/tex; mode=display">
sin(x+v)=sin(x)cos(v)+sin(v)cos(x)\\
cos(x+v)=cos(x)cos(v)-sin(x)sin(v)</script><p>同时记录cos和sin值就可以转化为线段树求和.<br>由于节点的tag不能直接和子节点的和相加,需要注意每次询问时先下放标签.还有浮点运算的常数极大,下放时先判一下0,不然很容易tle.<br><br></p>
<h2 id="luoguP1471方差"><a href="#luoguP1471方差" class="headerlink" title="luoguP1471方差"></a>luoguP1471方差</h2><p><a href="https://www.luogu.com.cn/problem/P1471">https://www.luogu.com.cn/problem/P1471</a></p>
<p>题意:每次修改一个点,求区间平均数和方差<br>首先是平均数的合并$a_3=(a_1n_1+a_2n_2)/(n_1+n_2)$<br>再考虑方差的更改,每次修改时可以$O(1)$的更新</p>
<script type="math/tex; mode=display">
D_1=\frac 1n\Sigma(x_i-a_1)^2\\
D_2=\frac 1n\Sigma(x_i+v-a_2)^2\\
D_2-D_1=\frac 1n\Sigma((x_i+v-a_2)^2-(x_i-a_1)^2)\\
       =\frac 1n\Sigma(v^2+a_2^2+2x_iv-2a_2v-2a_2x_i-a_1^2+2x_ia_1)\\
       =v^2+a_2^2-a_1^2-2a_2v+(2v-2a_2+2a_1)\frac 1n \Sigma x_i\\
       =v^2+a_2^2-a_1^2-2a_2v+2a_1v-2a_1a_2+2a_1^2\\
       =a_1^2+a_2^2+v^2+2a_1v-2a_2v-2a_1a_2</script><p>最后是方差的合并</p>
<script type="math/tex; mode=display">
D_1=\frac 1{n_1}\Sigma(x_1i-a_1)^2\\
D_2=\frac 1{n_2}\Sigma(x_2i-a_2)^2\\
D_3=\frac 1{n_1+n_2}\Sigma(x_i-a_3)^2\\
(n_1+n_2)D_3-D_1n_1-D_2n_2=\Sigma((x_i-a_3)^2-(x_i-a_j)^2)(j=1,2)\\
                          =\Sigma(a_3^2-a_j^2+2x_i(a_j-a_3))\\
                          =n_1(a_3^2-a_1^2)+2n_1a_1(a_1-a_3)\\
                          +n_2(a_3^2-a_2^2)+2n_2a_2(a_2-a_3)\\
                          =n_1a_1^2+n_2a_2^2-(n_1+n_2)a_3^2</script><p>最后特别要注意在合并方差时跨中点情况的判断,左右两段的长度应该取min(当前区间长度,询问区间长度)<br><br></p>
<h2 id="luoguP5142区间方差"><a href="#luoguP5142区间方差" class="headerlink" title="luoguP5142区间方差"></a>luoguP5142区间方差</h2><p><a href="https://www.luogu.com.cn/problem/P5142">https://www.luogu.com.cn/problem/P5142</a><br>基本与上题相同.longlong本身常数大,全局还带了一个$O(logn)$的求逆,无脑取模会t飞.本题需要先处理出inv数组,还要取模时判断优化,以免被卡常.<br><br></p>
<h2 id="What-a-Colorful-Wall"><a href="#What-a-Colorful-Wall" class="headerlink" title="What a Colorful Wall"></a>What a Colorful Wall</h2><p><a href="https://codeforces.com/gym/103443/problem/F">https://codeforces.com/gym/103443/problem/F</a></p>
<p>题意:n个有颜色的矩形按顺序放在平面上,被覆盖的部分颜色不可见,求最后可见的颜色数</p>
<p>矩形覆盖的问题很自然想到扫描线,先把矩形离散,按x坐标排序,并拆分为加入线段和删除线段两部分.线段树维护y轴,每个时刻先增删线段,每个节点挂一个可删堆维护当前区间内时间最大矩形的颜色,最后dfs全树,查询当前时刻能看到颜色种类.每次查询复杂度$O(nlogn)$,总共有n次询问,总复杂度$O(n^2logn)$,可以勉强卡过.<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//黑科技可删堆</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HEAP</span>&#123;</span><br><span class="line">    priority_queue &lt;pii&gt; p,q;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(pii x)</span></span>&#123;p.<span class="built_in">push</span>(x);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(pii x)</span></span>&#123;q.<span class="built_in">push</span>(x);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mt</span><span class="params">()</span></span>&#123;<span class="keyword">while</span>(p.<span class="built_in">size</span>()&amp;&amp;q.<span class="built_in">size</span>()&amp;&amp;q.<span class="built_in">top</span>()==p.<span class="built_in">top</span>())p.<span class="built_in">pop</span>(),q.<span class="built_in">pop</span>();&#125;</span><br><span class="line">    <span class="function">pii <span class="title">top</span><span class="params">()</span></span>&#123;<span class="built_in">mt</span>();<span class="keyword">return</span> p.<span class="built_in">top</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;<span class="built_in">mt</span>();<span class="keyword">return</span> p.<span class="built_in">empty</span>();&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//此处和通常的线段树稍有不同,由于维护的实际上是矩形的边,表示颜色块需要边界-1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr) &#123;ar[p].<span class="built_in">add</span>(qii);<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;mid) <span class="built_in">add</span>(ls,l,mid);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;qr) <span class="built_in">add</span>(rs,mid,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr) &#123;ar[p].<span class="built_in">del</span>(qii);<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;mid) <span class="built_in">del</span>(ls,l,mid);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;qr) <span class="built_in">del</span>(rs,mid,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,pii pi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!ar[p].<span class="built_in">empty</span>()) pi=<span class="built_in">max</span>(pi,ar[p].<span class="built_in">top</span>());</span><br><span class="line">    <span class="keyword">if</span>(r-l==<span class="number">1</span>)&#123;ans[pi.second]=<span class="number">1</span>;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="built_in">dfs</span>(ls,l,mid,pi),<span class="built_in">dfs</span>(rs,mid,r,pi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    po=<span class="built_in">pii</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">For</span>(i,<span class="number">1</span>,ttx)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:vad[i]) qii=<span class="built_in">pii</span>(x.id,ocl[x.id]),ql=x.l,qr=x.r,<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>,tty);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:vde[i]) qii=<span class="built_in">pii</span>(x.id,ocl[x.id]),ql=x.l,qr=x.r,<span class="built_in">del</span>(<span class="number">1</span>,<span class="number">1</span>,tty);</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>,tty,po);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;<span class="built_in">For</span>(i,<span class="number">1</span>,n)cnt+=ans[i];</span><br><span class="line">    cout&lt;&lt;cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>一个更好的做法就是在每个时刻维护每种颜色可见的总长度,直接在增删线段时更新,不需要再dfs,复杂度$O(nlogn)$.</p>
<p>需要注意的是,如果直接用二维线段树或外层暴力内层线段树,虽然理论复杂度是$O(n^2logn)$的,但是常数巨大,无法通过(存疑).</p>
]]></content>
  </entry>
</search>
